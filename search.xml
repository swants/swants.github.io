<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Swift Struct References]]></title>
    <url>%2F2017%2F08%2F27%2FSwift-Struct-References%2F</url>
    <content type="text"><![CDATA[译文出自：掘金翻译计划 译者： Swants 校对者： ChenDongnan FlyOceanFish Swift 结构体指针 所有的代码都可以在 gist 上获取。 最近我打算为 Swift 的最新的 keypaths 找一个好的使用场景，这篇文章介绍了我意外获得的一个使用示例。这是我刚研究出来的，但还没实际应用在生产代码上的成果。也就是说，我只是觉得这个成果非常酷并想把它展示出来。 思考一个简单的通讯录应用，这个应用包含一个展示联系人的列表视图和展示联系人实例的详情视图控制器。如果把 人 定义成一个类的话，大概是这个样子： class Person {var name: Stringvar addresses: [Address]init(name: String, addresses: [Address]) {self.name = nameself.addresses = addresses}} class Address {var street: Stringinit(street: String) {self.street = street}} 我们的（假设）viewController 有一个通过初始化方法设置的 person 属性。这个类还有一个 change 方法来修改这个人的属性。 final class PersonVC {var person: Personinit(person: Person) {self.person = person} func change() {person.name = “New Name”}} 让我们思考下当 Person 初始化为一个对象后遇到的问题： 因为 person 是一个指针，其他部分的代码就可能修改它。这是非常实用的，因为这让消息传递成为了可能。而与此同时，我们需要保证我们可以一直监听的到这些改变（比如使用 KVO ），否则我们可能会遇到数据不同步的问题。但保证我们能够实时监听则是不容易实现的。 当地址发生变化时，收到通知就更难了。观察嵌套的对象属性则是最困难的。 如果我们需要给 Person 创建一个独立的本地 copy，我们就需要实现一些像 NSCopying 这样的东西， 这需要不少的工作量。甚至当我们决定这么做时，我们仍然不得不考虑是想要深拷贝（地址也被拷贝）还是浅拷贝（地址数组是独立的，但是里面的地址仍指向相同的对象）？ 如果我们把 Person 当成 AddressBook 数组的元素，我们可能想要知道通讯录什么时候做了修改（比如说进行排序）。而想要知道你的对象图中的东西何时做了改变要么需要大量的样板，要么需要大量的观察。 如果 Person 和 Address 做成结构体的话，我们又会碰到不同的问题： 每个结构体都是独立的拷贝。这是有用的，因为我们知道它总是一致的，不会在我们手底下改变。然而，当我们在详情控制器 中对 Person 做了修改时。我们就需要一个方法来将这些改变反馈给列表视图（或者说通讯录列表）。而对于对象，这种情况会自动发生（通过在适当的位置修改 Person ）。 我们可以观察通讯录结构体的根地址，从而知道通讯录发生的任何变化。然而，我们还是不能很容易得观察到它内部属性的变化（比如：观察第一个人的名字）。 我现在提出的解决方案结合了两个方案的最大优势： 我们有可变的共享指针 因为底层数据是结构体，所以我们可以随时得到我们自己的独立拷贝 我们可以观察任何部分：无论在根级别，还是观察独立的属性（例如第一个人的名字） 我接下来会演示这个方案怎么使用，如何工作，最后再说说方案的局限性和问题。 让我们用结构体来创建一个通讯录。 struct Address {var street: String}struct Person {var name: Stringvar addresses: [Address]} typealias Addressbook = [Person] 现在我们可以使用我们的 Ref 类型（ Reference 的简称）。我们用一个初始化的空数组来创建一个新的 addressBook。然后添加一个 Person 。接下来就是最酷的地方：通过使用下标我们可以获得指向第一个人的 指针 ，接着是一个指向他们名字的 指针 。我们可以将指针指向的内容改为 “New Name&quot; 来验证我们是否更改了原始的通讯录。 let addressBook = Ref(initialValue: [])addressBook.value.append(Person(name: “Test”, addresses: []))let firstPerson: Ref = addressBook[0]let nameOfFirstPerson: Ref = firstPerson[.name]nameOfFirstPerson.value = “New Name”addressBook.value // shows [Person(name: “New Name”, addresses: [])] firstPerson 和 nameOfFirstPerson 类型可以被忽略，它们仅仅是为了增加代码可读性。 无论何时我们都可以对 Person 内容进行独立备份。一旦你做了拷贝，我们就可以使用 myOwnCopy ，并且不必实现 NSCopying 就能保证它的内容不会在我们手底下改变： var myOwnCopy: Person = firstPerson.value 我们可以监听任何 Ref 。就像 reactive 库一样，我们得到了一个可以控制观察者生命周期的一次性调用： var disposable: Any?disposable = addressBook.addObserver { newValue inprint(newValue) // Prints the entire address book} disposable = nil // stop observing 我们也可以监听 nameOfFirstPerson 。在目前的实现中，无论什么时候通讯录中的任何改变都会触发监听，但以后的实现会有更多的功能。 nameOfFirstPerson.addObserver { newValue inprint(newValue) // Prints a string} 让我们返回我们的 PersonVC 。我们可以使用 Ref 作为他的实现。 这样 viewController 就可以收到每一次更改。在响应式编程中，信号通常是只读类型的（你只会收到发生了变化的信息），这时你就需要找到另一种回传信号的方法。 在 Ref 方案中，我们可以使用 person.value 进行回写： final class PersonVC {let person: Refvar disposeBag: Any?init(person: Ref) {self.person = persondisposeBag = person.addObserver { newValue inprint(“update view for new person value: (newValue)”)}} func change() {person.value.name = “New Name”}} 这个 PersonVC 不知道 Ref &lt;Person&gt;是从哪里获得的：是从一个 person 数组，一个数据库或者其他地方。实际上，我们可以通过将我们的数组包装在 History 结构体 中来撤销对我们通讯录的支持。这样我们就不再需要修改 PersonVC： let source: Ref]]></content>
  </entry>
  <entry>
    <title><![CDATA[Swift 中的通用数据源]]></title>
    <url>%2F2017%2F08%2F14%2FSwift-%E4%B8%AD%E7%9A%84%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E6%BA%90%2F</url>
    <content type="text"><![CDATA[译文出自：掘金翻译计划 译者： Swants 校对者： iOSleep 在我开发的绝大多数 iOS app 中， tableView 和 collectionView 绝对是最常用的 UI 组件。鉴于设置一个 tableView 或 collectionView 需要大量样板代码，我最近花了些时间找到一个比较好的方法，去避免一遍又一遍地重复同样的代码。我的主要工作是对必需的样板代码进行抽取封装。随着时间的推移，很多其他开发者也解决了这个问题。并且随着 Swift 的最新进展出现了很多有趣的解决方案。 本篇文章里，我将介绍在我 APP 里已经使用了一段时间的解决方案，这个方案让我在设置 collectionView 的时候减少了大量的样板代码。 TableView vs CollectionView有些人可能会问 为什么单讨论 collectionView 而不提 tableView 呢? 在最近的几个月里，我在之前可以使用 tableView 的地方都使用成了 collectionView 。它们到目前为止表现良好！这一做法帮助我不用去区分这两个 几乎完全 相似但并不完全相同的集合概念。接下来则是让我做出这一决定的根本原因： 任何 tableView 都可以用单列的 collectionView 进行实现/重构。 tableView 在大屏幕上（如：iPad ）表现的不是特别好。 需要说明的是，我没有建议你把代码库里所有的 tableView 都用 collectionView 重新实现。我建议的是，当你需要添加一个展示列表的新功能时，你应该考虑下使用 collectionView 来代替 tableView 。尤其是在你开发一个 Universal APP 时，因为 collectionView 将让你的 APP 在所有尺寸屏幕上动态调整布局变得更简单。 Swift 泛型与有效抽取的探索我一直是泛型编程的拥趸，所以你能想象的到当苹果宣布在 Swift 中引进泛型时，我是多么的兴奋。但是泛型和协议结合有时并不合作的那么和谐。这时 Swift 2.x 中关于 关联类型 的介绍让使用泛型协议变得更加简单，越来越多的开发者开始去尝试使用它们。 我打算展示的代码抽取是基于对泛型使用的尝试，尤其是泛型协议。这样的代码抽取能够让我对设置 collectionView 所需的样板代码进行封装，从而减少设置数据源所需的代码，甚至在一些简单的使用场景两行代码就足够了。 我想说明下我所创建的不是通解。我做的代码封装针对于解决一些特定使用场景。对于这些场景来说，使用抽取封装后的代码效果非常好。对于一些复杂的使用场景，可能就需要添加额外的代码了。我把抽取工作主要放在了 collectionView 最常用的功能。如果需要的话，你可以封装更多的功能，但是对于我的特定场景来说，这并不是必需的。 作为本篇文章的目的，我将会展示一部分抽取代码来概括使用 collectionView 时常用的功能。这将是你了解使用泛型，尤其是泛型协议能够来做什么的一个好的机会。 Collection View Cell 抽取首先，我实现 collectionView 通常都是先创建展示数据的 cell 。处理 collectionView 的 cell 时通常需要： 重用 cell 配置 cell 为了简化上面的工作，我写了两个协议： ReusableCell ConfigurableCell 让我们详细地看一下这两个抽取后代码吧。 ReusableCell这个 ReusableCell 协议需要你定义一个 重用标识符 ，这个标志符将在重用 cell 的时候被用到。在我的 APP 里，我总是图方便把 cell 的重用标识符设置为和 cell 的类名一样。因此，很容易通过创建一个协议扩展来抽取出，让 reuseIdentifier 返回一个带有类名称的字符串： 123456789public protocol ReusableCell &#123; static var reuseIdentifier: String &#123; get &#125;&#125;public extension ReusableCell &#123; static var reuseIdentifier: String &#123; return String(describing: self) &#125;&#125; ConfigurableCell这个 ConfigurableCell 协议需要你实现一个方法，这个方法将使用特定类型的实例配置 cell ,而这个实例被定义成了一个泛型类型 T: 12345public protocol ConfigurableCell: ReusableCell &#123; associatedtype T func configure(_ item: T, at indexPath: IndexPath)&#125; 这个 ConfigurableCell 协议将会在加载 cell 内容的时候被调用。接下来我会详细介绍一些细节，现在我就强调下一些地方： ConfigurableCell 继承 ReusableCell 绑定类型的使用（ 绑定类型 T ）将 ConfigurableCell 定义为泛型协议。 数据源的抽取: CollectionDataProvider现在，让我们把目光收回，再回想下设置 collection view 都需要做些什么。为了让 collection view 展示内容，我们需要遵循 UICollectionViewDataSource 协议。那么最先要做的常常是确定下来这些: 需要几组：numberOfSections(in:) 每组需要几行：collectionView(_:numberOfItemsInSection:) cell 的内容怎么加载 ：collectionView(_:cellForItemAt:) 将上述代理方法实现，会确保我们能够对指定 collectionView 的 cell 进行展示 。而对于我来说，这里是非常适合进行代码抽取的地方。 为了抽取和封装上述步骤，我创建了以下泛型协议： 123456789public protocol CollectionDataProvider &#123; associatedtype T func numberOfSections() -&gt; Int func numberOfItems(in section: Int) -&gt; Int func item(at indexPath: IndexPath) -&gt; T? func updateItem(at indexPath: IndexPath, value: T)&#125; 这个协议前三个方法是： numberOfSections() numberOfItems(in:) item(at:) 他们指明了遵循 UICollectionViewDataSource 协议需要实现的代理方法列表。基于我有过一些当用户交互后需要更新数据源的使用场景，我在最后又加了一个 (updateItem(at:, value:)) 方法。这个方法允许你在需要的时候更新底层数据。到这里，在 CollectionDataProvider 定义的方法满足了遵循 UICollectionViewDataSource 协议时需要实现的常用功能。 封装样板: CollectionDataSource通过上面的抽取，现在可以开始实现一个基类，这个基类将被封装为 collectionView 创建数据源所需的常用样板。这就是最神奇地方！这个类的主要作用就是利用特定的 CollectionDataProvider 和 UICollectionViewCell 来满足遵循 UICollectionViewDataSource 协议所需要实现的方法。 这是这个类的定义： 123456open class CollectionDataSource&lt;Provider: CollectionDataProvider, Cell: UICollectionViewCell&gt;: NSObject, UICollectionViewDataSource, UICollectionViewDelegate, where Cell: ConfigurableCell, Provider.T == Cell.T&#123; [...] &#125; 它为我们做了很多事： 这个类有一个公有属性，让我们能够将它扩展为指定 CollectionDataProvider 提供正确的实现。 这是一个泛型的类，所以它需要特定的 Provider (CollectionDataProvider) 和 Cell (UICollectionViewCell) 对象进一步的定义来使用。 这个类继承于 NSObject 基类，所以能够遵循 UICollectionViewDataSource 和 UICollectionViewDelegate 来进行抽取封装样板代码。 这个类在以下场景使用的时候有一些特定限制： UICollectionViewCell 必须遵循 ConfigurableCell 协议。（ Cell: ConfigurableCell ） 特定类型 T 必须和 cell 跟 Provider 的 T 相同 (Provider.T == Cell.T)。 代码需要像下面一样对 CollectionDataSource 进行初始化和设置： 12345678910111213141516// MARK: - Private Propertieslet provider: Providerlet collectionView: UICollectionView// MARK: - Lifecycleinit(collectionView: UICollectionView, provider: Provider) &#123; self.collectionView = collectionView self.provider = provider super.init() setUp()&#125;func setUp() &#123; collectionView.dataSource = self collectionView.delegate = self&#125; 代码是非常简单的：CollectionDataSource 需要知道它将针对哪个 collectionView 对象，将根据哪个作为数据提供者。这些问题都是通过 init 方法的参数进行传递确定的。在初始化的过程中，CollectionDataSource 将自己设置为 UICollectionViewDataSource 和 UICollectionViewDelegate 的代理对象(在 setUp 方法中)。 现在让我们看一下 UICollectionViewDataSource 代理的样板代码。 这是代码： 12345678910111213141516171819202122// MARK: - UICollectionViewDataSourcepublic func numberOfSections(in collectionView: UICollectionView) -&gt; Int &#123; return provider.numberOfSections()&#125;public func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return provider.numberOfItems(in: section)&#125;open func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell&#123; guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: Cell.reuseIdentifier, for: indexPath) as? Cell else &#123; return UICollectionViewCell() &#125; let item = provider.item(at: indexPath) if let item = item &#123; cell.configure(item, at: indexPath) &#125; return cell&#125; 上面的代码片段通过 CollectionDataProvider 的一个对象展示了 UICollectionViewDataSource 代理的主要实现，就像之前所说的那样，它封装了数据源实现的所有细节。每个代理都使用指定的 CollectionDataProvider 方法来抽取跟数据源之间进行交互。 注意 collectionView(_:cellForItemAt:) 方法有一个公开的属性，这就能够让它的任何子类在需要对 cell 内容进行更多定制化的时候进行扩展。 现在对 collectionView cell 展示的功能已经做好了，让我们再为它添加更多的功能吧。 而作为第一个要添加的功能，用户应该能够在点击 cell 的时候触发某些操作。为了实现这个功能，一个简单的方案就是定义一个简单的 closure,并对这个 closure 初始化，当用户点击 cell 的时候执行这个 closure 。 处理 cell 点击的自定义 closure 如下所示： 1public typealias CollectionItemSelectionHandlerType = (IndexPath) -&gt; Void 现在，我们能定义个属性来存储这个 closure ，当用户点击这个 cell 的时候就会在 UICollectionViewDelegate 的 collectionView(_:didSelectItemAt:) 代理方法实现中执行这个初始化好的 closure 。 1234567// MARK: - Delegatespublic var collectionItemSelectionHandler: CollectionItemSelectionHandlerType?// MARK: - UICollectionViewDelegatepublic func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) &#123; collectionItemSelectionHandler?(indexPath)&#125; 作为第二个要添加的功能，我打算在 CollectionDataSource 中对多组组头和组的一些代码样板进行封装。这就需要实现 UICollectionViewDataSource 的代理方法 viewForSupplementaryElementOfKind 。为了能够让子类自定义的实现 viewForSupplementaryElementOfKind ，这个代理方法需要定义为公开方法，以便让任何子类能够对这个方法进行重写。 123456open func collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, at indexPath: IndexPath) -&gt; UICollectionReusableView&#123; return UICollectionReusableView(frame: CGRect.zero)&#125; 通常来说，这种方式适用于所有的代理方法，当他们需要被子类重写覆盖时，这些方法需要定义为公有方法，并在 CollectionDataSource 中实现。 另一种不同的解决方案就是使用一个自定义的 closure ，就像在 (CollectionItemSelectionHandlerType) 方法中处理 cell 点击事件一样。 我实现的这个特定方面是软件工程中的一个典型的权衡，一方面 —— 为 collectionView 设置数据源的主要细节都被隐藏（被抽取封装）。另一方面 —— 封装的样板代码中没有提供的功能，就会变得不能开箱即用，添加新的功能并不复杂，但是需要像我上面两个例子那样，需要实现更多的自定义代码。 实现一个具体的 CollectionDataProvider 也就是 ArrayDataProvider现在样板代码已经设置好了，collectionView 的数据源由 CollectionDataSource 负责。让我们通过一个普通的使用案例来看看样板代码用起来有多方便。为了做这个，CollectionDataSource 对象需要提供 CollectionDataProvider 具体的实现。一个覆盖大多数常见使用案例的基本实现，可以简单地使用二维数组来包含展示 collectionView cell 内容的数据 。作为我对数据源抽象的试验的一部分，我使这个实现变得更加通用，并且能够表示: 二维数组，每一个数组元素代表 collectionView 一组 cell 的内容。 数组，表示 collectionView 只有一组 cell 的内容（没有组头）。 上面的代码实现都包含在泛型类 ArrayDataProvider 中： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ArrayDataProvider&lt;T&gt;: CollectionDataProvider &#123; // MARK: - Internal Properties var items: [[T]] = [] // MARK: - Lifecycle init(array: [[T]]) &#123; items = array &#125; // MARK: - CollectionDataProvider public func numberOfSections() -&gt; Int &#123; return items.count &#125; public func numberOfItems(in section: Int) -&gt; Int &#123; guard section &gt;= 0 &amp;&amp; section &lt; items.count else &#123; return 0 &#125; return items[section].count &#125; public func item(at indexPath: IndexPath) -&gt; T? &#123; guard indexPath.section &gt;= 0 &amp;&amp; indexPath.section &lt; items.count &amp;&amp; indexPath.row &gt;= 0 &amp;&amp; indexPath.row &lt; items[indexPath.section].count else &#123; return items[indexPath.section][indexPath.row] &#125; return nil &#125; public func updateItem(at indexPath: IndexPath, value: T) &#123; guard indexPath.section &gt;= 0 &amp;&amp; indexPath.section &lt; items.count &amp;&amp; indexPath.row &gt;= 0 &amp;&amp; indexPath.row &lt; items[indexPath.section].count else &#123; return &#125; items[indexPath.section][indexPath.row] = value &#125;&#125; 这样做可以提取访问数据源的细节，线性数据结构可以表示 cell 的内容是最常见的使用情况。 封装到一块: CollectionArrayDataSource这样 CollectionDataProvider 协议就具体实现了，创建一个 CollectionDataSource 子类来实现最常见的简单的列表数据展示是非常容易的。 让我们从这个类的定义开始： 123open class CollectionArrayDataSource&lt;T, Cell: UICollectionViewCell&gt;: CollectionDataSource&lt;ArrayDataProvider&lt;T&gt;, Cell&gt; where Cell: ConfigurableCell, Cell.T == T &#123; [...] &#125; 这个声明定义了很多事情： 这个类有一个公有的属性，因为它最终将被扩展为 UICollectionView 对象的数据源对象。 这是一个继承 UICollectionViewCell 的泛型类，需要被特定的类型 T 进一步定义才能正确展示 cell 和 cell 的内容。 这个类扩展了 CollectionDataSource 来提供进一步的特定行为。 特定类型 T 将被表示，它将通过一个 ArrayDataProvider &lt; T &gt; 对象来访问 cell 内容。 这个类在 closure 中的定义表明有些特定的约束: UICollectionViewCell 必须遵循 ConfigurableCell 协议。（ Cell: ConfigurableCell ） cell 中的特定类型 T 必须跟 Provider 的 T 相同 (Provider.T == Cell.T) 。 类的实现非常简单： 123456789101112131415161718// MARK: - Lifecyclepublic convenience init(collectionView: UICollectionView, array: [T]) &#123; self.init(collectionView: collectionView, array: [array])&#125;public init(collectionView: UICollectionView, array: [[T]]) &#123; let provider = ArrayDataProvider(array: array) super.init(collectionView: collectionView, provider: provider)&#125;// MARK: - Public Methodspublic func item(at indexPath: IndexPath) -&gt; T? &#123; return provider.item(at: indexPath)&#125;public func updateItem(at indexPath: IndexPath, value: T) &#123; provider.updateItem(at: indexPath, value: value)&#125; 它只是提供了一些初始化方法和与交互方法，这些方法使我们能够让数据提供者与数据源透明地进行读取和写入操作。 创建一个基本的 CollectionView可以将 CollectionArrayDataSource 基类扩展，为任何可以用二维数组展示的 collection view 创建一个特定的数据源。 1class PhotosDataSource: CollectionArrayDataSource&lt;PhotoViewModel, PhotoCell&gt; &#123;&#125; 声明比较简单: 继承于 CollectionArrayDataSource 。 这个类表示 PhotoViewModel 作为特定类型 T 将会展示 cell 内容，可通过 ArrayDataProvider &lt; PhotoViewModel > 对象访问，PhotoCell 将作为 UICollectionViewCell 展示。 请注意，PhotoCell 必须遵守 ConfigurableCell 协议，并且能够通过 PhotoViewModel 实例初始化它的属性。 创建一个 PhotosDataSource 对象是非常简单的。只需要传递过去将要展示的 collectionView 和由展示每个 cell 内容的 PhotoViewModel 元素组成的数组： 1let dataSource = PhotosDataSource(collectionView: collectionView, array: viewModels) collectionView 参数通常是 storyboard 上的 collectionView 通过 outlet 指向获取到的。 所有的就完成了！两行代码就可以设置一个基本的 collectionView 数据源。 设置带有组标题和组的 CollectionView对于更高级和复杂的用例，你可以简单在 GitHub repo 上查看 TaskList 。内容已经很长了，本文就不再不介绍示例的更多细节。我将在下一篇 “Collection View with Headers and Sections” 文章里进行深入地探讨。在这个说明中，如果存在一个话题对你来说很有意思，请不要犹豫让我知道，这样我就可以优先考虑下一步写什么。为了和我联系，请在这篇文章下方留言或发邮件给我: andrea.prearo@gmail.com 。 结论在这篇文章中，我介绍了一些我做的抽取封装，以简化使用泛型数据源的 collectionView 。所提出的实现都是基于我在构建 iOS app 时遇到的重复代码的场景。一些更高级的的功能可能需要进一步的自定义。我相信，继续优化所得到的代码抽取，或者构建新的代码抽取，来简化处理不同的 collectionView 模式都是可能的。但这已经超出了这篇文章的范围。 所有的通用数据源代码和示例工程都在 GitHub 并且是遵守 MIT 协议的。你可以直接使用和修改它们。欢迎所有的反馈意见和建议的贡献，并非常感谢你这么做。如果你有足够的兴趣，我将很乐意添加所需的配置，使代码与Cocoapods和Carthage一起使用，并允许使用这种依赖关系管理工具导入通用数据源。或者，这可能是一个很好的起点去为这个项目做出贡献。 额外链接 Smooth Scrolling in UITableView and UICollectionView Boost Smooth Scrolling with iOS 10 Pre-Fetching API 披露声明：这些意见是作者的意见。 除非在文章中额外声明，否则 Capital One 版权不属于任何所提及的公司，也不属于任何上述公司。 使用或显示的所有商标和其他知识产权均为其各自所有者的所有权。 本文版权为 ©2017 Capital One 更多关于 API、开源、社区活动或开发文化的信息，请访问我们的一站式开发网站 developer.capitalone.com 。 掘金翻译计划 是一个翻译优质互联网技术文章的社区，文章来源为 掘金 上的英文分享文章。内容覆盖 Android、iOS、React、前端、后端、产品、设计 等领域，想要查看更多优质译文请持续关注 掘金翻译计划。]]></content>
  </entry>
  <entry>
    <title><![CDATA[开发者眼中 iOS 11 都更新了什么？]]></title>
    <url>%2F2017%2F07%2F07%2F%E5%BC%80%E5%8F%91%E8%80%85%E7%9C%BC%E4%B8%AD-iOS-11-%E9%83%BD%E6%9B%B4%E6%96%B0%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[译文出自：掘金翻译计划 译者： Swants 校对者： Danny1451 RichardLeeH 苹果在 2017 年全球开发者大会上公布了 iOS 11 , 其加入许多强大的功能，如 Core ML,ARKit,Vision,PDFKit,MusicKit 拖放等等。 我尝试着把主要变化在接下来的文章里总结了出来，并在可行的地方提供代码，这样你就可以直接上手。 注意： 有些地方没涉及到并不是因为懒，我已经尽我所能提供足够多的代码来帮你在应用上快速上手这些特性。但是你最终还是免不了去额外了解更多 iOS 11 中大量复杂的设计功能。 在接着读下去之前，你可能需要了解下这几篇文章： What’s new in Swift 4? What’s new in Swift 3.1? What’s new in iOS 10? What’s new in iOS 9? 你可能想购买我的新书：《 Practical iOS 11 》。 你可以通过教程的形式获得 7 个完整的项目代码，以及更多深入了解特定新技术的技术项目 - 这是熟悉 iOS 11最快的方式！ Buy Practical iOS 11 for $30 拖放拖放是我们在桌面操作系统中认为理所当然的操作，但是拖放在 iOS 上直到 iOS 11 才出现，这真的阻碍了多任务处理的发展。换句话说，在 iOS 11 上尤其是在 iPad 上，多任务处理迎来了高速发展的时代。得益于拖放成为其中很大的一部分：你可以在 APP 内部和或 APP 之间移动内容，当你拖放的时候你可以用另一只手对其他 app 进行操作.你甚至可以利用 全新的 dock 系统来激活其他 app 的中间拖动。 注意： 在 iPhone 上拖放被限制在单个 app 内 —— 你不能把内容拖放到其他 app 里。 令人欣喜的是，UITableView 和 UICollectionView 在一定程度上都支持拖拽内置。但是想要使用拖放功能仍旧需要写相当多的代码。你也可以向其他组件添加拖放支持，而且你会发现实际上这只需要少量的工作。 下面让我们来看看如何使用简单的拖放来实现在两个列表之间拷贝行内容。首先，我们需要使用一个简单的 app 。让我们写一些代码来创建两个有示例数据的 tableview 供我们拷贝。 在 Xcode 内创建一个新的单一视图 app 模板，然后打开 ViewController.swift 类进行编辑。 现在我们需要在这里放上两个含有示例数据的 tableView 。我不打算使用 IB 的方式布局， 因为全部使用代码来实现是更清楚的。顺便提一下，我 不打算 详细地解释代码，因为这都是现成的 iOS 代码，我不想浪费你的时间。 这些代码将： 创建两个 tableView ,并且创建两个分别包含Left 和 Right 元素的字符串数组。 制定两个 tableView 都使用 view controller 来作为它们的数据源，给他们写死位置宽高，注册一个可重用的 cell ，把它们两个都添加到这个 view 上。 实现 numberOfRowsInSection 方法，确保每个 table view 都根据其字符串数组有正确的行数。 实现 cellForRowAt 来排列，这时 cell根据 table 来从两个字符串数组中选出对应的数据源正确展示。 然后，这是 iOS 11 之前的所有代码，应该没有你不熟悉的代码。将 ViewController.swift 类的内容用下面的代码替换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import UIKitclass ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate &#123; var leftTableView = UITableView() var rightTableView = UITableView() var leftItems = [String](repeating: &quot;Left&quot;, count: 20) var rightItems = [String](repeating: &quot;Right&quot;, count: 20) override func viewDidLoad() &#123; super.viewDidLoad() leftTableView.dataSource = self rightTableView.dataSource = self leftTableView.frame = CGRect(x: 0, y: 40, width: 150, height: 400) rightTableView.frame = CGRect(x: 150, y: 40, width: 150, height: 400) leftTableView.register(UITableViewCell.self, forCellReuseIdentifier: &quot;Cell&quot;) rightTableView.register(UITableViewCell.self, forCellReuseIdentifier: &quot;Cell&quot;) view.addSubview(leftTableView) view.addSubview(rightTableView) &#125; func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; if tableView == leftTableView &#123; return leftItems.count &#125; else &#123; return rightItems.count &#125; &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) if tableView == leftTableView &#123; cell.textLabel?.text = leftItems[indexPath.row] &#125; else &#123; cell.textLabel?.text = rightItems[indexPath.row] &#125; return cell &#125;&#125; 好：下面就是 新 的内容了。如果你现在运行 app 你就会看到两个并列并且填满数据的 tableView 。我们现在想要做的就是让用户可以从一个 table 上选择一行并且复制到另一个 table 里，或者反方向操作。 第一步就是就是设置两个 tableView 的拖和放操作的代理为当前 view controller ，再把它们设置为可拖放。 最后把下面的代码加入到 viewDidLoad() 方法里： 1234567leftTableView.dragDelegate = selfleftTableView.dropDelegate = selfrightTableView.dragDelegate = selfrightTableView.dropDelegate = selfleftTableView.dragInteractionEnabled = truerightTableView.dragInteractionEnabled = true 当你做完这些后，Xcode 会抛出几个警告，因为我们当前的控制器类没有遵从 UITableViewDragDelegate 和 UITableViewDropDelegate 协议。通过给我们的类添加这两个协议很容易就修复这些警告了 —— 滚动到文件的最顶端并且改变类的定义： 1class ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate, UITableViewDragDelegate, UITableViewDropDelegate &#123; 但是这样又会产生新的问题：我说过我们应该遵从这两个新协议，但是我们没有实现协议必须实现的方法，在过去修复这个常常是很麻烦的，但是 Xcode 9 可以自动完成这几个协议必须实现的方法 —— 点击报红色高亮代码行上的数字 2，这时你将会看到出现了更多的详细解释。点击 “fix” 来让 Xcode 9 为我们插入两个缺少的方法 —— 你将会看到你的类里边出现了下面的代码： 1234567func tableView(_ tableView: UITableView, itemsForBeginning session: UIDragSession, at indexPath: IndexPath) -&gt; [UIDragItem] &#123; code&#125;func tableView(_ tableView: UITableView, performDropWith coordinator: UITableViewDropCoordinator) &#123; code&#125; Xcode 总是把新的方法插在你的类最上面，至少在这次初始的 beta 版本里是。如果你和我一样看这不顺眼 —— 在继续之前可以把它们移到更明智地方！ itemsForBeginning 方法是最简单的，让我们先从它开始。这个方法是在当用户的手指在 tableView 某行 cell 上按下执行拖的操作的时候调用。如果你返回一个空数组，你实际上就是拒绝了拖放操作。 我们打算为这个方法添加四行代码： 指出哪一个字符串被拷贝，我们可以使用一个简单的三元操作符来实现：如果当前的 tableView 是在左边就从 leftItems 中读取，否则就从 rightItems 中读取。 试着将这个字符串转换成一个 Data 对象， 以便可以通过拖放进行传递。 将这个 data 放进一个 NSItemProvider 中，并且标记为存储了一个纯文本字符串从而其他 app 可以知道如何去处理它。 最后， 把这个 NSItemProvider 放进一个 UIDragItem内，从而它可以用于 UIKit 的拖放。 为了把 data 元素标记为纯文本字符串 我们需要引入 MobileCoreServices 框架，所以请把下面的代码加入到 ViewController.swift 文件最上面： 1import MobileCoreServices 现在用下面的代码替换你的 itemsForBeginning 方法： 1234567func tableView(_ tableView: UITableView, itemsForBeginning session: UIDragSession, at indexPath: IndexPath) -&gt; [UIDragItem] &#123; let string = tableView == leftTableView ? leftItems[indexPath.row] : rightItems[indexPath.row] guard let data = string.data(using: .utf8) else &#123; return [] &#125; let itemProvider = NSItemProvider(item: data as NSData, typeIdentifier: kUTTypePlainText as String) return [UIDragItem(itemProvider: itemProvider)]&#125; 接下来我们只需要实现 performDropWith 方法。我说 “只需要”，但是剩下的两个潜在的复杂问题还是很棘手的。首先，如果有人拖放了很多东西我们就会同时获得很多字符串，我们需要把它们都正确插入。其次，我们可能被告知用户想要插入到哪几行，也可能不被告知 —— 用户可能只是把字符串拖放到 tableView 的空白处，这时需要我们决定该怎么处理。 要解决这两个问题需要写比你期望中的更多的代码，但我会带你一步一步编写代码，让它更容易些。 首先，是最简单的部分：找出行被拖放到哪里。 performDropWith 返回一个 UITableViewDropCoordinator 类对象，该对象有一个 destinationIndexPath 属性 可以告诉我们用户想把数据拖放到哪里。然而 这个方法是 可选 实现：如果用户把他们的数据拖放到我们 tableView 的空单元格上，方法返回的将会是 nil 。如果这真的发生了我们会认为用户是想把数据拖放到 table 的最尾部。 所以，把下面的代码添加到 performDropWith 方法内继续吧： 123456789let destinationIndexPath: IndexPathif let indexPath = coordinator.destinationIndexPath &#123; destinationIndexPath = indexPath&#125; else &#123; let section = tableView.numberOfSections - 1 let row = tableView.numberOfRows(inSection: section) destinationIndexPath = IndexPath(row: row, section: section)&#125; 正如你所看到的那样，如果 coordinator 的 destinationIndexPath 存在就直接用，如果不存在则创建一个最后一组最后一行的 destinationIndexPath 。 下一步就是让拖放的 coordinator 来加载拖动的所有特定类对象。在我们的例子里这个特定类是 NSString 。（然而，通常用 String 不起作用。）当所有拷贝的内容都就绪时我们需要发送一个闭包来运行，这也是最复杂的地方：我们需要把内容一个接一个地在目标行下面插入，修改 leftItems 或 rightItems 数组，最后调用我们 tableView 的 insertRows() 方法来展示拷贝后的结果。 那么，接下来：我们刚刚写了一些代码来指出拖放操作最终的目标行。但如果我们得到了 多个 拷贝对象，那么我们所有的都是初始的 destination index path —— 第一个拷贝对象的目标行就是它，第二个拷贝对象的目标行比它低一行，第三个拷贝对象的目标行比它低两行，等等。当我们移动每个拷贝对象时，我们会创建一个新的 index path 并且把它暂存到一个 indexPaths 数组中，这样我们就可以让 tableView 只调用一次 insertRows() 方法就完成了全部插入操作 。 把代码添加到你的 performDropWith 方法中，放在我们刚才写的代码下面： 123456789101112131415161718192021222324252627// attempt to load strings from the drop coordinatorcoordinator.session.loadObjects(ofClass: NSString.self) &#123; items in // convert the item provider array to a string array or bail out guard let strings = items as? [String] else &#123; return &#125; // create an empty array to track rows we&apos;ve copied var indexPaths = [IndexPath]() // loop over all the strings we received for (index, string) in strings.enumerated() &#123; // create an index path for this new row, moving it down depending on how many we&apos;ve already inserted let indexPath = IndexPath(row: destinationIndexPath.row + index, section: destinationIndexPath.section) // insert the copy into the correct array if tableView == self.leftTableView &#123; self.leftItems.insert(string, at: indexPath.row) &#125; else &#123; self.rightItems.insert(string, at: indexPath.row) &#125; // keep track of this new row indexPaths.append(indexPath) &#125; // insert them all into the table view at once tableView.insertRows(at: indexPaths, with: .automatic)&#125; 这就是完成的所有代码了 —— 你现在能够运行这个 app 并且在两个 tableView 之间拖动行内容来完成拷贝。完成这个花费了这么多的工作量，但令人感到惊喜的是：你所做的这些工作你能够支持整个系统的拖放：譬如如果你试着用 iPad 模拟器的话，你就会发现你可以把这些文本拖放到 Apple News 内的任何一个列表上，或者把 tableView 上的文本拖放到 Safari 的搜索条上。非常酷！ 在你试着去完成拖放操作之前，我想再展示一件事：如何实现为其他 View 添加拖放支持。其实比在 tableView 上实现要容易，那就让我们快速做一遍吧。 在开始之前，我们需要一个简单的控件来让我们有可以添加拖放的东西。这次我们打算创建一个 UIImageView 并且渲染一个简单的红色圆圈作为图片。你可以保留已存在的单视图 APP 模板 并把 ViewController.swift 的内容用新代码替换： 1234567891011121314151617181920212223import UIKitclass ViewController: UIViewController &#123; // create a property for our image view and define its size var imageView: UIImageView! let size = 512 override func viewDidLoad() &#123; super.viewDidLoad() // create and add the image view imageView = UIImageView(frame: CGRect(x: 50, y: 50, width: size, height: size)) view.addSubview(imageView) // render a red circle at the same size, and use it in the image view let renderer = UIGraphicsImageRenderer(size: CGSize(width: size, height: size)) imageView.image = renderer.image &#123; ctx in let rectangle = CGRect(x: 0, y: 0, width: size, height: size) ctx.cgContext.setFillColor(UIColor.red.cgColor) ctx.cgContext.fillEllipse(in: rectangle) &#125; &#125;&#125; 像之前一样，这都是些 iOS 的老代码所以我不打算给你详细解释它。如果你试着在 iPad 模拟器上运行，你就会在控制器里看到一个大的红色圆圈 —— 这对供我们测试来说足够了。 自定义视图的拖放是通过一个新的叫作 UIDragInteraction 类来实现的。 你告诉它在哪里发送信息（在我们这个例子里，我们用的是当前的控制器），然后将它和用来交互的 View 绑定。 重要提示： 千万不要忘了打开相关视图的交互，否则当拖放最后不起作用时，你会感到非常困惑。 首先， 在 viewDidLoad() 的最末尾添加这三行代码，就在之前的代码后面。你就会看到 Xcode 提示我们的 View Controller 没有遵循UIDragInteractionDelegate 协议，所以把类的定义改成下面这样： 1class ViewController: UIViewController, UIDragInteractionDelegate &#123; Xcode 将会继续提示我们没有实现 UIDragInteractionDelegate 协议的一个必要方法，所以重复之前我们所做的 —— 在出错行上单击错误提示，然后选择 “Fix” 来插入下面的代码： 123func dragInteraction(_ interaction: UIDragInteraction, itemsForBeginning session: UIDragSession) -&gt; [UIDragItem] &#123; code&#125; 这就像我们之前为我们的 tableView 实现的 itemsForBeginning 方法一样：当用户开始拖动我们的 imageView 的时候，我们需要返回我们想要分享的图像。 这些代码是非常好并且简单的：我们会使用 guard 来防止我们在 imageView 上拉取图片时出现问题，先用一个 NSItemProvider 包装 image，然后返回数据的时候再使用 UIDragItem 包装下。 将 itemsForBeginning 方法用下面的代码替换： 123456func dragInteraction(_ interaction: UIDragInteraction, itemsForBeginning session: UIDragSession) -&gt; [UIDragItem] &#123; guard let image = imageView.image else &#123; return [] &#125; let provider = NSItemProvider(object: image) let item = UIDragItem(itemProvider: provider) return [item]&#125; 这就完成了！ 尝试使用 ipad 多任务处理功能来将图库放在屏幕的右端 —— 你能够通过拖放图片来将图片从你的 APP 拷贝到图库里。 增强现实增强现实 (AR) 已经出现有一段时间了，但是苹果在 iOS 11 上做了一些可圈可点的事情：他们创造了一个卓越的实现就是让 AR 开发可以和现有的游戏开发技术无缝集成。这就意味着你不需要做太多的工作就能把你 SpriteKit 或 SceneKit 技能和 AR 集成起来，这是个非常诱人的前景。 Xcode 自带了一个非常棒可以立即使用的 ARKit 模板，因此我鼓励你去尝试一下 —— 你会惊奇地发现实现它是多么的容易！ 我想快速地演示下模板的使用，这样你就可以了解到这一切是如何融合在一起的。首先，使用虚拟现实模板创建一个新的 Xcode 工程，然后选择 SpriteKit 作为内容技术。是的，SpriteKit 是一个 2D 框架，但它仍能够在 ARKit 中用得很好，因为它可以像 3D 一样通过扭曲或旋转来展示你的精灵。 如果你打开了 Main.storyboard ，你会发现这个 ARKit 模板与普通的 SpriteKit 模板有所不同：它使用了一个新的 ARSKView 界面对象，将 ARKit 和 SpriteKit 两个世界融合在一起。这个对象通过一个 outlet 和 ViewController.swift 连接在一起，在这个控制器中的 viewWillAppear() 方法中构建 AR 追踪，并在 viewWillDisappear() 方法中暂停追踪。 但是，真正起作用的是在两个地方：Scene.swift 文件的 touchesBegan() 方法内，和 ViewController.swift 文件的 nodeFor 方法。 在通常的 SpriteKit 中你创建节点并把节点直接添加到你的场景中，但是使用 ARKit 后创建的是 锚点 —— 包含场景位置和标识符的占位，但它没有实际的内容。根据需要的时候使用 nodeFor 方法转换为 SpriteKit 节点。如果你曾使用过 MKMapView ，会发现这和 MKMapView 添加大头针和标注的方式是类似的 —— 标注是你的模型数据，大头针是 view。 在 Scene.swift 类的 touchesBegan() 方法你会看到从 ARKit 拉出当前帧的代码，先计算放入一个新敌人的位置。这是通过矩阵乘法实现：如果你创建一个单位矩阵（表示位置 X:0, Y:0, Z:0 的东西），再将它的 Z 坐标移回 0.2（相当于 0.2 米），你可以乘以当前场景相机位置来实现向用户指向的方向移动。 所以，当用户指向前方锚点就会被放在前方，如果他们指向上方，锚点就会放在上方。一旦锚点被放在那，它就会呆在那：ARKit 将会自动移动，旋转或扭曲来确保当用户的设备移动时与锚点始终正确对齐。 所有的操作可以用三行代码来实现： 123var translation = matrix_identity_float4x4translation.columns.3.z = -0.2let transform = simd_mul(currentFrame.camera.transform, translation) 一旦计算出来转换，位移就会包装成一个锚点并添加到回话中，就像这样： 12let anchor = ARAnchor(transform: transform)sceneView.session.add(anchor: anchor) 最后会调用 ViewController.swift 类的 nodeFor 方法。之所以会调用是因为当前 ViewController 被设置成了 ARSKView 的代理，当前 ViewController 就会在需要的时候负责把锚点转换成节点。你 不需要 担心定位这些节点：记住，锚点已经放置到真实世界的具体坐标上了，ARKit 负责映射锚点的位置并转换成 SpriteKit 节点。 总之，nodeFor 方法很简单： 1234567func view(_ view: ARSKView, nodeFor anchor: ARAnchor) -&gt; SKNode? &#123; // Create and configure a node for the anchor added to the view&apos;s session. let labelNode = SKLabelNode(text: &quot;Enemy&quot;) labelNode.horizontalAlignmentMode = .center labelNode.verticalAlignmentMode = .center return labelNode;&#125; 如果你想知道，ARKit 锚点有一个 identifier 属性可以让你知道创建了什么样的节点。在 Xcode 模板中所有的节点都是未知的。但是在你自己的工程中你几乎肯定会想把事物唯一标识出来。 就是这些！这么少的代码带来的结果是非常有效的 —— ARKit 注定是一个大的飞跃。 插播广告如果你喜欢这篇文章，你可能对我新写的 iOS 11 实践教程新书感兴趣。你将会实际开发基于 Core ML , PDFView , ARKit , 拖拽等更多新技术的工程。 —— 这是学习 iOS 11 最快的方式！ Buy Practical iOS 11 for $30 PDF 渲染自从 OS X 10.4 开始受益于几乎不需要提供任何代码就可以提供 PDF 渲染，操作，标注甚至更多的 PDFKit 框架后，macOS 就始终对 PDF 渲染有着一流的支持。 至于，到了 iOS 11 也可以在系统中使用 PDF 框架的全部功能了：你可以使用 PDFView 类来显示 PDF，让用户浏览文档，选择并且分享内容，放大缩小等等操作。或者，你可以使用独立的类比如： PDFDocument , PDFPage 和 PDFAnnotation 来创建你自己自定义的 PDF 阅读器。 和拖放一样，我们可以创建一个简单的 app 来演示 PDFKIT 是多么的简单。如果你愿意的话，你可以继续使用你刚才创建的单视图 app 工程，但你需要向工程中导入一个 PDF 文件来供 PDFKit 去读取。 你需要学习两个新的比较小的类来编写代码，第一个是 PDFView ，它负责所有的负责工作，包括 PDF 渲染，滚动和缩放手势响应，选择文本等。它也是 iOS 系统中常见的 UIView 子类，所以你可以不使用任何参数地创建 PDFView 实例对象，然后使用自动布局来约束它的位置来满足你的需求。第二个是新的类是 PDFDocument ，它可以通过一个 URL 来加载一个在其他地方可以被渲染或者操作 PDF 文档。 把 ViewController.swift 类的全部代码用这个代替： 1234567891011121314151617181920212223242526import PDFKitimport UIKitclass ViewController: UIViewController &#123; // store our PDFView in a property so we can manipulate it later var pdfView: PDFView! override func viewDidLoad() &#123; super.viewDidLoad() // create and add the PDF view pdfView = PDFView() pdfView.translatesAutoresizingMaskIntoConstraints = false view.addSubview(pdfView) // make it take up the full screen pdfView.leadingAnchor.constraint(equalTo: view.leadingAnchor).isActive = true pdfView.trailingAnchor.constraint(equalTo: view.trailingAnchor).isActive = true pdfView.topAnchor.constraint(equalTo: view.topAnchor).isActive = true pdfView.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive = true // load our example PDF and make it display immediately let url = Bundle.main.url(forResource: &quot;your-pdf-name-here&quot;, withExtension: &quot;pdf&quot;)! pdfView.document = PDFDocument(url: url) &#125;&#125; 如果运行 app 你应该可以看到你可以使用连续的滚动机制垂直滚动页面。如果你在真机上测试，你也可以通过捏合操作进行缩放 —— 这时你就会发现 PDF 以更高的分辨率重新渲染。如果你想要更改 PDF 的布局样式，你可以试着去设置 displayMode, displayDirection, 和 displaysAsBook 属性。 例如，你可以将页面以双页的模式展现，而封面默认就是这样的： 12pdfView.displayMode = .twoUpContinuouspdfView.displaysAsBook = true PDFView 提供了一系列有用的方法来让用户浏览和操作 PDF。为了试验，我们会在我们的控制器上添加一些导航栏按钮，因为这是添加交互最简单的方式。 总共三步，我们先添加一个 navigation controller， 这样我们就有了一个现成的导航栏来使用。所以，打开你的 Main.storyboard ，在大纲视图里选中 View Controller Scene 。再进入编辑菜单选择 Embed In &gt; Navigation Controller 。 接下来，在 ViewController.swift 中的 viewDidLoad() 方法中添加以下代码： 12345let printSelectionBtn = UIBarButtonItem(title: &quot;Selection&quot;, style: .plain, target: self, action: #selector(printSelection))let firstPageBtn = UIBarButtonItem(title: &quot;First&quot;, style: .plain, target: self, action: #selector(firstPage))let lastPageBtn = UIBarButtonItem(title: &quot;Last&quot;, style: .plain, target: self, action: #selector(lastPage))navigationItem.rightBarButtonItems = [printSelectionBtn, firstPageBtn, lastPageBtn] 这些代码添加了三个按钮来实现一些基本的功能。最后，我们只需要写这三个按钮的响应方法就好了，那么把下面这些方法添加到 ViewController 类中： 1234567891011func printSelection() &#123; print(pdfView.currentSelection ?? &quot;No selection&quot;)&#125;func firstPage() &#123; pdfView.goToFirstPage(nil)&#125;func lastPage() &#123; pdfView.goToLastPage(nil)&#125; 现在，如果是在 Swift 3 下，我们可以这么做。但是到了 Swift 4 你将会看到报 “Argument of ‘#selector’ refers to instance method ‘firstPage()’ that is not exposed to Objective-C” 错误。换句话说就是 Swift 的方法对 Objective-C 不可见的，而 UIBarButtonItem 是 Objective-C 代码实现。 当然在每个方法之前加上 @objc 是个有效的办法，我猜大部分人可能就耸耸肩（我有什么办法，我也很绝望啊），然后在类之前加上一个 @objcMembers 的定义 —— 这会像之前 Swift 3 那样自动将类的所有东西都暴露给 Objective-C 。所以，把类的定义修改成这样： 12@objcMembersclass ViewController: UIViewController &#123; 现在这就正确地编译了，现在你将会看到跳转到首页和末页的功能可以直接使用了。至于选择按钮，你只需要在点击按钮之前在 PDF 之前选择一些文本 —— 就像在 iBooks 进行文本选择操作那样。 开始支持 NFC 读取iPhone 7 引入了针对 NFC 的硬件支持，至于 iOS 11，NFC 开始支持让我们在自己的 APP 内使用：你现在可以编写代码来检测附近的 NFC NDEF 标签，而且出乎意料地简单 —— 至少在 代码层面 。然而在我们看代码之前，你需要绕过一些坑，所有的我都希望在正式版消失。 Step 1: 在 Xcode 里创建一个新的 单视图 APP 模板。 Step 2: 去 iTunes 配置网站 https://developer.apple.com/account 为你的 APP 创建一个 包含 NFC 标签读取的 APP ID。 Step 3: 为这个 APP ID 创建一个描述文件，并将其安装到 Xcode 中。取消 “Automatically manage signing” 选项卡，并且选择你刚才安装的描述文件。你可以点击描述文件旁边的小 “i” 按钮来在权限列表里查看 “com.apple.developer.nfc.readersession.formats”。 Step 4: 使用 快捷键 Cmd+N 为工程添加一个新的文件，先选择属性列表。把它命名为 “Entitlements.entitlements” ，并且确保 “Group” 旁边有一个蓝色的图标。 Step 5: 打开 Entitlements.entitlements 进行编辑，右击空白处选择 “Add Row”。键值为 “com.apple.developer.nfc.readersession.formats” 并把它的类型改为数组。点击 “com.apple.developer.nfc.readersession.formats” 左侧的指示箭头，再点击右边的 + 标记。这时应该会插入一个带有空值的 “Item 0” 键 —— 把它的值改为 “NDEF”。 Step 6: 定位到你的 target 的 build settings 找到 Code Signing Entitlements 。在文本框里填入 “Entitlements.entitlements” 。 Step 7: 打开你的 Info.plist 文件，再右击空白处选择 “Add Row” 。添加键为 “Privacy - NFC Scan Usage Description” ，值为 “SwiftyNFC” 。 是的，就是一团糟。我不知道为什么——能够扫描 NFC 几乎没有比访问某人的健康记录更私密，而且更容易做到。在你思考恶意应用会不会暗地里扫描 NFC 之前，还是省省吧：就像刚才看到的那样，这是根本不可能做到的。 在混乱的设置之后，很高兴地告诉你使 NFC 工作的代码几乎是微不足道的：创建一个属性来存储一个代表当前 NFC 扫描会话的 NFCNDEFReaderSession 对象，再创建这个对象并要求它开始扫描。 当你创建读取会话时，你需要给它提供三条数据：它能够发送信息的代理，它应该用于发送这些消息的队列和当它扫描到一个 NFC 标签的时候是否结束扫描。我们会用 self 作为代理，DispatchQueue.main 作为队列，将值设置为 false 当扫描到一个标签后不停止扫描，所以它会继续扫描直到60秒结束。 打开 ViewController.swift，导入 CoreNFC，再把这个属性添加到 ViewController 类： 1var session: NFCNDEFReaderSession! 接下来,在 viewDidLoad() 方法中添加这两行代码： 12session = NFCNDEFReaderSession(delegate: self, queue: DispatchQueue.main, invalidateAfterFirstRead: false)session.begin() ViewController 现在还没有正确地遵循 NFCNDEFReaderSessionDelegate 协议，你需要修改你的类定义来包含它： 1class ViewController: UIViewController, NFCNDEFReaderSessionDelegate &#123; 按照惯例，Xcode 将会报你缺失一些必要方法的错，所以使用它建议的修复来插入下面这两个方法： 1234567func readerSession(_ session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage]) &#123; code&#125;func readerSession(_ session: NFCNDEFReaderSession, didInvalidateWithError error: Error) &#123; code&#125; 两个方法都是特别简单的，但是错误的处理也非常简单——我们只是把错误打印到 Xcode 的控制台。在 didInvalidateWithError 方法内像这样添加内容： 123func readerSession(_ session: NFCNDEFReaderSession, didInvalidateWithError error: Error) &#123; print(error.localizedDescription)&#125; 现在对于 didDetectNDEFs 方法。当它被调用的时候你会得到一个检测到的消息的数组，数组每一个元素都可以包含描述单个数据的一个或更多记录。例如，你可能会看到 NFC 被用作启动 Google Cardboard app: Cardboard 设备有一个简单的包含绝对 URL “cardboard://V1.0.0” 的 NFC 标签，当设备检测到标签后会唤起 APP 显示。 用 NFC 数据的处理就是你需要做的事了，我们只是把他打印出来了，把你的 didDetectNDEFs 修改成这样： 123456789func readerSession(_ session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage]) &#123; for message in messages &#123; for record in message.records &#123; if let string = String(data: record.payload, encoding: .ascii) &#123; print(string) &#125; &#125; &#125;&#125; 所有的代码就完成了，那么继续开始运行这个 app 吧！如果所有的部分都起作用了，你将立即看到系统用户界面出现提示用户将其设备靠近要扫描的位置。这就是为什么恶意应用程序滥用 NFC 扫描是不可能的 - 不仅我们无法控制用户界面，而且 60 秒后扫描也会因为超时结束以避免浪费电量。 机器学习和视觉识别机器学习是现在最时髦的流行语，就是让计算机根据过去接触到的处理规则来适应新的数据。比如，如果你只有一张吉他画和一个空的 Swift 类，那么”这幅画中有吉他吗？“是个非常难回答的问题，但是如果你使用大量包含吉他的图片样本来构建一个训练模型，这时你就可以有效地训练计算机识别出包含吉他的新图像。 听上去很无聊，但实际上是 iOS 11 上大量的先进技术的基础：Siri，照相机，Quick Type 都使用了机器学习来帮助它们更好的理解我们所在的世界。iOS 11 还引入了一个新的 Vision 框架，这是一个从 Core Image ，机器学习功能和所有新技术组成的一个有点模糊的组合。 在 iOS 11 里所有的这些都是由一个叫做 Core ML 的机器学习框架提供，该框架旨在支持各种各样的模型，而不仅仅是识别图像。信不信由你，编写 Core ML 的代码是很少的，然而这只是事情的一面。 你清楚的，Core ML 需要训练模型才能工作，而模型是用算法在大量数据训练得出的。这些模型可以从几千字节到数百兆字节甚至更多，而且明显需要一定的专业知识才能训练，特别是当你处理图像识别的时候。令人欣喜的是，苹果提供了一些可以用来快速上手和运行的模型，所以如果你只是想要尝试下使用 Core ML ，实际上是非常简单的。 难过的是，还有事情还有另外一面：第三方框架总是非常恶心的，你明白的，Core ML 模型为我们自动生成接收一些输入数据并返回一些输出数据的代码 - 这部分是非常友好的。但悲伤的是，处理图像时所需的输入数据不是 “UIImage”，也不是 “CGImage”，更不是 “CIImage” 。 相反，苹果选择让我们使用 “CVPixelBuffer” 输入。CVPixelBuffer 放进我的代码中就像血友病聚会上来了头豪猪一样不受欢迎。没有把 UIImage 转换为 CVPixelBuffer 的完美有效的方法，我是很有资格说的，因为我浪费了几个小时来寻求解决方案。幸运的是 Chris Cieslak 非常慷慨把他的代码分享给我，在他的 WTFPL 下转换是非常有效的，所以你也可以使用它进行转换。 现在让我们尝试下 Core ML 吧。先创建一个新的单视图 APP 工程（或者继续使用你现有的工程），再在工程里添加一张图片 —— 我添加的是维基百科里的 华盛顿杜勒斯国际机场 。把这张图片重命名为 “test.jpg” 以避免拼写错误。 现在我们有一些输入测试，我们需要添加一个训练好的模型。它可能没有看到过我们确切的照片，但它需要接触些类似的图片以便识别出这个机场。苹果在 https://developer.apple.com/machine-learning 上提供了一些预配置的模型 —— 现在进入网站，并下载 “Places205-GoogLeNet” 模型。 模型只有 25MB，所以它不会占用你用户设备上太多空间。 当你下载好模型后，先把它拖到你的 Xcode 工程中，再选择它，这时你就可以看到 Core ML 的模型查看器。你会看到它是由 MIT 制作的神经网络分类器，还有可以根据知识共享许可证使用。在这个下面，你将看到它有 “sceneImage” 作为输入，还有 “sceneLabelProbs ” 和 “sceneLabel” 作为输出 —— 输入一张图片，输出一些计算机识别这张图片的文本描述。 你还将看到 “Model class” 和 “Swift generated source” —— Xcode为我们生成了一个类，只包含几行代码，这一点非常显著，你将很快看到。 现在，我们有一个可以识别的图像和一个可以检查它的训练好的模型。 我们现在需要做的是将两者放在一起：加载图片，为模型准备图片，最后询问模型的预测。 为了使这个代码更容易理解，我把它分成了一些块。 首先，打开 ViewController.swift 并将其修改为： 12345678910111213import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let image = UIImage(named: &quot;test.jpg&quot;)! // 1 // 2 // 3 &#125;&#125; 这只是加载我们准备被处理的测试图片。 接下来的步骤是从 “// 1” 开始逐个填写这三个注释。 基于图像的 Core ML 模型要求以精确的尺寸接收图片，这是他们接受过训练的尺寸。 对于 GoogLeNetPlaces 模型尺寸应该是 224 x 224 而其他模型有它们各自的尺寸，而 Core ML 会告诉你是否以错误的尺寸输入了东西。 所以，我们需要的第一件事是缩小我们的图像，让图片恰好是 224 x 224 ，而不管我们是使用视网膜屏设备还是其他的设备。 这可以使用 “UIGraphicsBeginImageContextWithOptions（）” 方法来强制 1.0 的比例。 用下面的代码替换这个 // 1 注释： 12345let modelSize = 224UIGraphicsBeginImageContextWithOptions(CGSize(width: modelSize, height: modelSize), true, 1.0)image.draw(in: CGRect(x: 0, y: 0, width: modelSize, height: modelSize))let newImage = UIGraphicsGetImageFromCurrentImageContext()!UIGraphicsEndImageContext() 这给了我们一个新的叫做 “newImage” 常量，它是一个符合模型中正确尺寸的 “UIImage”。 现在第二部分要做的是从 “UIImage” 到 “CVPixelBuffer” 之间恶心的转换。 因为这是毫无意义的复杂操作，所以我不打算试图解释所有的各个步骤。除了拷贝下面的代码，我不建议你做任何事情。 用下面的代码替换这个 // 2 注释： 123456789101112131415161718let attrs = [kCVPixelBufferCGImageCompatibilityKey: kCFBooleanTrue, kCVPixelBufferCGBitmapContextCompatibilityKey: kCFBooleanTrue] as CFDictionaryvar pixelBuffer : CVPixelBuffer?let status = CVPixelBufferCreate(kCFAllocatorDefault, Int(newImage.size.width), Int(newImage.size.height), kCVPixelFormatType_32ARGB, attrs, &amp;pixelBuffer)guard (status == kCVReturnSuccess) else &#123; return &#125;CVPixelBufferLockBaseAddress(pixelBuffer!, CVPixelBufferLockFlags(rawValue: 0))let pixelData = CVPixelBufferGetBaseAddress(pixelBuffer!)let rgbColorSpace = CGColorSpaceCreateDeviceRGB()let context = CGContext(data: pixelData, width: Int(newImage.size.width), height: Int(newImage.size.height), bitsPerComponent: 8, bytesPerRow: CVPixelBufferGetBytesPerRow(pixelBuffer!), space: rgbColorSpace, bitmapInfo: CGImageAlphaInfo.noneSkipFirst.rawValue)context?.translateBy(x: 0, y: newImage.size.height)context?.scaleBy(x: 1.0, y: -1.0)UIGraphicsPushContext(context!)newImage.draw(in: CGRect(x: 0, y: 0, width: newImage.size.width, height: newImage.size.height))UIGraphicsPopContext()CVPixelBufferUnlockBaseAddress(pixelBuffer!, CVPixelBufferLockFlags(rawValue: 0)) 如果可能使用很多次上面的代码，你可能想要把这些复杂代码封装到一个函数里边。但无论你如何操作，请不要试图去记住它。 现在开始重要的，有趣的和微不足道的部分：实际使用 Core ML 框架，这只有三行代码，相当坦率地说，非常简单。 就像我所说的，Xcode 自动根据 Core ML 模型生成一个 Swift 类，所以我们可以立即实例化一个 “GoogLeNetPlaces” 对象。 最后我们可以将我们的图片缓存传递给它的 “prediction()” 方法，这个方法将返回预测结果或抛出一个错误。 在实践中，你可能会发现使用 `try？’ 更容易获得一个值或是 nil 。 最后，我们将打印出预测结果，以便你了解到 Core ML 的表现。 用下面代码替换替换这个 // 3 注释： 123let model = GoogLeNetPlaces()guard let prediction = try? model.prediction(sceneImage: pixelBuffer!) else &#123; return &#125;print(prediction.sceneLabel) 不管你相不相信，这就是使用 Core ML 的所有代码； 这简单的三行代码做完了所有的工作。 你打印出来的结果取决于你的输入内容和你的训练模型，但 GoogLeNetPlaces 正确地将我的图片识别为机场航站楼，这一切完全在设备上完成 —— 无需将图片发送到远程服务器处理，因此在这个黑盒子里你得到了极好的隐私保护。 更多其他的更新。。。iOS 11 还有大量的其他更新 —— 这些是我最喜欢的： Metal 2 被设置成提高整个系统的图形性能。我没在这提供代码示例是因为这实在是一个高深的话题 —— 大多数人只会很高兴看到他们的 SpriteKit ，SceneKit 和 Unity 应用程序无需额外的工作就可以获得更快的速度。 TableView Cell 现在自动支持自适应。以前都是设置 UITableViewAutomaticDimension 作为行高来触发自适应行为。但现在再也不需要设置了。 TableView 增加了一个 新的基于闭包的 performBatchUpdates() 方法，它可以让你一次性对多行的插入、删除、移动操作进行动画处理，甚至可以在动画完成之后立即执行结束闭包。 在 Apple Music 第一次出现的新的加粗黑标题现在可以再整个系统使用了，同时支持通过一个细小的改动在我们自己的 APP 使用：在 IB 内为我们的导航条选择 “Prefers Large Titles” ，或者如果你更喜欢使用代码的话使用 navigationController?.navigationBar.prefersLargeTitles = true 来设置。 为了支持 safeAreaLayoutGuide topLayoutGuide属性被弃用了。它提供了所有边的边缘而不仅仅是顶部和底部，这可能预示未来的 iPhone 为非矩形布局 —— 带有沉浸式相机的全屏幕 iPhone 8，有人有异议吗？ Stack views 增加了一个 setCustomSpacing(_:after:) 方法，这可以让你在 stack view 添加你想要的而不是统一大小的空白。 接下来就是 XcodeXcode 9 是我见过的最令人兴奋的 Xcode 版本 —— 它充满了令人难以置信的新功能，甚至可以使最坚定的 Xcode 抱怨者重新考虑。 这些是最吸引我的功能更新： 可以在编辑器内进行 Swift 和 Objective-C 的重构，这意味着你只需点击几下鼠标就可以对你的代码进行彻底的更改（例如对方法重命名）。 iOS 和 tvOS 支持无线调试了。为了使用这个功能，先使用 USB 连接你的设备，再在 Window 菜单里选择 Devices and Simulators 。选择你的设备，最后选择 “Connect via network” 。如果第一次不能成功 不必感到惊奇 —— 这还是 beta 1 版本！ 源代码编辑器使用 Swift 进行了重写，带来了滚动和搜索的速度极大的提升。以及一些其他有用的功能，比如按住 Ctrl 键时的范围高亮显示。 你现在可以将命名颜色添加到 asset catalogs，这样你可以定义一次颜色， 在任何地方使用 UIColor(named:) 方法初始化。 默认情况下启用了一个新的主线程检查器，当检测到任何不在主线程上执行的 UIKit 方法调用时，它将自动发出警告 - 这是常见的错误源头。 你现在可以同时运行多个模拟器，甚至可以自由调整它们的大小。 苹果在模拟器周围添加了额外的用户界面，以便我们访问硬件控件。 如果您不想立即使用 Swift 4，则会有一个新的 “Swift Language Version” 构建设置，您可以选择 Swift 4.0 或 Swift 3.2。 两者都使用相同的编译器，但在内部启用不同的选项 认真的，我希望我今年在 WWDC 现场，这样我就给 Xcode 工程师一个熊抱 —— 这是一个炙手可热的版本，让 Xcode 在奔向伟大的路上越行越远。 还在等什么？现在你已经了解了 iOS 11 中的新功能，你也应该看一看我的新书：Practical iOS 11。这是一本用实际项目讲解 iOS 11 中所有主要变化的书籍，拥有它你可以尽可能快地熟悉 iOS 11。 Buy Practical iOS 11 for $30 掘金翻译计划 是一个翻译优质互联网技术文章的社区，文章来源为 掘金 上的英文分享文章。内容覆盖 Android、iOS、React、前端、后端、产品、设计 等领域，想要查看更多优质译文请持续关注 掘金翻译计划。]]></content>
      <tags>
        <tag>iOS 11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]避免使用第三方UI库]]></title>
    <url>%2F2017%2F06%2F15%2F%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9UI%E5%BA%93%2F</url>
    <content type="text"><![CDATA[原文地址: http://holko.pl/2017/05/31/avoiding-ui-libraries/翻译: Swants 最近 iOS 社区一些人在讨论关于应该 赞成还是反对使用第三方依赖库 (当然, 大部分人持反对意见). 我看到的许多争论的观点都有失偏颇 -它们把所有的第三方库都归于一类混为一谈. 就像大多数事情一样,整体考虑不是那么简单的的事,所以现在让我们将目光放在一个小的观点上: 我们应该避免使用 第三方UI依赖库吗? 考虑使用第三方库的缘由开发者们考虑使用一个第三方库通常有两个主要原因: 缺乏技能或者知识。 比方说,你正在做一款照片分享功能的 app. 你没有从 推出自己的密码 开始。 缺乏从事某件事的时间或者兴趣。 除非你又无限的时间不需要去分清主次。 大部分的 UI 库(不是所有的!)都趋向于第二个原因.这个事儿不是高深的事,但是把它做好却需要花费时间. 什么应该”外包”那么,我们通常应该怎么决定什么代码应该我们自己写,什么应该交给第三方组件呢? 著名的乔尔建议提供了非常好的依据: 如果是核心商业功能的话 就自己做 不管它是什么。 一个事实(并且比较残酷的)是几乎所有的 iOS app 正在向前端而不是后端发展。,因此我们应该考虑在内部尽可能多地进行 UI 开发 看起来就尤为重要。 有人可能会说这只是个人观点,所以让我们重新思考你是对第三方 UI 库使用的更详细原因。 UI库自身的问题通用 vs 特定有两种类型的控件/视图: 通用 允许你在很多场景 甚至是我们想不到的场景下使用 比如 UIKit 中的 UICollectionView . 特定 专门为一些特定的场景设计 比如 UIPickerView 大部分第三方库倾向于第二个分类.而且它们通常是在一个已存在并且在不断优化的代码库中取出.比如,还记得上个月看到的那个看起来非常酷的下拉刷新库吗?如果不修改控制器交互或下拉偏移量的话,它可能不太适合你 app 的设计或使用场景. 使用继承进行个性化就面向对象而言,由子类化转向组件化是行业趋势.当你选择第三方库的时候请确保没有违背这个趋势.在大多数情况下 你可以选择其他人做的一个组件,你只需要继承或者直接修改代码就好了.(代理模式也是接近组件化的方法之一.) 看起来过于定制化 一个第三方库内可见的 UI 元素越少越好,这听起来可能觉得有悖常理.高度定制化的控件或界面带来的问题就是它不可能满足所有的的需求来迎合所有的使用情景. 如果有大量的自定义 UI ,你可能无法回馈上游,因为你对于外观或感觉的想法可能和库的维护者不一样.这个时候你会自己维护一个库的fork代码.或者在 app 内添加一个丑陋的遮盖 仅仅是为了移除一条阴影.而在另一方面,一些库在UI层进行操作 但是没有或者几乎没有提供任何样式.想一想 SDWebImage 或者我的 SloppySwiper . 它们都可以不需要任何修改直接放进你的工程内. 未知的早期预设很多团队都会对内部代码进行代码审查, 但可能将第三方源代码的质量视为理所当然。花费点时间去浏览第三方库的源代码是值得的.你可能会看到一堆警告 比如在不需要的地方使用方法实现交换. 尝试着去了解下库的结构,你能否根据未来的需求尝试着去调整库,或者当 MVP 的时候后重写库吗? 你也应该考虑下库的维护情况,最近有多少次提交,多少个问题 是否做过任何的单元测试或者 UI测试? 忽略 GitHub 的星数,尽管它有时是很有意义的. 想法 &gt; 代码 ?我喜欢开源因为开源允许我去了解别人是怎么思考的,是怎么设计他们的方案的. 通常学习这个想法比获得这个代码本身更有意义. 如果一个库接触到了 UI 并且很小,通常从代码中获取灵感并且开发一个组件来完美适应你的工程是更明智的做法. 不能忽略它由于 UIKit 的设计方式,你可能几乎不能够忽略掉第三方 UI 库,比如 在一个适配器后面,一个库将会和你的 UI 代码交叉在一起,事实上已经变成了你工程里一等公民. 未来时间花费UIKit 会随着每个 iOS 版本进行变化,这时候就糟了,你的第三方依赖并不会像你想象的那样免于维护. ##结论在编程中经常会出现这种情况,很难提供一般规则,我们必须在代码库添加每一行代码的时候都要考虑一条又一条的规则.根据我的个人经验,使用大多数第三方UI库都是通过牺牲灵活性来节省一些时间. 我们利用现成的代码来更快地实现需求,但是迟早,我们将会被第三方库所限制 并作出艰难的决定:考虑接下来怎么办?]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS APP 崩溃日志分析]]></title>
    <url>%2F2017%2F05%2F11%2FiOS-APP-%E5%B4%A9%E6%BA%83%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在日常开发中,我们难免遇到崩溃.如果是在开发过程中，我们可以直接通过 Xcode 来找到问题所在。如果是在测试的时候崩溃，我们也可以轻易的通过测试机导出 crash 进行问题定位。 可是一旦当产品上线之后，这一切就变得不那么容易了。庆幸的是市场上已经出现了一些比较好的第三方 crash 统计服务比如 bugly。 可以让我轻松了解到crash时的堆栈信息。 但是bugly也有符号化不到位的情况， 比如: 那么在这种情况下我们应该怎么办呢? 崩溃日志符号化使用xcode符号化 条件: (需要崩溃手机) 如果发生崩溃的手机在手边.可以连上电脑 在 Xcode 中的 organizer&gt;device 中直接查看符号化好的日志.优点: 操作简单缺点: 如果崩溃日志较多 还需要崩溃时间才能确定是哪个crash文件. crash不好统计 使用symbolicatecrash符号化条件: crash文件 dsYM 文件 symbolicatecrashsymbolicatecrash 位置 1(/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash) 方法: 将三个文件放在同级下 然后打开终端 进入文件夹目录下 设置环境变量 1export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer 符号化 12 ### symbol.crash 就是最后符号化好的文件 ###../symbolicatecrash ../.crash ../.dsym &gt; ../symbol.crash 优点:操作简单缺点:适合针对单个crash 文件符号化 使用 atos 命令符号化条件: dSYM 和堆栈信息使用 grep 命令 获取该模块的 指令集和加载起始地址 1grep "name armv" ../*.crash 然后用获得的指令集(armv7) 和起始地址(0x4000) 来符号化 12345xcrun atos -o ../.dsYM/../name -l 0x4000(起始地址) -arch -armv7(指令集) //输入目标地址 0x00352aee //得到结果 -[UIScrollView(UITouch) touchesEnded:withEvent:] (in appName) (UIScrollView+UITouch.h:26) 注意 模块只能定位到本模块的位置 不能越层 如:AFN.framework.dSYM 只能定位到AFN内的目标地址位置appName.app.dSYM 只能定位到app内代码的地址位置 优点: 只需要堆栈信息 和符号表就可以. 可以在获取不到Crash文件 但在bugly等第三方统计中获得了堆栈信息的情况下使用.缺点: 一次只能符号化一行,比较繁琐.(可以作为bugly符号化不完全情况下的补充.) 有兴趣的可以实际动手操作下:Xcode 自带 atos 脚本: symbolicatecrash 下载crash 文件 : demoAPP.crash 下载符号表: demoAPP.app.dSYM 下载第三方模块符号表 RBPlayer.framework.dSYM 下载 crash文件组成分析让我们看一下一个实际的 crash 文件组成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126### 1.进程信息 ###Incident Identifier: CDDADF33-6F8A-44B3-90D1-52D9095ADA0CCrashReporter Key: ed6929203307e230288ce2a758bd7099d3a52e15Hardware Model: iPhone5,2Process: demoApp [9806]Path: /private/var/containers/Bundle/Application/0C5CCF0C-6A7F-4864-BD5A-0765725E0CCB/demoApp.app/demoAppIdentifier: com.yimiao100.demoAppVersion: 6 (1.6)Code Type: ARM (Native)Role: ForegroundParent Process: launchd [1]Coalition: com.yimiao100.demoApp [3588]### 2.基本信息 ###Date/Time: 2017-05-10 10:37:51.2003 +0800Launch Time: 2017-05-10 10:36:26.0000 +0800OS Version: iPhone OS 10.3.1 (14E304)Report Version: 104### 3.异常信息 ###Exception Type: EXC_CRASH (SIGABRT)Exception Codes: 0x0000000000000000, 0x0000000000000000Exception Note: EXC_CORPSE_NOTIFYTriggered by Thread: 0Application Specific Information:abort() calledFiltered syslog:None foundLast Exception Backtrace:(0x1ceefb38 0x1c177062 0x1ceefa80 0x1fd6f826 0x1fd6f9de 0x1fd70044 0x148a244 0x14813e4 0x1ce9bdb4 0x1ce9b6f4 0x1ce9b4dc 0x1cef6304 0x1cdff030 0x1d74c0a8 0x1d750b26 0x147f440 0x237bff76 0x237c0622 0x237c1644 0x1c5bd792 0x1c5bd77e 0x1c5c1d00 0x1ceabd64 0x1cea9e14 0x1cdfd0ea 0x1cdfcf0c 0x1e5a7b3c 0x22181e7e 0x10b2a8 0x1c5ea4e6)### 4.线程回溯 ###Thread 0 name: Dispatch queue: com.apple.main-thread### Crash调用堆栈 ###Thread 0 Crashed:0 libsystem_kernel.dylib 0x1c6bdacc 0x1c6a8000 + 887801 libsystem_pthread.dylib 0x1c7760f6 0x1c771000 + 207262 libsystem_c.dylib 0x1c65295a 0x1c608000 + 3054983 libc++abi.dylib 0x1c157708 0x1c156000 + 58964 libc++abi.dylib 0x1c16e552 0x1c156000 + 996665 libobjc.A.dylib 0x1c17731e 0x1c170000 + 294706 demoApp 0x005b6e78 0x44000 + 57135287 libc++abi.dylib 0x1c16b98e 0x1c156000 + 884628 libc++abi.dylib 0x1c16b1a2 0x1c156000 + 864349 libobjc.A.dylib 0x1c177138 0x1c170000 + 2898410 CoreFoundation 0x1ceefa84 0x1cdf5000 + 102669211 QuartzCore 0x1fd6f82a 0x1fc7c000 + 99741812 QuartzCore 0x1fd6f9e2 0x1fc7c000 + 99785813 QuartzCore 0x1fd70048 0x1fc7c000 + 99949614 RBPlayer 0x0148a248 0x1477000 + 7840815 RBPlayer 0x014813e8 0x1477000 + 4196016 CoreFoundation 0x1ce9bdb8 0x1cdf5000 + 68344817 CoreFoundation 0x1ce9b6f8 0x1cdf5000 + 68172018 CoreFoundation 0x1ce9b4e0 0x1cdf5000 + 68118419 CoreFoundation 0x1cef6308 0x1cdf5000 + 105344820 CoreFoundation 0x1cdff034 0x1cdf5000 + 4101221 Foundation 0x1d74c0ac 0x1d746000 + 2474822 Foundation 0x1d750b2a 0x1d746000 + 4381823 RBPlayer 0x0147f444 0x1477000 + 3386024 AVFoundation 0x237bff7a 0x23759000 + 42175425 AVFoundation 0x237c0626 0x23759000 + 42346226 AVFoundation 0x237c1648 0x23759000 + 42759227 libdispatch.dylib 0x1c5bd796 0x1c5bc000 + 603828 libdispatch.dylib 0x1c5bd782 0x1c5bc000 + 601829 libdispatch.dylib 0x1c5c1d04 0x1c5bc000 + 2381230 CoreFoundation 0x1ceabd68 0x1cdf5000 + 74890431 CoreFoundation 0x1cea9e18 0x1cdf5000 + 74088832 CoreFoundation 0x1cdfd0ee 0x1cdf5000 + 3300633 CoreFoundation 0x1cdfcf10 0x1cdf5000 + 3252834 GraphicsServices 0x1e5a7b40 0x1e59e000 + 3974435 UIKit 0x22181e82 0x22110000 + 46656236 demoApp 0x0010b2ac 0x44000 + 81578837 libdyld.dylib 0x1c5ea4ea 0x1c5e7000 + 13546### 其他线程 ###Thread 1 name: Dispatch queue: com.apple.root.default-qosThread 1:0 libsystem_kernel.dylib 0x1c6bde7c 0x1c6a8000 + 897241 libsystem_c.dylib 0x1c6120e8 0x1c608000 + 411922 Foundation 0x1d834c36 0x1d746000 + 9779743 demoApp 0x00228310 0x44000 + 19832484 libdispatch.dylib 0x1c5bd796 0x1c5bc000 + 60385 libdispatch.dylib 0x1c5cab1c 0x1c5bc000 + 601886 libdispatch.dylib 0x1c5cc1b4 0x1c5bc000 + 659727 libdispatch.dylib 0x1c5cc00e 0x1c5bc000 + 655508 libsystem_pthread.dylib 0x1c7728ec 0x1c771000 + 63809 libsystem_pthread.dylib 0x1c7724cc 0x1c771000 + 5324Thread 2 name: com.apple.uikit.eventfetch-threadThread 2:0 libsystem_kernel.dylib 0x1c6a8900 0x1c6a8000 + 23041 libsystem_kernel.dylib 0x1c6a86e0 0x1c6a8000 + 17602 CoreFoundation 0x1ceabbe2 0x1cdf5000 + 7485143 CoreFoundation 0x1ceaa064 0x1cdf5000 + 741476...Thread 3 name: com.apple.NSURLConnectionLoaderThread 3:0 libsystem_kernel.dylib 0x1c6a8900 0x1c6a8000 + 23041 libsystem_kernel.dylib 0x1c6a86e0 0x1c6a8000 + 17602 CoreFoundation 0x1ceabbe2 0x1cdf5000 + 7485143 CoreFoundation 0x1ceaa064 0x1cdf5000 + 7414764 CoreFoundation 0x1cdfd0ee 0x1cdf5000 + 33006...... ...Thread 0 crashed with ARM Thread State (32-bit): r0: 0x00000000 r1: 0x00000000 r2: 0x00000000 r3: 0x0000006e r4: 0x00000006 r5: 0x3a697e40 r6: 0x397d430c r7: 0x00c88044 r8: 0x00000002 r9: 0x00000000 r10: 0x40000000 r11: 0x158ee214 ip: 0x00000148 sp: 0x00c88038 lr: 0x1c7760f7 pc: 0x1c6bdacc cpsr: 0x00000010### 5.动态库信息 ###Binary Images:0x44000 - 0x85ffff demoApp armv7 &lt;4d8140e3978f35d29c938c2659aa766d&gt; /var/containers/Bundle/Application/0C5CCF0C-6A7F-4864-BD5A-0765725E0CCB/demoApp.app/demoApp0xa4d000 - 0xa78fff AFNetworking armv7 &lt;f0d55a034b7f3eb7b90a1214a8639f1a&gt; /var/containers/Bundle/Application/0C5CCF0C-6A7F-4864-BD5A-0765725E0CCB/demoApp.app/Frameworks/AFNetworking.framework/AFNetworking0x1477000 - 0x1496fff RBPlayer armv7 &lt;f03427c9cf4e32ddae455c67d3a157ac&gt; /var/containers/Bundle/Application/0C5CCF0C-6A7F-4864-BD5A-0765725E0CCB/demoApp.app/Frameworks/RBPlayer.framework/RBPlayerEOF 进程信息第一部分是闪退进程的相关信息。 Incident Identifier是崩溃报告的唯一标识符。 CrashReporter Key是与设备标识相对应的唯一键值。虽然它不是真正的设备标识符，但也是一个非常有用的情报:如果你看到 100 个崩溃日志的 CrashReporter Key 值都是相同的，或者只有少数几个不同的 CrashReport 值，说明这不是一个普遍的问题，只发生在一个或少数几个设备上。 Hardware Model 标识设备类型。 如果很多崩溃日志都是来自相同的设备类型，说明应用只在某特定类型的设备上有问题。上面的日志里，崩溃日志产生的设备是 iPhone 5 。 Process 是应用名称。中括号里面的数字是闪退时应用的进程ID。 基本信息 VersionAPP的版本号 OS VersioniOS操作系统版本号 iPhone OS 10.3.1 (14E304)10.3.1：系统版本14E304：build 号这里要所以下 build 号。每个系统版本号有可能会对应多个 build 号。如苹果发布的 10.3.1 会有几个版本，如：电信版本、联通版本等。build 号我们后面对日志符号化的时候会用到。 异常信息在这部分，你可以看到闪退发生时抛出的异常类型。还能看到异常编码和抛出异常的线程。根据崩溃报告类型的不同，在这部分你还能看到一些另外的信息。 Crashed Threadcrash 线程号。可以根据这个编号找到对应的 crash 调用堆栈，当前crash 线程的编号为 0，所以我们可以直接找到 crash 线程的堆栈信息：12345678910111213141516171819202122232425262728293031323334353637383940Thread 0 name: Dispatch queue: com.apple.main-threadThread 0 Crashed:0 libsystem_kernel.dylib 0x1c6bdacc 0x1c6a8000 + 887801 libsystem_pthread.dylib 0x1c7760f6 0x1c771000 + 207262 libsystem_c.dylib 0x1c65295a 0x1c608000 + 3054983 libc++abi.dylib 0x1c157708 0x1c156000 + 58964 libc++abi.dylib 0x1c16e552 0x1c156000 + 996665 libobjc.A.dylib 0x1c17731e 0x1c170000 + 294706 demoApp 0x005b6e78 0x44000 + 57135287 libc++abi.dylib 0x1c16b98e 0x1c156000 + 884628 libc++abi.dylib 0x1c16b1a2 0x1c156000 + 864349 libobjc.A.dylib 0x1c177138 0x1c170000 + 2898410 CoreFoundation 0x1ceefa84 0x1cdf5000 + 102669211 QuartzCore 0x1fd6f82a 0x1fc7c000 + 99741812 QuartzCore 0x1fd6f9e2 0x1fc7c000 + 99785813 QuartzCore 0x1fd70048 0x1fc7c000 + 99949614 RBPlayer 0x0148a248 0x1477000 + 7840815 RBPlayer 0x014813e8 0x1477000 + 4196016 CoreFoundation 0x1ce9bdb8 0x1cdf5000 + 68344817 CoreFoundation 0x1ce9b6f8 0x1cdf5000 + 68172018 CoreFoundation 0x1ce9b4e0 0x1cdf5000 + 68118419 CoreFoundation 0x1cef6308 0x1cdf5000 + 105344820 CoreFoundation 0x1cdff034 0x1cdf5000 + 4101221 Foundation 0x1d74c0ac 0x1d746000 + 2474822 Foundation 0x1d750b2a 0x1d746000 + 4381823 RBPlayer 0x0147f444 0x1477000 + 3386024 AVFoundation 0x237bff7a 0x23759000 + 42175425 AVFoundation 0x237c0626 0x23759000 + 42346226 AVFoundation 0x237c1648 0x23759000 + 42759227 libdispatch.dylib 0x1c5bd796 0x1c5bc000 + 603828 libdispatch.dylib 0x1c5bd782 0x1c5bc000 + 601829 libdispatch.dylib 0x1c5c1d04 0x1c5bc000 + 2381230 CoreFoundation 0x1ceabd68 0x1cdf5000 + 74890431 CoreFoundation 0x1cea9e18 0x1cdf5000 + 74088832 CoreFoundation 0x1cdfd0ee 0x1cdf5000 + 3300633 CoreFoundation 0x1cdfcf10 0x1cdf5000 + 3252834 GraphicsServices 0x1e5a7b40 0x1e59e000 + 3974435 UIKit 0x22181e82 0x22110000 + 46656236 demoApp 0x0010b2ac 0x44000 + 81578837 libdyld.dylib 0x1c5ea4ea 0x1c5e7000 + 13546 线程回溯线程回溯这部分提供应用中所有线程的回溯日志。 回溯是闪退发生时所有活动帧清单。它包含闪退发生时调用函数的清单。Crash 调用堆栈这一部分是我们分析 crash 最重要的信息。一般我们会把焦点放在 crash 线程的堆栈上。因为这样可以帮我最快的找到 crash 的原因。 看下面这行日志: 16 demoApp 0x005b6e78 0x44000 + 5713528 这条调用栈包括下面四部分： 模块号：这里是 6 二进制库名：这里是 demoApp 调用方法的地址：这里是 0x005b6e78 第四部分分为两列，基地址和偏移地址。此处基地址为 0x66000，偏移地址为 19244367。基地址指向 crash 的模块（也是模块的 load 地址）如 UIKit。偏移地址指向 crash 代码的行数。如何转换我们后面讨论。这些信息都保存在 dsym 文件中。 动态库信息这些信息包括动态库名称、UUID、模块起始地址、模块结束地址、指令集种类、安装路径等信息。这些信息都是在符号化堆栈用到的。后面我们讨论怎么用。 特别注意 注意: 你必需同时保留应用二进制文件和 .dSYM 文件才能将崩溃日志完整符号化。每次提交到 iTunes Connect 的构建都必需归档保存。.dSYM 文件和二进制文件是特定绑定于每一次构建和后续构建的，即使来自相同的源代码文件，每一次构建也与其他构建不同，不能相互替换。如果你使用 Build 和 Archive 命令,这些文件会自动放在适当位置。 如果不是使用 Build 和 Archive 命令，最好放到单独的文件夹保存。 附录符号化好的crash文件 12345678910111213141516171819202122232425262728293031 Last Exception Backtrace:0 CoreFoundation 0x1ceefb38 __exceptionPreprocess + 1241 libobjc.A.dylib 0x1c177062 objc_exception_throw + 342 CoreFoundation 0x1ceefa80 +[NSException raise:format:] + 1043 QuartzCore 0x1fd6f826 CA::Layer::set_position(CA::Vec2&lt;double&gt; const&amp;, bool) + 2344 QuartzCore 0x1fd6f9de -[CALayer setPosition:] + 505 QuartzCore 0x1fd70044 -[CALayer setFrame:] + 4846 RBPlayer 0x01483244 -[RBPlayerSlider setValue:] (RBPlayerSlider.m:194)7 RBPlayer 0x0147a3e4 -[RBPlayerBottomMask playerUpdateCurrentSeconds] (RBPlayerBottomMask.m:111)8 CoreFoundation 0x1ce9bdb4 __CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 69 CoreFoundation 0x1ce9b6f4 _CFXRegistrationPost + 37810 CoreFoundation 0x1ce9b4dc ___CFXNotificationPost_block_invoke + 3611 CoreFoundation 0x1cef6304 -[_CFXNotificationRegistrar find:object:observer:enumerator:] + 123812 CoreFoundation 0x1cdff030 _CFXNotificationPost + 53613 Foundation 0x1d74c0a8 -[NSNotificationCenter postNotificationName:object:userInfo:] + 6214 Foundation 0x1d750b26 -[NSNotificationCenter postNotificationName:object:] + 2615 RBPlayer 0x01478440 __32-[RBCorePlayer addTimerObserver]_block_invoke (RBCorePlayer.m:243)16 AVFoundation 0x237bff76 -[AVPeriodicTimebaseObserver _fireBlockForTime:] + 6417 AVFoundation 0x237c0622 -[AVPeriodicTimebaseObserver _handleTimeDiscontinuity] + 23418 AVFoundation 0x237c1644 __AVTimebaseObserver_timebaseNotificationCallback_block_invoke + 12219 libdispatch.dylib 0x1c5bd792 _dispatch_call_block_and_release + 620 libdispatch.dylib 0x1c5bd77e _dispatch_client_callout + 1821 libdispatch.dylib 0x1c5c1d00 _dispatch_main_queue_callback_4CF + 89822 CoreFoundation 0x1ceabd64 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 423 CoreFoundation 0x1cea9e14 __CFRunLoopRun + 84424 CoreFoundation 0x1cdfd0ea CFRunLoopRunSpecific + 46625 CoreFoundation 0x1cdfcf0c CFRunLoopRunInMode + 10026 GraphicsServices 0x1e5a7b3c GSEventRunModal + 7627 UIKit 0x22181e7e UIApplicationMain + 14628 VaccineSale 0x001042a8 main (main.m:15)29 libdyld.dylib 0x1c5ea4e6 _dyld_process_info_notify_release + 26 从符号化完的堆栈信息可以清楚的看出 崩溃是由 RBPlayer 类 RBPlayerSlider 文件 setValue: 方法中 第 194 行引起的. 该行对 layer 的 frame 和 position 进行赋值操作时引起了崩溃. –原创所有,转载请注明出处。]]></content>
      <tags>
        <tag>crash 符号化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CALayer 入门指引]]></title>
    <url>%2F2016%2F10%2F04%2FCALayer-%E5%85%A5%E9%97%A8%E6%8C%87%E5%BC%95%2F</url>
    <content type="text"><![CDATA[本篇文章将会介绍 iOS 中一个老生常谈的话题: layers .你可能已经熟悉iOS中各种各样的views,但可能还不知道每一个view背后都有一个叫做 layer 的东西存在.而layers是组成 Core Animation framework 的重要一部分. 你可能还不了解 layer 的作用,甚至觉得自己从来不曾使用过 layer ,它可能是一个无足轻重的东西, 不管你是否了解 layer ,你的app中到处都是 layer 的身影.你app中每个 view 的背后都有个 layer 在支撑.是它让你的 app 轻松地将每个 view 的位图信息提供给手机 GPUs 绘制.下面的这张图片清楚的展示了 Core Animation 在 iOS 绘制层级中的位置. 为什么要使用 Layers?在智能手机上,用户希望能够飞速的进行各种操作.所以保持界面稳定的刷新帧率给用户丝滑般的感觉就显得尤为重要.在 iOS 系统中屏幕平均每秒钟刷新 60 次,为了保证系统在这个帧率下稳定运行,最基本同时也最强大的能够在 GPU 上精准运行的 OpenGL 就诞生了.OpenGL 提供了手机图形硬件最低层但也是最快的权限.但这也是需要权衡的,OpenGL过于低层,甚至完成最简单的任务都需要大量的代码. 为了缓解这个问题, Core Graphocs 就诞生了. Core Graphocs 可以用更少的代码提供更轻量的高层次的功能.为了让 Core Graphocs 使用起来更简单, Core Animation 也出现了. Core Animation 提供了 CALayer 类,并且能够使用一些基本的的图形能力. 后来苹果公司发现 Core Animation 强大的功能大部分在常规app内并没有使用到.于是苹果公司便推出了具有更高层次图形权限的 UIKit. 这么设计的好处就是你的 app 可以根据需求自由选择不同的图形层次功能.允许灵活选择需要实现的功能有效的防止了不必要的代码产生. UIKit 缺点就是高层次的图形 API 所能提供的功能比较少.我们可以这件事中知道: CALayer 可以让 iOS 系统快速便捷地获得 app 页面上 views 的位图信息, 这些信息将会交付给 Core Graphics 甚至 OpenGL处理 然后通过 GPU 绘制在你的手机屏幕上. 虽然在大部分的情况下我们不需要直接使用 CALayer, 但是低层次的 APIs 提供给开发者很多灵活可定制的功能,我们在文章后面将会提到. 获得 CALayer通过讨论 layers 为什么存在之后, 让我们来学着去使用! 就像我刚才提到的, 每一个 view 的背后都有个 layer 支撑. 我们可以通过 UIView 的属性来获得这个 layer. 假使我们有一个 myView 对象, 我们可以得到它的 layer 就像这样: 1myView.layer 好了, 当我们拿到 view 的 layer 之后都能做些什么操作呢? 你将会对之后我们能做的事之多感到惊奇. 在接下来的文章中我们将会看到 layer 的一些使用方法和所能达到的效果. Demo Project首先, 打开 示例工程 ,学习的最好方法就是实践,接下来我们将要在 app 内的 layer 上添加一些自定义的效果. 打开工程 你将会看到界面很简洁,一个空白的 view 中间有一个方块的 subview. 让我们来帮它美化下. 打开 ViewController.swift 开始操作吧. 切圆角你可以使用 CALayer 的 cornerRadius 属性来制作圆角. 让我们试一下吧. 在 viewDidLoad() 内 添加如下代码: 1box.layer.cornerRadius = 5 正如期望的那样,这行代码在 box 的 layer 上添加了一个 5个点单位的圆角. 就是下面这个样子: 还不错吧! 增加圆角弧度会让 layer 更加的圆滑,相反减少圆角弧度 会让layer 更加的棱角分明. 所有的 layer 默认的圆角弧度是 0 . 增加阴影效果阴影可以让我们的 app 更有立体感,并且阴影在设计界面的时候是非常有帮助的.在阴影效果下 我们可以让 views 看起来像漂浮在屏幕上. 让我们研究下用 CALayer 如何制作出隐形效果. 把下面代码插入到 ViewController 的 viewDidLoad 方法中: 1234box.layer.shadowOffset = CGSizeMake(5, 5)box.layer.shadowOpacity = 0.7box.layer.shadowRadius = 5box.layer.shadowColor = UIColor(red: 44.0/255.0, green: 62.0/255.0, blue: 80.0/255.0, alpha: 1.0).CGColor 第一行 设置 layer 的阴影偏移量是 (5,5). 将阴影的 layer.shadowOffset 设置(5,5), 意味着这个 layer 的阴影是到 box.layer 右边 5 个点单位距离, 下边 5 个单位的距离.第二行 设置 layer 的阴影透明度是 0.7 . 意味着这个阴影应该是70%的不透明度.第三行 设置的是 layer 的阴影半径是5个点. 阴影的范围是 box.layer 的模糊弧度决定的.更高的弧度会让阴影的范围更广,但是更加模糊不可见.更低的弧度会让阴影更加清晰可见度更高. 第四行 设置的是阴影的颜色是深蓝. 注意这里的颜色属性是 CGColor 类型. 而不是 UIColor. 这两个颜色类的转换是非常简单的,你只需要写成 myUIColor.CGColor. 让我们看一下效果: 添加边框 我们能够轻易地使用 CALayer 添加边框.让我们给 box 添加一个边框. 12box.layer.borderColor = UIColor.blueColor().CGColorbox.layer.borderWidth = 3 第一行 设置 box 的边框颜色是蓝色.这将会让 box 的所有边框都是蓝色的.第二行 设置边框线条的宽度是 3 点. 也就是 box 的边框厚度是 3 个点的单位. 让我们看一下 box添加边框之后的效果: 渲染图片你也可以吧一张图片赋值给 layer 这样 layer 就会将这张图片渲染出来. 在这里有一张树的图片, 让我们试着用 layer 来显示这张图片.把下面的代码插入到 viewDidLoad: 123box.layer.contents = UIImage(named: &quot;tree.jpg&quot;)?.CGImagebox.layer.contentsGravity = kCAGravityResizebox.layer.masksToBounds = true 第一行 将图片赋值给 layer 的 contents 属性.第二行 将 layer 的内容这是成自适应大小, 图片会自适应 layer 大小.第三行 将 layer 的任何 扩展到 layer 外的子 layer 部分都剪切掉.如果你不明白是什么意思.你可以将 masksToBounds 设置成 false 来看看他们的区别 (阴影被裁剪掉了): 背景颜色和不透明度研究了在 layer 添加一些 UIKit 无法实现的特殊效果. 我们也应该讨论下通过 CALayer 来修改 UIKit 类的属性的可能性. 比如 你可以修改 view 的背景颜色和不透明度: 12box.layer.backgroundColor = UIColor.blueColor().CGColorbox.layer.opacity = 0.5 CALayer 的性能在 layers 上添加太多的特殊效果会影响到性能, 现在我们来聊一聊可以帮助我们提高 app 性能的 2 个 CALayer 属性. 首先是 drawsAsynchronously 属性.这个属性决定 CPU 是否应该在子线程里渲染 layer. 如果设置成 true, 这个 layer 看起来像我们平时看到的样子, 但是 CPU 需要在子线程中来计算和渲染它.如果你的 app 里面有一个 view 需要频繁重绘(比如一个地图view 或者 tableView),你需要将这个属性设置为 true; 第二个属性是 shouldRasterize,这个属性决定这 layer 是否会栅格化.当这个属性设置为 true 后,这个 layer 只会被绘制一次,当它具有动画时 layer不会被渲染 并且第一次绘制的位图信息将会被回收.当你的app有一个不需要频繁绘制的 view 时 你可以把这个属性设置为 true. 注意 当你设置了shouldRasterize属性后,layer 的外观可能在 Retina 屏上有锯齿. 这是因为 layer 有一个控制 layer 的栅格化因子 rasterizationScale.为了防止这种情况. 将 layer 的 rasterizationScale 设置成 UIScreen.mainScreen().scale 这样就不会出现锯齿了. 栅格化 是PS中的一个专业术语，栅格即像素，栅格化即将矢量图形转化为位图。开启 shouldRasterize 后, CALayer 会被栅格化为 bitmap , layer 的阴影等效果也会被保存到 bitmap 中。 避免 shouldRasterize 和 drawsAsynchronously 的过度使用当我们开启光栅化后,需要注意三点问题。 如果我们更新已光栅化的layer,会造成大量的 offscreen 渲染。 offscreen rendring指的是在图像在绘制到当前屏幕前,需要先进行一次渲染,之后才绘制到当前屏幕。offscreen渲染会耗费大量资源. 因此 CALayer 的光栅化选项的开启与否需要我们仔细衡量使用场景。 只能用在图像内容不变的前提下的： 用于避免静态内容的复杂特效的重绘,例如前面讲到的UIBlurEffect用于避免多个View嵌套的复杂View的重绘。而对于经常变动的内容,这个时候不要开启,否则会造成性能的浪费。 例如我们日程经常打交道的 TableViewCell ,因为 TableViewCell 的重绘是很频繁的（因为Cell 的复用）,如果Cell的内容不断变化,则 Cell 需要不断重绘,如果此时设置了cell.layer 可光栅化。则会造成大量的 offscreen 渲染,降低图形性能。 当然,合理利用的话,是能够得到不少性能的提高的,因为使用 shouldRasterize 后 layer 会缓存为Bitmap位图,对一些添加了 shawdow 等效果的耗费资源较多的静态内容进行缓存,能够得到性能的提升。 不要过度使用,系统限制了缓存的大小为 2.5 x Screen Size.如果过度使用,超出缓存之后,同样会造成大量的 offscreen 渲染。被光栅化的图片如果超过 100ms 没有被使用,则会被移除 因此我们应该只对连续不断使用的图片进行缓存。对于不常使用的图片缓存是没有意义,且耗费资源的。 基于 99% 的情况下 你都不需要手动设置这两个属性.不当的设置它们可能会反而导致你 app 的性能变得更糟. 题外 关于 offscreen rendering 注意到上面提到的 offscreen rendering 。我们需要注意 shouldRasterize 的地方就是会造成 offscreen rendering 的地方,那么为什么需要避免呢？WWDC 2011 Understanding UIKit Rendering 指出一般导致图形性能的问题大部分都出在了 offscreen rendering ,因此如果我们发现列表滚动不流畅,动画卡顿等问题,就可以想想和找出我们哪部分代码导致了大量的 offscreen 渲染。那么为什么 offscreen 渲染会耗费大量资源呢？原因是显卡需要另外 alloc 一块内存来进行渲染,渲染完毕后在绘制到当前屏幕,而且对于显卡来说, onscreen 到 offscreen 的上下文环境切换是非常昂贵的(涉及到 OpenGL 的 pipelines 和 barrier 等),我们在开发应用,提高性能通常要注意的是避免 offscreen rendering 。不需要纠结和拘泥于它的定义.有兴趣可以继续阅读 Andy Matuschak , 前 UIKit team 成员关于offscreen rendering 的 评论 。 总之,我们通常需要避免大量的offscreen rendering.会造成 offscreen rendering的原因有：Any layer with a mask (layer.mask)Any layer with layer.masksToBounds being trueAny layer with layer.allowsGroupOpacity set to YES and layer.opacity is less than 1.0Any layer with a drop shadow (layer.shadow*).Any layer with layer.shouldRasterize being trueAny layer with layer.cornerRadius, layer.edgeAntialiasingMask,layer.allowsEdgeAntialiasing 因此,对于一些需要优化图像性能的场景,我们可以检查我们是否触发了 offscreen rendering 。并用更高效的实现手段来替换。阴影绘制:裁剪图片为圆:Blending 的过多使用检查有无过多offscreen渲染检查有无过多Blending检查有无不正确图片格式,图片是否被放缩,像素是否对齐。检查有无使用复杂的图形效果。 – 原创所有,转载请注明出处。]]></content>
      <tags>
        <tag>CALayer</tag>
      </tags>
  </entry>
</search>