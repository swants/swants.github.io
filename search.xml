<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS APP 崩溃日志分析]]></title>
    <url>%2F2017%2F05%2F11%2FiOS-APP-%E5%B4%A9%E6%BA%83%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在日常开发中,我们难免遇到崩溃.如果是在开发过程中,我们可以直接通过xcode来找到问题所在.如果是在测试的时候崩溃,我们也可以轻易的通过测试机导出crash进行问题定位. 可是一旦当产品上线之后.这一切就变得不那么容易了.庆幸的是市场上已经出现了一些比较好的第三方crash统计服务比如bugly. 可以让我轻松了解到crash时的堆栈信息. 但是bugly也有符号化不到位的情况. 比如: 那么在这种情况下我们应该怎么办呢? 崩溃日志符号化使用xcode符号化 条件: (需要崩溃手机) 如果发生崩溃的手机在手边.可以连上电脑 在xcode中的organizer&gt;device中直接查看符号化好的日志.优点: 操作简单缺点: 如果崩溃日志较多 还需要崩溃时间才能确定是哪个crash文件. crash不好统计 使用symbolicatecrash符号化条件: crash文件 dsYM文件 symbolicatecrashsymbolicatecrash 位置1(/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash) 方法: 将三个文件放在同级下 然后打开终端 进入文件夹目录下 1 . 设置环境变量 1export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer 2 . 符号化 12 ### symbol.crash 就是最后符号化好的文件 ###../symbolicatecrash ../.crash ../.dsym &gt; ../symbol.crash 优点:操作简单缺点:适合针对单个crash 文件符号化 使用atos命令符号化条件: dSYM 和堆栈信息使用 grep 命令 获取该模块的 指令集和加载起始地址 1grep "name armv" ../*.crash 然后用获得的指令集(armv7) 和起始地址(0x4000) 来符号化 12345xcrun atos -o ../.dsYM/../name -l 0x4000(起始地址) -arch -armv7(指令集) //输入目标地址 0x00352aee //得到结果 -[UIScrollView(UITouch) touchesEnded:withEvent:] (in appName) (UIScrollView+UITouch.h:26) 注意 模块只能定位到本模块的位置 不能越层 如:AFN.framework.dSYM 只能定位到AFN内的目标地址位置appName.app.dSYM 只能定位到app内代码的地址位置 优点: 只需要堆栈信息 和符号表就可以. 可以在获取不到Crash文件 但在bugly等第三方统计中获得了堆栈信息的情况下使用.缺点: 一次只能符号化一行,比较繁琐.(可以作为bugly符号化不完全情况下的补充.) 有兴趣的可以实际动手操作下:xcode自带atos脚本: symbolicatecrash 下载crash文件 : demoAPP.crash 下载符号表: demoAPP.app.dSYM 下载第三方模块符号表 RBPlayer.framework.dSYM 下载 crash文件组成分析让我们看一下一个实际的 crash 文件组成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126### 1.进程信息 ###Incident Identifier: CDDADF33-6F8A-44B3-90D1-52D9095ADA0CCrashReporter Key: ed6929203307e230288ce2a758bd7099d3a52e15Hardware Model: iPhone5,2Process: demoApp [9806]Path: /private/var/containers/Bundle/Application/0C5CCF0C-6A7F-4864-BD5A-0765725E0CCB/demoApp.app/demoAppIdentifier: com.yimiao100.demoAppVersion: 6 (1.6)Code Type: ARM (Native)Role: ForegroundParent Process: launchd [1]Coalition: com.yimiao100.demoApp [3588]### 2.基本信息 ###Date/Time: 2017-05-10 10:37:51.2003 +0800Launch Time: 2017-05-10 10:36:26.0000 +0800OS Version: iPhone OS 10.3.1 (14E304)Report Version: 104### 3.异常信息 ###Exception Type: EXC_CRASH (SIGABRT)Exception Codes: 0x0000000000000000, 0x0000000000000000Exception Note: EXC_CORPSE_NOTIFYTriggered by Thread: 0Application Specific Information:abort() calledFiltered syslog:None foundLast Exception Backtrace:(0x1ceefb38 0x1c177062 0x1ceefa80 0x1fd6f826 0x1fd6f9de 0x1fd70044 0x148a244 0x14813e4 0x1ce9bdb4 0x1ce9b6f4 0x1ce9b4dc 0x1cef6304 0x1cdff030 0x1d74c0a8 0x1d750b26 0x147f440 0x237bff76 0x237c0622 0x237c1644 0x1c5bd792 0x1c5bd77e 0x1c5c1d00 0x1ceabd64 0x1cea9e14 0x1cdfd0ea 0x1cdfcf0c 0x1e5a7b3c 0x22181e7e 0x10b2a8 0x1c5ea4e6)### 4.线程回溯 ###Thread 0 name: Dispatch queue: com.apple.main-thread### Crash调用堆栈 ###Thread 0 Crashed:0 libsystem_kernel.dylib 0x1c6bdacc 0x1c6a8000 + 887801 libsystem_pthread.dylib 0x1c7760f6 0x1c771000 + 207262 libsystem_c.dylib 0x1c65295a 0x1c608000 + 3054983 libc++abi.dylib 0x1c157708 0x1c156000 + 58964 libc++abi.dylib 0x1c16e552 0x1c156000 + 996665 libobjc.A.dylib 0x1c17731e 0x1c170000 + 294706 demoApp 0x005b6e78 0x44000 + 57135287 libc++abi.dylib 0x1c16b98e 0x1c156000 + 884628 libc++abi.dylib 0x1c16b1a2 0x1c156000 + 864349 libobjc.A.dylib 0x1c177138 0x1c170000 + 2898410 CoreFoundation 0x1ceefa84 0x1cdf5000 + 102669211 QuartzCore 0x1fd6f82a 0x1fc7c000 + 99741812 QuartzCore 0x1fd6f9e2 0x1fc7c000 + 99785813 QuartzCore 0x1fd70048 0x1fc7c000 + 99949614 RBPlayer 0x0148a248 0x1477000 + 7840815 RBPlayer 0x014813e8 0x1477000 + 4196016 CoreFoundation 0x1ce9bdb8 0x1cdf5000 + 68344817 CoreFoundation 0x1ce9b6f8 0x1cdf5000 + 68172018 CoreFoundation 0x1ce9b4e0 0x1cdf5000 + 68118419 CoreFoundation 0x1cef6308 0x1cdf5000 + 105344820 CoreFoundation 0x1cdff034 0x1cdf5000 + 4101221 Foundation 0x1d74c0ac 0x1d746000 + 2474822 Foundation 0x1d750b2a 0x1d746000 + 4381823 RBPlayer 0x0147f444 0x1477000 + 3386024 AVFoundation 0x237bff7a 0x23759000 + 42175425 AVFoundation 0x237c0626 0x23759000 + 42346226 AVFoundation 0x237c1648 0x23759000 + 42759227 libdispatch.dylib 0x1c5bd796 0x1c5bc000 + 603828 libdispatch.dylib 0x1c5bd782 0x1c5bc000 + 601829 libdispatch.dylib 0x1c5c1d04 0x1c5bc000 + 2381230 CoreFoundation 0x1ceabd68 0x1cdf5000 + 74890431 CoreFoundation 0x1cea9e18 0x1cdf5000 + 74088832 CoreFoundation 0x1cdfd0ee 0x1cdf5000 + 3300633 CoreFoundation 0x1cdfcf10 0x1cdf5000 + 3252834 GraphicsServices 0x1e5a7b40 0x1e59e000 + 3974435 UIKit 0x22181e82 0x22110000 + 46656236 demoApp 0x0010b2ac 0x44000 + 81578837 libdyld.dylib 0x1c5ea4ea 0x1c5e7000 + 13546### 其他线程 ###Thread 1 name: Dispatch queue: com.apple.root.default-qosThread 1:0 libsystem_kernel.dylib 0x1c6bde7c 0x1c6a8000 + 897241 libsystem_c.dylib 0x1c6120e8 0x1c608000 + 411922 Foundation 0x1d834c36 0x1d746000 + 9779743 demoApp 0x00228310 0x44000 + 19832484 libdispatch.dylib 0x1c5bd796 0x1c5bc000 + 60385 libdispatch.dylib 0x1c5cab1c 0x1c5bc000 + 601886 libdispatch.dylib 0x1c5cc1b4 0x1c5bc000 + 659727 libdispatch.dylib 0x1c5cc00e 0x1c5bc000 + 655508 libsystem_pthread.dylib 0x1c7728ec 0x1c771000 + 63809 libsystem_pthread.dylib 0x1c7724cc 0x1c771000 + 5324Thread 2 name: com.apple.uikit.eventfetch-threadThread 2:0 libsystem_kernel.dylib 0x1c6a8900 0x1c6a8000 + 23041 libsystem_kernel.dylib 0x1c6a86e0 0x1c6a8000 + 17602 CoreFoundation 0x1ceabbe2 0x1cdf5000 + 7485143 CoreFoundation 0x1ceaa064 0x1cdf5000 + 741476...Thread 3 name: com.apple.NSURLConnectionLoaderThread 3:0 libsystem_kernel.dylib 0x1c6a8900 0x1c6a8000 + 23041 libsystem_kernel.dylib 0x1c6a86e0 0x1c6a8000 + 17602 CoreFoundation 0x1ceabbe2 0x1cdf5000 + 7485143 CoreFoundation 0x1ceaa064 0x1cdf5000 + 7414764 CoreFoundation 0x1cdfd0ee 0x1cdf5000 + 33006...... ...Thread 0 crashed with ARM Thread State (32-bit): r0: 0x00000000 r1: 0x00000000 r2: 0x00000000 r3: 0x0000006e r4: 0x00000006 r5: 0x3a697e40 r6: 0x397d430c r7: 0x00c88044 r8: 0x00000002 r9: 0x00000000 r10: 0x40000000 r11: 0x158ee214 ip: 0x00000148 sp: 0x00c88038 lr: 0x1c7760f7 pc: 0x1c6bdacc cpsr: 0x00000010### 5.动态库信息 ###Binary Images:0x44000 - 0x85ffff demoApp armv7 &lt;4d8140e3978f35d29c938c2659aa766d&gt; /var/containers/Bundle/Application/0C5CCF0C-6A7F-4864-BD5A-0765725E0CCB/demoApp.app/demoApp0xa4d000 - 0xa78fff AFNetworking armv7 &lt;f0d55a034b7f3eb7b90a1214a8639f1a&gt; /var/containers/Bundle/Application/0C5CCF0C-6A7F-4864-BD5A-0765725E0CCB/demoApp.app/Frameworks/AFNetworking.framework/AFNetworking0x1477000 - 0x1496fff RBPlayer armv7 &lt;f03427c9cf4e32ddae455c67d3a157ac&gt; /var/containers/Bundle/Application/0C5CCF0C-6A7F-4864-BD5A-0765725E0CCB/demoApp.app/Frameworks/RBPlayer.framework/RBPlayerEOF 进程信息第一部分是闪退进程的相关信息。 Incident Identifier是崩溃报告的唯一标识符。 CrashReporter Key是与设备标识相对应的唯一键值。虽然它不是真正的设备标识符，但也是一个非常有用的情报:如果你看到100个崩溃日志的CrashReporter Key值都是相同的，或者只有少数几个不同的CrashReport值，说明这不是一个普遍的问题，只发生在一个或少数几个设备上。 Hardware Model 标识设备类型。 如果很多崩溃日志都是来自相同的设备类型，说明应用只在某特定类型的设备上有问题。上面的日志里，崩溃日志产生的设备是iPhone5。 Process 是应用名称。中括号里面的数字是闪退时应用的进程ID。 基本信息 VersionAPP的版本号 OS VersioniOS操作系统版本号 iPhone OS 10.3.1 (14E304)10.3.1：系统版本14E304：build号这里要所以下build号。每个系统版本号有可能会对应多个build号。如苹果发布的10.3.1会有几个版本，如：电信版本、联通版本等。build号我们后面对日志符号化的时候会用到。 异常信息在这部分，你可以看到闪退发生时抛出的异常类型。还能看到异常编码和抛出异常的线程。根据崩溃报告类型的不同，在这部分你还能看到一些另外的信息。 Crashed Threadcrash线程号。可以根据这个编号找到对应的crash调用堆栈，当前crash线程的编号为0，所以我们可以直接找到crash线程的堆栈信息：12345678910111213141516171819202122232425262728293031323334353637383940Thread 0 name: Dispatch queue: com.apple.main-threadThread 0 Crashed:0 libsystem_kernel.dylib 0x1c6bdacc 0x1c6a8000 + 887801 libsystem_pthread.dylib 0x1c7760f6 0x1c771000 + 207262 libsystem_c.dylib 0x1c65295a 0x1c608000 + 3054983 libc++abi.dylib 0x1c157708 0x1c156000 + 58964 libc++abi.dylib 0x1c16e552 0x1c156000 + 996665 libobjc.A.dylib 0x1c17731e 0x1c170000 + 294706 demoApp 0x005b6e78 0x44000 + 57135287 libc++abi.dylib 0x1c16b98e 0x1c156000 + 884628 libc++abi.dylib 0x1c16b1a2 0x1c156000 + 864349 libobjc.A.dylib 0x1c177138 0x1c170000 + 2898410 CoreFoundation 0x1ceefa84 0x1cdf5000 + 102669211 QuartzCore 0x1fd6f82a 0x1fc7c000 + 99741812 QuartzCore 0x1fd6f9e2 0x1fc7c000 + 99785813 QuartzCore 0x1fd70048 0x1fc7c000 + 99949614 RBPlayer 0x0148a248 0x1477000 + 7840815 RBPlayer 0x014813e8 0x1477000 + 4196016 CoreFoundation 0x1ce9bdb8 0x1cdf5000 + 68344817 CoreFoundation 0x1ce9b6f8 0x1cdf5000 + 68172018 CoreFoundation 0x1ce9b4e0 0x1cdf5000 + 68118419 CoreFoundation 0x1cef6308 0x1cdf5000 + 105344820 CoreFoundation 0x1cdff034 0x1cdf5000 + 4101221 Foundation 0x1d74c0ac 0x1d746000 + 2474822 Foundation 0x1d750b2a 0x1d746000 + 4381823 RBPlayer 0x0147f444 0x1477000 + 3386024 AVFoundation 0x237bff7a 0x23759000 + 42175425 AVFoundation 0x237c0626 0x23759000 + 42346226 AVFoundation 0x237c1648 0x23759000 + 42759227 libdispatch.dylib 0x1c5bd796 0x1c5bc000 + 603828 libdispatch.dylib 0x1c5bd782 0x1c5bc000 + 601829 libdispatch.dylib 0x1c5c1d04 0x1c5bc000 + 2381230 CoreFoundation 0x1ceabd68 0x1cdf5000 + 74890431 CoreFoundation 0x1cea9e18 0x1cdf5000 + 74088832 CoreFoundation 0x1cdfd0ee 0x1cdf5000 + 3300633 CoreFoundation 0x1cdfcf10 0x1cdf5000 + 3252834 GraphicsServices 0x1e5a7b40 0x1e59e000 + 3974435 UIKit 0x22181e82 0x22110000 + 46656236 demoApp 0x0010b2ac 0x44000 + 81578837 libdyld.dylib 0x1c5ea4ea 0x1c5e7000 + 13546 线程回溯线程回溯这部分提供应用中所有线程的回溯日志。 回溯是闪退发生时所有活动帧清单。它包含闪退发生时调用函数的清单。Crash调用堆栈这一部分是我们分析crash最重要的信息。一般我们会把焦点放在crash线程的堆栈上。因为这样可以帮我最快的找到crash的原因。 看下面这行日志: 16 demoApp 0x005b6e78 0x44000 + 5713528 这条调用栈包括下面四部分： 模块号：这里是6 二进制库名：这里是demoApp 调用方法的地址：这里是0x005b6e78 第四部分分为两列，基地址和偏移地址。此处基地址为0x66000，偏移地址为19244367。基地址指向crash的模块（也是模块的load地址）如UIKit。偏移地址指向crash代码的行数。如何转换我们后面讨论。这些信息都保存在dsym文件中。 动态库信息这些信息包括动态库名称、UUID、模块起始地址、模块结束地址、指令集种类、安装路径等信息。这些信息都是在符号化堆栈用到的。后面我们讨论怎么用。 特别注意 注意: 你必需同时保留应用二进制文件和.dSYM文件才能将崩溃日志完整符号化。每次提交到iTunes Connect的构建都必需归档保存。.dSYM文件和二进制文件是特定绑定于每一次构建和后续构建的，即使来自相同的源代码文件，每一次构建也与其他构建不同，不能相互替换。如果你使用Build 和 Archive 命令,这些文件会自动放在适当位置。 如果不是使用Build 和 Archive命令，最好放到单独的文件夹保存。 附录符号化好的crash文件 12345678910111213141516171819202122232425262728293031 Last Exception Backtrace:0 CoreFoundation 0x1ceefb38 __exceptionPreprocess + 1241 libobjc.A.dylib 0x1c177062 objc_exception_throw + 342 CoreFoundation 0x1ceefa80 +[NSException raise:format:] + 1043 QuartzCore 0x1fd6f826 CA::Layer::set_position(CA::Vec2&lt;double&gt; const&amp;, bool) + 2344 QuartzCore 0x1fd6f9de -[CALayer setPosition:] + 505 QuartzCore 0x1fd70044 -[CALayer setFrame:] + 4846 RBPlayer 0x01483244 -[RBPlayerSlider setValue:] (RBPlayerSlider.m:194)7 RBPlayer 0x0147a3e4 -[RBPlayerBottomMask playerUpdateCurrentSeconds] (RBPlayerBottomMask.m:111)8 CoreFoundation 0x1ce9bdb4 __CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 69 CoreFoundation 0x1ce9b6f4 _CFXRegistrationPost + 37810 CoreFoundation 0x1ce9b4dc ___CFXNotificationPost_block_invoke + 3611 CoreFoundation 0x1cef6304 -[_CFXNotificationRegistrar find:object:observer:enumerator:] + 123812 CoreFoundation 0x1cdff030 _CFXNotificationPost + 53613 Foundation 0x1d74c0a8 -[NSNotificationCenter postNotificationName:object:userInfo:] + 6214 Foundation 0x1d750b26 -[NSNotificationCenter postNotificationName:object:] + 2615 RBPlayer 0x01478440 __32-[RBCorePlayer addTimerObserver]_block_invoke (RBCorePlayer.m:243)16 AVFoundation 0x237bff76 -[AVPeriodicTimebaseObserver _fireBlockForTime:] + 6417 AVFoundation 0x237c0622 -[AVPeriodicTimebaseObserver _handleTimeDiscontinuity] + 23418 AVFoundation 0x237c1644 __AVTimebaseObserver_timebaseNotificationCallback_block_invoke + 12219 libdispatch.dylib 0x1c5bd792 _dispatch_call_block_and_release + 620 libdispatch.dylib 0x1c5bd77e _dispatch_client_callout + 1821 libdispatch.dylib 0x1c5c1d00 _dispatch_main_queue_callback_4CF + 89822 CoreFoundation 0x1ceabd64 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 423 CoreFoundation 0x1cea9e14 __CFRunLoopRun + 84424 CoreFoundation 0x1cdfd0ea CFRunLoopRunSpecific + 46625 CoreFoundation 0x1cdfcf0c CFRunLoopRunInMode + 10026 GraphicsServices 0x1e5a7b3c GSEventRunModal + 7627 UIKit 0x22181e7e UIApplicationMain + 14628 VaccineSale 0x001042a8 main (main.m:15)29 libdyld.dylib 0x1c5ea4e6 _dyld_process_info_notify_release + 26 从符号化完的堆栈信息可以清楚的看出 崩溃是由 RBPlayer类 RBPlayerSlider文件 setValue:方法中 第194行引起的. 该行对layer的frame和position进行赋值操作时引起了崩溃. –原创所有,转载请注明出处]]></content>
      <tags>
        <tag>crash 符号化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CALayer 入门指引]]></title>
    <url>%2F2016%2F10%2F04%2FCALayer-%E5%85%A5%E9%97%A8%E6%8C%87%E5%BC%95%2F</url>
    <content type="text"><![CDATA[本篇文章将会介绍 iOS 中一个老生常谈的话题: layers .你可能已经熟悉iOS中各种各样的views,但可能还不知道每一个view背后都有一个叫做 layer 的东西存在.而layers是组成 Core Animation framework 的重要一部分. 你可能还不了解 layer 的作用,甚至觉得自己从来不曾使用过 layer ,它可能是一个无足轻重的东西, 不管你是否了解 layer ,你的app中到处都是 layer 的身影.你app中每个 view 的背后都有个 layer 在支撑.是它让你的 app 轻松地将每个 view 的位图信息提供给手机 GPUs 绘制.下面的这张图片清楚的展示了 Core Animation 在iOS绘制层级中的位置. 为什么要使用 Layers?在智能手机上,用户希望能够飞速的进行各种操作.所以保持界面稳定的刷新帧率给用户丝滑般的感觉就显得尤为重要.在 iOS 系统中屏幕平均每秒钟刷新 60 次,为了保证系统在这个帧率下稳定运行,最基本同时也最强大的能够在 GPU 上精准运行的 OpenGL 就诞生了.OpenGL 提供了手机图形硬件最低层但也是最快的权限.但这也是需要权衡的,OpenGL过于低层,甚至完成最简单的任务都需要大量的代码. 为了缓解这个问题, Core Graphocs 就诞生了. Core Graphocs 可以用更少的代码提供更轻量的高层次的功能.为了让 Core Graphocs 使用起来更简单, Core Animation 也出现了. Core Animation 提供了 CALayer 类,并且能够使用一些基本的的图形能力. 后来苹果公司发现 Core Animation 强大的功能大部分在常规app内并没有使用到.于是苹果公司便推出了具有更高层次图形权限的 UIKit. 这么设计的好处就是你的 app 可以根据需求自由选择不同的图形层次功能.允许灵活选择需要实现的功能有效的防止了不必要的代码产生. UIKit 缺点就是高层次的图形 API 所能提供的功能比较少.我们可以这件事中知道: CALayer 可以让 iOS 系统快速便捷地获得 app 页面上 views 的位图信息, 这些信息将会交付给 Core Graphics 甚至 OpenGL处理 然后通过 GPU 绘制在你的手机屏幕上. 虽然在大部分的情况下我们不需要直接使用 CALayer, 但是低层次的 APIs 提供给开发者很多灵活可定制的功能,我们在文章后面将会提到. 获得 CALayer通过讨论 layers 为什么存在之后, 让我们来学着去使用! 就像我刚才提到的, 每一个 view 的背后都有个 layer 支撑. 我们可以通过 UIView 的属性来获得这个 layer. 假使我们有一个 myView 对象, 我们可以得到它的 layer 就像这样: 1myView.layer 好了, 当我们拿到 view 的 layer 之后都能做些什么操作呢? 你将会对之后我们能做的事之多感到惊奇. 在接下来的文章中我们将会看到 layer 的一些使用方法和所能达到的效果. Demo Project首先, 打开 示例工程 ,学习的最好方法就是实践,接下来我们将要在 app 内的 layer 上添加一些自定义的效果. 打开工程 你将会看到界面很简洁,一个空白的 view 中间有一个方块的 subview. 让我们来帮它美化下. 打开 ViewController.swift 开始操作吧. 切圆角你可以使用 CALayer 的 cornerRadius 属性来制作圆角. 让我们试一下吧. 在 viewDidLoad() 内 添加如下代码: 1box.layer.cornerRadius = 5 正如期望的那样,这行代码在 box 的 layer 上添加了一个 5个点单位的圆角. 就是下面这个样子: 还不错吧! 增加圆角弧度会让 layer 更加的圆滑,相反减少圆角弧度 会让layer 更加的棱角分明. 所有的 layer 默认的圆角弧度是 0 . 增加阴影效果阴影可以让我们的 app 更有立体感,并且阴影在设计界面的时候是非常有帮助的.在阴影效果下 我们可以让 views 看起来像漂浮在屏幕上. 让我们研究下用 CALayer 如何制作出隐形效果. 把下面代码插入到 ViewController 的 viewDidLoad 方法中: 1234box.layer.shadowOffset = CGSizeMake(5, 5)box.layer.shadowOpacity = 0.7box.layer.shadowRadius = 5box.layer.shadowColor = UIColor(red: 44.0/255.0, green: 62.0/255.0, blue: 80.0/255.0, alpha: 1.0).CGColor 第一行 设置 layer 的阴影偏移量是 (5,5). 将阴影的 layer.shadowOffset 设置(5,5), 意味着这个 layer 的阴影是到 box.layer 右边 5 个点单位距离, 下边 5 个单位的距离.第二行 设置 layer 的阴影透明度是 0.7 . 意味着这个阴影应该是70%的不透明度.第三行 设置的是 layer 的阴影半径是5个点. 阴影的范围是 box.layer 的模糊弧度决定的.更高的弧度会让阴影的范围更广,但是更加模糊不可见.更低的弧度会让阴影更加清晰可见度更高. 第四行 设置的是阴影的颜色是深蓝. 注意这里的颜色属性是 CGColor 类型. 而不是 UIColor. 这两个颜色类的转换是非常简单的,你只需要写成 myUIColor.CGColor. 让我们看一下效果: 添加边框 我们能够轻易地使用 CALayer 添加边框.让我们给 box 添加一个边框. 12box.layer.borderColor = UIColor.blueColor().CGColorbox.layer.borderWidth = 3 第一行 设置 box 的边框颜色是蓝色.这将会让 box 的所有边框都是蓝色的.第二行 设置边框线条的宽度是 3 点. 也就是 box 的边框厚度是 3 个点的单位. 让我们看一下 box添加边框之后的效果: 渲染图片你也可以吧一张图片赋值给 layer 这样 layer 就会将这张图片渲染出来. 在这里有一张树的图片, 让我们试着用 layer 来显示这张图片.把下面的代码插入到 viewDidLoad: 123box.layer.contents = UIImage(named: &quot;tree.jpg&quot;)?.CGImagebox.layer.contentsGravity = kCAGravityResizebox.layer.masksToBounds = true 第一行 将图片赋值给 layer 的 contents 属性.第二行 将 layer 的内容这是成自适应大小, 图片会自适应 layer 大小.第三行 将 layer 的任何 扩展到 layer 外的子 layer 部分都剪切掉.如果你不明白是什么意思.你可以将 masksToBounds 设置成 false 来看看他们的区别 (阴影被裁剪掉了): 背景颜色和不透明度研究了在 layer 添加一些 UIKit 无法实现的特殊效果. 我们也应该讨论下通过 CALayer 来修改 UIKit 类的属性的可能性. 比如 你可以修改 view 的背景颜色和不透明度: 12box.layer.backgroundColor = UIColor.blueColor().CGColorbox.layer.opacity = 0.5 CALayer 的性能在 layers 上添加太多的特殊效果会影响到性能, 现在我们来聊一聊可以帮助我们提高 app 性能的 2 个 CALayer 属性. 首先是 drawsAsynchronously 属性.这个属性决定 CPU 是否应该在子线程里渲染 layer. 如果设置成 true, 这个 layer 看起来像我们平时看到的样子, 但是 CPU 需要在子线程中来计算和渲染它.如果你的 app 里面有一个 view 需要频繁重绘(比如一个地图view 或者 tableView),你需要将这个属性设置为 true; 第二个属性是 shouldRasterize,这个属性决定这 layer 是否会栅格化.当这个属性设置为 true 后,这个 layer 只会被绘制一次,当它具有动画时 layer不会被渲染 并且第一次绘制的位图信息将会被回收.当你的app有一个不需要频繁绘制的 view 时 你可以把这个属性设置为 true. 注意 当你设置了shouldRasterize属性后,layer 的外观可能在 Retina 屏上有锯齿. 这是因为 layer 有一个控制 layer 的栅格化因子 rasterizationScale.为了防止这种情况. 将 layer 的 rasterizationScale 设置成 UIScreen.mainScreen().scale 这样就不会出现锯齿了. 栅格化 是PS中的一个专业术语，栅格即像素，栅格化即将矢量图形转化为位图。开启 shouldRasterize 后, CALayer 会被栅格化为 bitmap , layer 的阴影等效果也会被保存到 bitmap 中。 避免 shouldRasterize 和 drawsAsynchronously 的过度使用当我们开启光栅化后,需要注意三点问题。 如果我们更新已光栅化的layer,会造成大量的 offscreen 渲染。 offscreen rendring指的是在图像在绘制到当前屏幕前,需要先进行一次渲染,之后才绘制到当前屏幕。offscreen渲染会耗费大量资源. 因此 CALayer 的光栅化选项的开启与否需要我们仔细衡量使用场景。只能用在图像内容不变的前提下的： 用于避免静态内容的复杂特效的重绘,例如前面讲到的UIBlurEffect用于避免多个View嵌套的复杂View的重绘。而对于经常变动的内容,这个时候不要开启,否则会造成性能的浪费。 例如我们日程经常打交道的 TableViewCell ,因为 TableViewCell 的重绘是很频繁的（因为Cell 的复用）,如果Cell的内容不断变化,则 Cell 需要不断重绘,如果此时设置了cell.layer 可光栅化。则会造成大量的 offscreen 渲染,降低图形性能。 当然,合理利用的话,是能够得到不少性能的提高的,因为使用 shouldRasterize 后 layer 会缓存为Bitmap位图,对一些添加了 shawdow 等效果的耗费资源较多的静态内容进行缓存,能够得到性能的提升。 不要过度使用,系统限制了缓存的大小为2.5X Screen Size.如果过度使用,超出缓存之后,同样会造成大量的 offscreen 渲染。被光栅化的图片如果超过 100ms 没有被使用,则会被移除 因此我们应该只对连续不断使用的图片进行缓存。对于不常使用的图片缓存是没有意义,且耗费资源的。 基于99%的情况下 你都不需要手动设置这两个属性.不当的设置它们可能会反而导致你 app 的性能变得更糟. 题外 关于offscreen rendering 注意到上面提到的 offscreen rendering 。我们需要注意shouldRasterize的地方就是会造成offscreen rendering的地方,那么为什么需要避免呢？WWDC 2011 Understanding UIKit Rendering指出一般导致图形性能的问题大部分都出在了offscreen rendering,因此如果我们发现列表滚动不流畅,动画卡顿等问题,就可以想想和找出我们哪部分代码导致了大量的offscreen 渲染。那么为什么offscreen渲染会耗费大量资源呢？原因是显卡需要另外alloc一块内存来进行渲染,渲染完毕后在绘制到当前屏幕,而且对于显卡来说,onscreen到offscreen的上下文环境切换是非常昂贵的(涉及到OpenGL的pipelines和barrier等),我们在开发应用,提高性能通常要注意的是避免offscreen rendering。不需要纠结和拘泥于它的定义.有兴趣可以继续阅读Andy Matuschak, 前UIKit team成员关于offscreen rendering的 评论. 总之,我们通常需要避免大量的offscreen rendering.会造成 offscreen rendering的原因有：Any layer with a mask (layer.mask)Any layer with layer.masksToBounds being trueAny layer with layer.allowsGroupOpacity set to YES and layer.opacity is less than 1.0Any layer with a drop shadow (layer.shadow*).Any layer with layer.shouldRasterize being trueAny layer with layer.cornerRadius, layer.edgeAntialiasingMask,layer.allowsEdgeAntialiasing 因此,对于一些需要优化图像性能的场景,我们可以检查我们是否触发了offscreen rendering。并用更高效的实现手段来替换。阴影绘制:裁剪图片为圆:Blending 的过多使用检查有无过多offscreen渲染检查有无过多Blending检查有无不正确图片格式,图片是否被放缩,像素是否对齐。检查有无使用复杂的图形效果。 –原创所有,转载请注明出处]]></content>
      <tags>
        <tag>CALayer</tag>
      </tags>
  </entry>
</search>