<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用 NSProxy 代理解决 NSTimer 内存泄漏]]></title>
    <url>%2F2019%2F02%2F12%2F%E4%BD%BF%E7%94%A8%20NSProxy%20%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%20NSTimer%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.html</url>
    <content type="text"><![CDATA[NSProxy 是什么?NSProxy 是一个抽象根类。换句话说， 它没有父类； 它是一个抽象类，没有具体实现。 因此它常常作为其他对象或尚不存在对象的代理，定义对象的 API。 关于 NSProxy 的简单介绍通常，当 proxy 收到消息时，它会将消息转发给实际的处理对象，或加载/转换为实际的消息处理对象进行处理。NSProxy 的子类可以用于实现透明的消息转发（例如 NSDistantObject），或者用于延迟资源消耗较大对象的创建时机。 NSProxy 实现了作为根类需要实现的基本方法（包括 NSObject 协议方法），同时作为抽象类，proxy 不能提供初始化方法，当收到未实现的消息时抛出异常。proxy 正确实现的子类，必须提供一个初始化或创建方法，并且重写 forwardInvocation: 和 methodSignatureForSelector: 方法来处理它本身未实现的消息。 forwardInvocation: 将给定的调用传递给 proxy 实际代理的对象 methodSignatureForSelector: 默认抛出 NSInvalidArgumentException，重写这个方法可以为 proxy 代理对象返回一个合适的 NSMethodSignature 对象， NSProxy 为什么可以解决 NSTimer 循环引用?循环引用情况分析：VC -&gt; timer -&gt; VC(target), runloop -&gt; timer 基于 NSProxy 消息转发的特性，让 NSProxy 子类弱持有 target，将收到的消息转发给实际的消息处理类，即 VC。 此时的引用情况： VC —&gt; timer —&gt; Proxy --&gt; VC(target)， runloop —&gt; timer 循环引用此时便被打破了，这样做的 好处 是易拓展，低耦和，符合设计模式中的开闭原则和迪米特法则。因此 在一些开源框架中常常使用 proxy 持有一个弱引用的 target， 来打破 NSTimer、CADisplayLink 与 target 之间的循环引用。 解决的其它正确姿势：iOS 10 之后 NSTimer 提供了 block 支持的API，而 iOS 10 之前循环引用的常见解决方式： VC 弱引用 timer，在 VC 的 viewWillDisappear: 中调用 invalidate 废弃 timer引用情况为 VC --&gt; timer —&gt; VC(target), runloop —&gt; timer 添加 NSTimer 分类 结合 Block 调用定时方法，VC 的 dealloc 方法中调用 invalidateVC —&gt; timer —&gt; NSTimer(target 类方法执行 block), runloop —&gt; timer 使用中间类进行解耦，中间类弱引用 target并重写消息转发方法 forwardInvocation 让 VC 处理消息VC —&gt; timer —&gt; MiddleClass(消息转发给 target 处理) --&gt; VC(target)， runloop —&gt; timer 最后一点本质上和使用 NSProxy 相同，而使用 Proxy 代理的优点是：可以直接进行消息转发，和第三点相比跳过了消息派发和动态方法解析阶段，因此效率较高一些。 错误的解决方式：12__weak typeof(self) weakSelf = self;_timer = [NSTimer scheduledTimerWithTimeInterval:3.0f target:weakSelf selector:@selector(doSomthing) userInfo:nil repeats:YES]; 即使 weakSelf 并将 target 指向 weakSelf， timer 还是会强引用 self。因为所有权修饰符无论是 __weak 还是 __strong ，在 NSTimer 中都会生成新的强引用指针重新指向，导致循环引用的。 apple 文档：The timer maintains a strong reference to target until it (the timer) is invalidated. Proxy 怎么用?YYImage 内 Proxy 比较规范的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** A proxy used to hold a weak object. It can be used to avoid retain cycles, such as the target in NSTimer or CADisplayLink. */@interface _YYImageWeakProxy : NSProxy@property (nonatomic, weak, readonly) id target;- (instancetype)initWithTarget:(id)target;+ (instancetype)proxyWithTarget:(id)target;@end@implementation _YYImageWeakProxy- (instancetype)initWithTarget:(id)target &#123; _target = target; return self;&#125;+ (instancetype)proxyWithTarget:(id)target &#123; return [[_YYImageWeakProxy alloc] initWithTarget:target];&#125;// 将消息转发给实际处理类- (id)forwardingTargetForSelector:(SEL)selector &#123; return _target;&#125;// 防止抛出异常- (void)forwardInvocation:(NSInvocation *)invocation &#123; void *null = NULL; [invocation setReturnValue:&amp;null];&#125;// 这里默认返回init 方法的签名，目的是防止抛出异常- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector &#123; return [NSObject instanceMethodSignatureForSelector:@selector(init)];&#125;// Proxy 其它的一些自省方法，可不实现- (BOOL)respondsToSelector:(SEL)aSelector &#123; return [_target respondsToSelector:aSelector];&#125;- (BOOL)isEqual:(id)object &#123; return [_target isEqual:object];&#125;- (NSUInteger)hash &#123; return [_target hash];&#125;- (Class)superclass &#123; return [_target superclass];&#125;- (Class)class &#123; return [_target class];&#125;- (BOOL)isKindOfClass:(Class)aClass &#123; return [_target isKindOfClass:aClass];&#125;- (BOOL)isMemberOfClass:(Class)aClass &#123; return [_target isMemberOfClass:aClass];&#125;- (BOOL)conformsToProtocol:(Protocol *)aProtocol &#123; return [_target conformsToProtocol:aProtocol];&#125;- (BOOL)isProxy &#123; return YES;&#125;- (NSString *)description &#123; return [_target description];&#125;- (NSString *)debugDescription &#123; return [_target debugDescription];&#125;@end 参考文档 NSTimer 文档: https://developer.apple.com/documentation/foundation/nstimer NSProxy 文档: https://developer.apple.com/documentation/foundation/nsproxy YYImage: https://github.com/ibireme/YYImage]]></content>
      <tags>
        <tag>内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸡是如何度过2018年的]]></title>
    <url>%2F2018%2F12%2F29%2F%E8%8F%9C%E9%B8%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%BA%A6%E8%BF%872018%E5%B9%B4%E7%9A%84.html</url>
    <content type="text"><![CDATA[​ 感觉昨天才刚写完 2017 总结，今天就要着手 2018 的年终总结了，心丧~，人到中年，才深深体会到逝者如斯夫的真正含义。 ^.^! 2018 发生了很多，我也成长了很多，这一年无论在工作上还是生活上都走过了一些人生的重要的节点，明显感觉到现在和之前的自己有了很大的进步。就如题目，2018 年对自己的总结定位还是十分贴切的。 工作上 阔别呆了两年的创业公司，充满不舍却也非常无奈。人不能一直呆在舒适区拒绝成长，尤其是漂泊在北京。5月份来到新公司，结束了几年的 iOS 独立开发之路。见识到团队协作开发模式，为了适应团队协作的模式，踩了很多 git、pods 私有源模块化协作的坑。见识到了各自开发互不影响的高效开发模式，在开发视角高度上提升了很多。前两个月还在公司内部的软件比赛上打了个酱油，得了个团队三等奖（50%的中奖率，想不得也挺难的）。于此同时却也被体制内流程的推进和沟通的巨大成本所困扰，总体上来说没有背离当初离开上家公司的初衷。 在新公司开始尝试 Swift 结合模块化开发项目，学习了 Rxswift、Alamofire、Moya 的使用。业余时间研究了 Masonry、JSPatch、Git、YYCache 的原理，开始静下心来尝试阅读框架源码，写一些小 demo 总结自己的心得体会，不再单单拾人牙慧，2018 这一改变是非常值得纪念的。 生活上阅读 完成了去年书单大部分书目的阅读，包括巨人的陨落、世界的凛冬(还差最后一部永恒的边缘)、亲密关系、解忧杂货店、全球通史、达芬奇密码、简单逻辑学、公正。 技术方面：程序员的自我修养、iOS高级编程、 52个effective方法、swift 100Tips、 图解http 、编写可读代码的艺术。 摄影 系统了解下摄影史，认识了曼雷、亚当斯、薇薇安等人的作品。意识到摄影本质上是摄影师思想的创作表达，⽽不单纯的是记录，⽽正是这⼀特质让摄影最终能够成为⼀⻔艺术而不是一门技艺。认识到关于照片加不加后期的争论毫无意义，不加后期而通过好的机位、合适的快⻔、合适的光圈得到⼀张漂亮的照⽚本身也是摄影师思想的创作表达；通过后期减少杂色干扰、提⾼对⽐度同样是摄影师主观思想的表达，两者并没有本质上的区别。 2018 一整年外拍的次数并不多，也没有修出几张拿得出手的照片，这一点上还是挺遗憾的。 视野 老板前年画的饼终于要实现了， 公司在3月末的时候组织了次泰国五日游， 我也沾光体验到了墙以外的世界，见识到了安逸到懒散的多妻制异域生活，切身体会到宗教对一个国家的影响力（泰国的男孩出生后必须要当一段时间沙弥） 意识到大乘佛教与小乘佛教的不同，也满眼羡慕下泰国的医疗福利保障。（不管你是拿药手术住院还是癌症费用都只要30泰铢（合人民币6块钱），完全不需要承担国内巨大的看病压力。）。相比这些看得见够不着的东西，没什么比体验一把马杀鸡更舒服的事了 ^-^。 关于佛教的一点个人总结 佛教的四⼤真理是：⼈⽣是苦的 苦的原因在于欲望 只有消灭⼀切欲望才能消灭苦因，断绝苦果。要做到这⼀切，只有通过⼋正道，正⻅ 正志 正语 正业 正命 正精进 正念 正定。 佛教以涅架为终极⽬的，意为 ⽆为 寂灭，而佛教又分为大乘佛教和小乘佛教，国人所了解到的佛教一般都为大乘佛教，而泰国则是小乘佛教。 ⼩乘佛教 在于修⼰ 通过苦修身⼼ 最终达到涅架境界（也就是我们所说的苦行僧） ⼤乘佛教 在于普度众⽣ 注重施舍 虔诚信仰 灵魂救赎 其他爱好2018 年鬼使神差喜欢上古典乐，迷上了巴赫的大提琴，听着低沉悠扬的琴声，浮躁的心便感到宁静。 入了任天堂的坑，终日在海拉鲁大陆上游荡。 继续刷关于自我内省和 BBC 关于自然方面的记录片，上半年又刷了一遍人生七年和浮生一日。不得不吐槽人生七年真是太长了，刷一遍耗费好多天 &gt;_&lt;! 自律 生活工作的事务渐渐杂乱繁多起来，做一件事的时候常常被其他事打断，对不能持续专注做一件事感到十分困扰。于是开始学习使用番茄工作法，尝试了几种 GTD 工具，始终在手机和电脑的使用连贯性上没有个好的解决方案。目前还是 mac 上使用番茄土豆，手机上用极简待办。每天都努力尝试去完成几个番茄，自律的效果还是不错。（虽然大多数的时候一天也完不成几个番茄 :(） 2018年对自我的认知更加深刻，找到了潜藏在自己内心深处的不安全感，恐惧感、挫败感与自卑感。意识到自己在面对生活中的失败与挫折时潜意识将自己置于受害者的角色之中，而不是拯救者。意识到这一现象后，也开始努力让自己朝拯救者的身份转变。 继续坚持着写笔记的习惯，今天看着一年的点点滴滴，十分感触，让今年的总结工作也轻松了不少，对自己的剖析也更深入到位了。 史蒂芬-卡普曼的 戏剧三角形 模型： 家庭在十八线家乡小城买人生第一套房后。每月面临近5000贷款和3000房租，压的近乎喘不过气。 展望 2019工作上坚持不同的角度思考问题，坚持阅读框架源码，明年加大技术上的输入和输出。 生活上阅读明年计划阅读的书单： 技术方面： 设计模式之禅、 iOS 逆向与安全、iOS 性能优化、网络是怎样连接的、计算机是怎样跑起来的。 非技术方面： 永恒的边缘、拖延心理学、自控力、乌合之众、原则、非暴力沟通、资中筠自选集、人月神话、影响力、上帝掷骰子吗。 视野上半年时跟公司申请了带欢欢泰国游，最后也没得到批准。今年计划带欢欢出去玩一次。 附信附上母校孟老师的一封信，勉励自己的同时，也希望给大家一份启迪。 《来自聊城大学计算机学院孟之天老师的第四封信》时间过的真快，又到该给大家写信的时候了。迟迟没有动笔，因为不确定应该讲什么。估计很多同学经过在职场的打拼，最近遇到了事业上的瓶颈期。另外，你的心态大概也和你刚步入社会的时候相去甚远了。那就讲讲这两件事儿。如何突破事业上的瓶颈。如何保持好的心态。瓶颈期瓶颈期其实来自于稳定的环境：工作，生活，朋友圈，人脉资源。但是，社会的发展是不可逆的。人工智能很快会逐渐颠覆四平八稳的生活。一切变得越来越难以预期。所以，如果你选择在大城市。其实不进步，就是退步。我作为教师，也有危机感。未来的教学模式一定会逐步改变，网络课程会越来越多，教师只负责答疑，以及组织学生的学习流程。技术进步，会改变很多我们熟悉的行业。或许未来不需要公交司机。或许将来会实现无人物流配送。手机会消失，取而代之的是智能穿戴设备。或许未来代码可以由人工智能自动生成，留给人的工作是对代码的优化。可以想象的空间太大了。唯一不变的就是：我们需要不停的学习，而不能满足于现状。我能想到的办法也并不高明，大概有以下三点。进修、旅游、换环境。进修可以是提升学历的进修。可以是提升业务的进修，也可以是为积累人脉而进修。不管哪一种方式，都可以打破你目前的稳定生活，进而有可能突破瓶颈。旅游，不同的城市有不同的气质。北京很大，人才济济，但也不适合生存。深圳是全中国最生机勃勃的城市。上海是最规范也最虚荣的城市。广州是最适合人类居住的城市。旅游，到处走走看看，可以让你看到各种人的活法。有助于你改变现有的生活惯性。换环境，这包括换工作。如果你不能一步到位，可以试试中间地带。用两连跳，或三连跳来完成。如果不能换工作，在一个组织内部，也可以寻求纵向或横向的流动性。如果你在一个小型创业公司，你可以要求成为合伙人，我个人认为这比要求加薪，可以获得更大的发展空间。如果你在一个大中型公司或企业，那么应该尝试是否有晋升机会。凡事多向领导汇报，争取成为心腹，获得晋升机会。如果不能纵向提升，那么可以争取横向流动的机会，去不同的部门锻炼，获得相应的工作经验。那么未来在同等条件下，有更多晋升机会的是你。我们有很多同学在北京工作，我个人认为，到27/8岁的时候应该考虑去留的问题了。北京很好，但北京很贵。据我的观察，在其他城市一样可以活的幸福。婚姻和家庭比事业更重要。在北京有高薪，但北京给不了你一个可以安居的家。最后，聊聊一个有些沉重的话题。保留你内心的净土现在的你和刚出校门的你，是否早已天壤之别。走入社会，我们不得不学会八面玲珑，圆滑的为人处世。学会说冠冕堂皇，言不由衷的套话。学会见人说人话，见鬼说鬼话。学会了自我保护，不能无底线的善良。更有可能你要说服自己去做不违法，但违背良知的事情。这些事情可能让你不安。但这些其实只是生存之道，我们人人都得会。你不必为此感到焦虑和不安。只有当你做，并认同你做的事。说，并认同了你说的话。甚至用这些去教导的下属和后代的时候，你才应该真正的感到不安。我们可以迫于现实的压力做这些事儿，说这些话。但在内心我们可以高傲的拒绝。你有权力在内心留有一块净土，它神圣不可侵犯。就把这些留给职场吧。我们至少要保护好我们的孩子，家人，远离这些。如果你没听懂，可以去看一个经典黑帮电影《教父》。办法也很简单：读书、旅行；除了工作关系的圈子，你更需要一个和工作完全无关的朋友圈。不管你在职场需要如何作为，那不是真正的你。转个身，关闭职场的门。你依然是你，保留内心的净土，保持做梦的能力，保护好家人。]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发中的设计模式下]]></title>
    <url>%2F2018%2F12%2F17%2FiOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8B.html</url>
    <content type="text"><![CDATA[在这个由两部分组成的教程中，你将了解构建 iOS 应用程序的常见设计模式，以及如何在自己的应用程序中应用这些模式。 更新说明：本教程已由译者针对 iOS 12，Xcode 10 和 Swift 4.2 进行了更新。原帖由教程团队成员 Eli Ganem 发布。 欢迎回到 iOS 设计模式的入门教程第二部分！在 第一部分 中，你已经了解了 Cocoa 中的一些基本模式，比如 MVC、单例和装饰模式。 在最后一部分中，你将了解 iOS 和 OS X 开发中出现的其他基本设计模式：适配器、观察者和备忘录。让我们现在就开始吧！ 入门你可以下载 第一部分最结尾处的项目 来开始。 这是你在第一部分结尾处留下的音乐库应用程序： 该应用程序的原计划包括了屏幕顶部用来在专辑之间切换的 scrollView。但是与其编写一个只有单个用途的 scrollView，为何不让它变得可以给其他任何 view 复用呢？ 要使此 scrollView 可复用，跟其内容有关的所有决策都应留给其他两个对象：它的数据源和代理。为了使用 scrollView，应该给它声明数据源和代理实现的方法，这就类似于 UITableView 的代理方法工作方式。当我们接下来一边讨论下一个设计模式时，你也将一边着手实现它。 适配器模式适配器允许和具有不兼容接口的类一起工作，它将自身包裹在一个对象内，并公开一个标准接口来与该对象进行交互。 如果你熟悉适配器模式，那么你会注意到 Apple 以一种稍微不同的方式实现它，那就是协议。你可能熟悉 UITableViewDelegate，UIScrollViewDelegate，NSCoding 和 NSCopying 等协议。例如使用 NSCopying 协议，任何类都可以提供一个标准的 copy 方法。 如何使用适配器模式之前提到的 scrollView 如下图所示： 我们现在来实现它吧，右击项目导航栏中的 View 组，选择 New File &gt; iOS &gt; Cocoa Touch Class，然后单击 Next，将类名设置为 HorizontalScrollerView 并继承自 UIView。 打开 HorizontalScrollerView.swift 并在 HorizontalScroller 类声明的 上方 插入以下代码： 123456protocol HorizontalScrollerViewDataSource: class &#123; // 询问数据源它想要在 scrollView 中显示多少个 view func numberOfViews(in horizontalScrollerView: HorizontalScrollerView) -&gt; Int // 请求数据源返回应该出现在第 index 个的 view func horizontalScrollerView(_ horizontalScrollerView: HorizontalScrollerView, viewAt index: Int) -&gt; UIView&#125; 这定义了一个名为 HorizontalScrollerViewDataSource 的协议，它执行两个操作：请求在 scrollView 内显示 view 的个数以及应为特定索引显示的 view。 在此协议定义的下方再添加另一个名为 HorizontalScrollerViewDelegate 的协议。 1234protocol HorizontalScrollerViewDelegate: class &#123; // 通知代理第 index 个 view 已经被选择 func horizontalScrollerView(_ horizontalScrollerView: HorizontalScrollerView, didSelectViewAt index: Int)&#125; 这将使 scrollView 通知某个其他对象它内部的一个 view 已经被选中。 注意：将关注区域划分为不同的协议会使代码看起来更加清晰。通过这种方式你可以决定遵循特定的协议，并避免使用 @objc 来声明可选的协议方法。 在 HorizontalScrollerView.swift 中，将以下代码添加到 HorizontalScrollerView 类的定义里： 12weak var dataSource: HorizontalScrollerViewDataSource?weak var delegate: HorizontalScrollerViewDelegate? 代理和数据源都是可选项，因此你不一定要给他们赋值，但你在此处设置的任何对象都必须遵循相应的协议。 在类里继续添加以下代码： 123456789101112// 1private enum ViewConstants &#123; static let Padding: CGFloat = 10 static let Dimensions: CGFloat = 100 static let Offset: CGFloat = 100&#125;// 2private let scroller = UIScrollView()// 3private var contentViews = [UIView]() 每条注释的详解如下： 定义一个私有的 enum 来使代码布局在设计时更易修改。scrollView 的内的 view 尺寸为 100 x 100，padding 为 10 创建包含多个 view 的 scrollView 创建一个包含所有专辑封面的数组 接下来你需要实现初始化器。添加以下方法： 1234567891011121314151617181920212223242526272829override init(frame: CGRect) &#123; super.init(frame: frame) initializeScrollView()&#125;required init?(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder) initializeScrollView()&#125;func initializeScrollView() &#123; // 1 addSubview(scroller) // 2 scroller.translatesAutoresizingMaskIntoConstraints = false // 3 NSLayoutConstraint.activate([ scroller.leadingAnchor.constraint(equalTo: self.leadingAnchor), scroller.trailingAnchor.constraint(equalTo: self.trailingAnchor), scroller.topAnchor.constraint(equalTo: self.topAnchor), scroller.bottomAnchor.constraint(equalTo: self.bottomAnchor) ]) // 4 let tapRecognizer = UITapGestureRecognizer(target: self, action: #selector(scrollerTapped(gesture:))) scroller.addGestureRecognizer(tapRecognizer)&#125; 这项工作是在 initializeScrollView() 中完成的。以下是详细分析： 添加子视图 UIScrollView 实例 关闭 autoresizingMask，这样你就可以使用自定义约束了 将约束应用于 scrollView，你希望 scrollView 完全填充 HorizontalScrollerView 创建 tap 手势。它会检测 scrollView 上的触摸事件并检查是否已经点击了专辑封面。如果是，它将通知 HorizontalScrollerView 的代理。在这里会有一个编译错误，因为 scrollerTapped(gesture:) 方法尚未实现，你接下来就要实现它了。 现在添加下面的方法： 123456func scrollToView(at index: Int, animated: Bool = true) &#123; let centralView = contentViews[index] let targetCenter = centralView.center let targetOffsetX = targetCenter.x - (scroller.bounds.width / 2) scroller.setContentOffset(CGPoint(x: targetOffsetX, y: 0), animated: animated)&#125; 此方法检索特定索引的 view 并使其居中。它将由以下方法调用（你也需要将此方法添加到类中）： 123456789@objc func scrollerTapped(gesture: UITapGestureRecognizer) &#123; let location = gesture.location(in: scroller) guard let index = contentViews.index(where: &#123; $0.frame.contains(location)&#125;) else &#123; return &#125; delegate?.horizontalScrollerView(self, didSelectViewAt: index) scrollToView(at: index)&#125; 此方法在 scrollView 中寻找点击的位置，如果存在的话它会查找包含该位置的第一个 contentView 的索引。 如果点击了 contentView，则通知代理并将此 view 滚动到中心位置。 接下来添加以下内容以从滚动器访问专辑封面： 123func view(at index :Int) -&gt; UIView &#123; return contentViews[index]&#125; view(at:) 只返回特定索引处的 view，稍后你将使用此方法突出显示你已点击的专辑封面。 现在添加以下代码来刷新 scrollView： 12345678910111213141516171819202122232425func reload() &#123; // 1. 检查是否有数据源，如果没有则返回。 guard let dataSource = dataSource else &#123; return &#125; // 2. 删除所有旧的 contentView contentViews.forEach &#123; $0.removeFromSuperview() &#125; // 3. xValue 是 scrollView 内每个 view 的起点 x 坐标 var xValue = ViewConstants.Offset // 4. 获取并添加新的 View contentViews = (0..&lt;dataSource.numberOfViews(in: self)).map &#123; index in // 5. 在正确的位置添加 View xValue += ViewConstants.Padding let view = dataSource.horizontalScrollerView(self, viewAt: index) view.frame = CGRect(x: xValue, y: ViewConstants.Padding, width: ViewConstants.Dimensions, height: ViewConstants.Dimensions) scroller.addSubview(view) xValue += ViewConstants.Dimensions + ViewConstants.Padding return view &#125; // 6 scroller.contentSize = CGSize(width: xValue + ViewConstants.Offset, height: frame.size.height)&#125; UITableView 中的 reload 方法会在 reloadData 之后建模，它将重新加载用于构造 scrollView 的所有数据。 每条注释对应的详解如下： 在执行任何 reload 之前检查数据源是否存在。 由于你要清除专辑封面，因此你还需要移除所有存在的 view。 所有 view 都从给定的偏移量开始定位。目前它是 100，但可以通过更改文件顶部的常量 ViewConstants.Offset 来轻松地做出调整。 向数据源请求 view 的个数，然后使用它来创建新的 contentView 数组。 HorizontalScrollerView 一次向一个 view 请求其数据源，并使用先前定义的填充将它们水平依次布局。 所有 view 布局好之后，设置 scrollView 的偏移量来允许用户滚动浏览所有专辑封面。 当你的数据发生改变时调用 reload 方法。 HorizontalScrollerView 需要实现的最后一个功能是确保你正在查看的专辑始终位于 scrollView 的中心。为此，当用户用手指拖动 scrollView 时，你需要执行一些计算。 下面添加以下方法： 123456789101112131415private func centerCurrentView() &#123; let centerRect = CGRect( origin: CGPoint(x: scroller.bounds.midX - ViewConstants.Padding, y: 0), size: CGSize(width: ViewConstants.Padding, height: bounds.height) ) guard let selectedIndex = contentViews.index(where: &#123; $0.frame.intersects(centerRect) &#125;) else &#123; return &#125; let centralView = contentViews[selectedIndex] let targetCenter = centralView.center let targetOffsetX = targetCenter.x - (scroller.bounds.width / 2) scroller.setContentOffset(CGPoint(x: targetOffsetX, y: 0), animated: true) delegate?.horizontalScrollerView(self, didSelectViewAt: selectedIndex)&#125; 上面的代码考虑了 scrollView 的当前偏移量以及 view 的尺寸和填充以便计算当前view 与中心的距离。最后一行很重要：一旦 view 居中，就通知代理所选的 view 已变更。 要检测用户是否在 scrollView 内完成了拖动，你需要实现一些 UIScrollViewDelegate 的方法，将以下类扩展添加到文件的底部。记住一定要在主类声明的花括号 下面 添加！ 1234567891011extension HorizontalScrollerView: UIScrollViewDelegate &#123; func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) &#123; if !decelerate &#123; centerCurrentView() &#125; &#125; func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) &#123; centerCurrentView() &#125;&#125; scrollViewDidEndDragging(_:willDecelerate:) 在用户完成拖拽时通知代理，如果 scrollView 尚未完全停止，则 decelerate 为 true。当滚动结束时，系统调用scrollViewDidEndDecelerating(_:)。在这两种情况下，你都应该调用新方法使当前视图居中，因为当用户拖动滚动视图后当前视图可能已更改。 最后不要忘记设置代理，将以下代码添加到 initializeScrollView() 的最开头： 1scroller.delegate = self 你的 HorizontalScrollerView 已准备就绪！看一下你刚刚编写的代码，你会看到没有任何地方有出现 Album 或 AlbumView 类。这非常棒，因为这意味着新的 scrollView 真正实现了解耦并且可复用。 编译项目确保可以正常通过编译。 现在 HorizontalScrollerView 已经完成，是时候在你的应用程序中使用它了。首先打开 Main.storyboard。单击顶部的灰色矩形视图，然后单击 Identity Inspector。将类名更改为 HorizontalScrollerView，如下图所示： 接下来打开 Assistant Editor 并从灰色矩形 view 拖线到 ViewController.swift 来创建一个 IBOutlet，并命名为 horizontalScrollerView，如下图所示： 接下来打开 ViewController.swift，是时候开始实现一些 HorizontalScrollerViewDelegate 方法了！ 把下面的拓展添加到该文件的最底部： 1234567891011121314extension ViewController: HorizontalScrollerViewDelegate &#123; func horizontalScrollerView(** horizontalScrollerView: HorizontalScrollerView, didSelectViewAt index: Int) &#123; // 1 let previousAlbumView = horizontalScrollerView.view(at: currentAlbumIndex) as! AlbumView previousAlbumView.highlightAlbum(false) // 2 currentAlbumIndex = index // 3 let albumView = horizontalScrollerView.view(at: currentAlbumIndex) as! AlbumView albumView.highlightAlbum(true) // 4 showDataForAlbum(at: index) &#125;&#125; 这是在调用此代理方法时发生的事情： 首先你取到之前选择的专辑，然后取消选择专辑封面 存储刚刚点击的当前专辑封面的索引 取得当前所选的专辑封面并显示高亮状态 在 tableView 中显示新专辑的数据 接下来，是时候实现 HorizontalScrollerViewDataSource 了。在当前文件末尾添加以下代码： 12345678910111213141516extension ViewController: HorizontalScrollerViewDataSource &#123; func numberOfViews(in horizontalScrollerView: HorizontalScrollerView) -&gt; Int &#123; return allAlbums.count &#125; func horizontalScrollerView(_ horizontalScrollerView: HorizontalScrollerView, viewAt index: Int) -&gt; UIView &#123; let album = allAlbums[index] let albumView = AlbumView(frame: CGRect(x: 0, y: 0, width: 100, height: 100), coverUrl: album.coverUrl) if currentAlbumIndex == index &#123; albumView.highlightAlbum(true) &#125; else &#123; albumView.highlightAlbum(false) &#125; return albumView &#125;&#125; 正如你所看到的，numberOfViews(in:) 是返回 scrollView 中 view 的个数的协议方法。由于 scrollView 将显示所有专辑数据的封面，因此 count 就是专辑记录的数量。在 horizontalScrollerView(_:viewAt:) 里你创建一个新的 AlbumView，如果它是所选的专辑，则高亮显示它，再将它传递给 HorizontalScrollerView。 基本完成了！只用三个简短的方法就能显示出一个漂亮的 scrollView。你现在需要设置数据源和代理。在 viewDidLoad 中的 showDataForAlbum(at:) 之前添加以下代码： 123horizontalScrollerView.dataSource = selfhorizontalScrollerView.delegate = selfhorizontalScrollerView.reload() 编译并运行你的项目，就可以看到漂亮的水平滚动视图： 呃，等一下！水平滚动视图已就位，但专辑的封面在哪里呢？ 噢，对了，你还没有实现下载封面的代码。为此，你需要添加下载图像的方法，而且你对服务器的全部访问请求都要通过一个所有新方法必经的一层 LibraryAPI。但是，首先要考虑以下几点： AlbumView 不应直接与 LibraryAPI 产生联系，你不会希望将 view 里的逻辑与网络请求混合在一起的。 出于同样的原因，LibraryAPI 也不应该知道 AlbumView 的存在。 当封面被下载完成，LibraryAPI 需要通知 AlbumView 来显示专辑。 是不是感觉听起来好像很难的样子？不要绝望，你将学习如何使用 观察者 模式来做到这点！ 观察者模式在观察者模式中，一个对象通知其他对象任何状态的更改，但是通知的涉及对象不需要相互关联，我们鼓励这种解耦的设计方式。这种模式最常用于在一个对象的属性发生更改时通知其他相关对象。 通常的实现是需要观察者监听另一个对象的状态。当状态发生改变时，所有观察对象都会被通知此次更改。 如果你坚持 MVC 的概念（也确实需要坚持），你需要允许 Model 对象与 View 对象进行通信，但是它们之间没有直接引用，这就是观察者模式的用武之地。 Cocoa 以两种方式实现了观察者模式：通知 和 键值监听（KVO）。 通知不要与推送通知或本地通知混淆，观察者模式的通知基于订阅和发布模型，该模型允许对象（发布者）将消息发送到其他对象（订阅者或监听者），而且发布者永远不需要了解有关订阅者的任何信息。 Apple 会大量使用通知。例如，当显示或隐藏键盘时，系统分别发送 UIKeyboardWillShow 和 UIKeyboardWillHide 通知。当你的应用程序转入后台运行时，系统会发送一个 UIApplicationDidEnterBackground 通知。 如何使用通知右击 RWBlueLibrary 并选择 New Group，然后命名为 Extension。再次右击该组，然后选择New File &gt; iOS &gt; Swift File，并将文件名设置为 NotificationExtension.swift。 把下面的代码拷贝到该文件中： 123extension Notification.Name &#123; static let BLDownloadImage = Notification.Name("BLDownloadImageNotification")&#125; 你正在使用自定义通知扩展的 Notification.Name，从现在开始，新的通知可以像系统通知一样用 .BLDownloadImage 访问。 打开 AlbumView.swift 并将以下代码插入到 init(frame:coverUrl:) 方法的最后： 1NotificationCenter.default.post(name: .BLDownloadImage, object: self, userInfo: ["imageView": coverImageView, "coverUrl" : coverUrl]) 该行代码通过 NotificationCenter 的单例发送通知，通知信息包含要填充的 UIImageView 和要下载的专辑图像的 URL，这些是执行封面下载任务所需的所有信息。 将以下代码添加到 LibraryAPI.swift中的 init 方法来作为当前为空的初始化方法的实现： 1NotificationCenter.default.addObserver(self, selector: #selector(downloadImage(with:)), name: .BLDownloadImage, object: nil) 这是通知这个等式的另一边–观察者，每次 AlbumView 发送 BLDownloadImage 通知时，由于 LibraryAPI 已注册成为该通知的观察者，系统会通知 LibraryAPI，然后 LibraryAPI 响应并调用 downloadImage(with:)。 在实现 downloadImage(with:) 之前，还有一件事要做。在本地保存下载的封面可能是个好主意，这样应用程序就不需要一遍又一遍地下载相同的封面了。 打开 PersistencyManager.swift，把 import Foundation 换成下面的代码： 1import UIKit 此次 import 很重要，因为你将处理 UI 对象，比如 UIImage。 把这个计算属性添加到该类的最后： 123private var cache: URL &#123; return FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask)[0]&#125; 此变量返回缓存目录的 URL，它是一个存储了你可以随时重新下载的文件的好地方。 现在添加以下两个方法： 123456789101112131415func saveImage(_ image: UIImage, filename: String) &#123; let url = cache.appendingPathComponent(filename) guard let data = UIImagePNGRepresentation(image) else &#123; return &#125; try? data.write(to: url)&#125;func getImage(with filename: String) -&gt; UIImage? &#123; let url = cache.appendingPathComponent(filename) guard let data = try? Data(contentsOf: url) else &#123; return nil &#125; return UIImage(data: data)&#125; 这段代码非常简单，下载的图像将保存在 Cache 目录中，如果在 Cache 目录中找不到匹配的文件，getImage(with:) 将返回 nil。 现在打开 LibraryAPI.swift 并且将 import Foundation 改为 import UIKit。 在类的最后添加以下方法： 123456789101112131415161718192021@objc func downloadImage(with notification: Notification) &#123; guard let userInfo = notification.userInfo, let imageView = userInfo["imageView"] as? UIImageView, let coverUrl = userInfo["coverUrl"] as? String, let filename = URL(string: coverUrl)?.lastPathComponent else &#123; return &#125; if let savedImage = persistencyManager.getImage(with: filename) &#123; imageView.image = savedImage return &#125; DispatchQueue.global().async &#123; let downloadedImage = self.httpClient.downloadImage(coverUrl) ?? UIImage() DispatchQueue.main.async &#123; imageView.image = downloadedImage self.persistencyManager.saveImage(downloadedImage, filename: filename) &#125; &#125;&#125; 以下是上面两个方法的详解： downloadImage 是通过通知触发调用的，因此该方法接收通知对象作为参数。从通知传递来的对象取出 UIImageView 和 image 的 URL。 如果先前已下载过，则从 PersistencyManager 中检索 image。 如果尚未下载图像，则使用 HTTPClient 检索。 下载完成后，在 imageView 中显示图像，并使用 PersistencyManager 将其保存在本地。 再一次的，你使用外观模式隐藏了从其他类下载图像这一复杂的过程。通知发送者并不关心图像是来自网络下载还是来自本地的存储。 编译并运行你的应用程序，现在能看到 collectionView 中漂亮的封面： 停止你的应用并再次运行它。请注意加载封面没有延迟，这是因为它们已在本地保存了。你甚至可以断开与互联网的连接，应用程序仍将完美运行。然而这里有一个奇怪的地方，旋转加载的动画永远不会停止！这是怎么回事？ 你在下载图像时开始了旋转动画，但是在下载图像后，你并没有实现停止加载动画的逻辑。你 本应该 在每次下载图像时发送通知，但是下面你将使用键值监听（KVO）来执行此操作。 键值监听（KVO）在 KVO 中，对象可以监听一个特定属性的任何更改，要么是自己的属性，要么就是另一个对象的。如果你有兴趣，可以阅读 KVO 开发文档 中的更多关信息。 如何使用键值监听如上所述，键值监听机制允许对象观察属性的变化。在你的案例中，你可以使用键值监听来监听显示图片的 UIImageView 里 image 属性的更改。 打开 AlbumView.swift 并在 private var indicatorView: UIActivityIndicatorView! 的声明下面添加以下属性： 1private var valueObservation: NSKeyValueObservation! 在添加封面的 imageView 做为子视图之前，将以下代码添加到commonInit： 12345valueObservation = coverImageView.observe(\.image, options: [.new]) &#123; [unowned self] observed, change in if change.newValue is UIImage &#123; self.indicatorView.stopAnimating() &#125;&#125; 这段代码将 imageView 做为封面图片的 image 属性的观察者。\.image 是一个启用此功能的 keyPath 表达式。 在 Swift 4 中，keyPath 表达式具有以下形式： 1\&lt;type&gt;.&lt;property&gt;.&lt;subproperty&gt; type 通常可以由编译器推断，但至少需要提供一个 property。在某些情况下，使用属性的属性可能是有意义的。在你现在的情况下，我们已指定属性名称 image，而省略了类型名称 UIImageView。 尾随闭包指定了在每次观察到的属性更改时执行的闭包。在上面的代码中，当 image 属性更改时，你要停止加载的旋转动画。这样做了之后，当图片加载完成，旋转动画就会停止。 编译并运行你的项目，加载中的旋转动画将会消失： 注意： 要始终记得在它们被销毁时删除你的观察者，否则当对象试图向这些不存在的观察者发送消息时，你的应用程序将崩溃！在这种情况下，当专辑视图被移除，valueObservation 将被销毁，因此监听将会停止。 如果你稍微使用一下你的应用然后就终止它，你会注意到你的应用状态并未保存。应用程序启动时，你查看的最后一张专辑将不是默认专辑。 要更正此问题，你可以使用之前列表中接下来的一个模式：备忘录。 备忘录模式备忘录模式捕获并使对象的内部状态暴露出来。换句话讲，它可以在某处保存你的东西，稍后在不违反封装的原则下恢复此对外暴露的状态。也就是说，私有数据仍然是私有的。 如何使用备忘录模式iOS 使用备忘录模式作为 状态恢复 的一部分。你可以通过阅读我们的 教程 来了解更多信息，但实质上它会存储并重新应用你的应用程序状态，以便用户回到上次操作的状态。 要在应用程序中激活状态恢复，请打开 Main.storyboard，选择 Navigation Controller，然后在 Identity Inspector 中找到 Restoration ID 字段并输入 NavigationController。 选择 Pop Music scene 并在刚才的位置输入 ViewController。这些 ID 会告诉系统，当应用重新启动时，你想要恢复这些 viewController 的状态。 在 AppDelegate.swift 中添加以下代码： 1234567func application(_ application: UIApplication, shouldSaveApplicationState coder: NSCoder) -&gt; Bool &#123; return true&#125;func application(_ application: UIApplication, shouldRestoreApplicationState coder: NSCoder) -&gt; Bool &#123; return true&#125; 以下的代码会为你的应用程序打开状态作为一个整体来还原。现在，将以下代码添加到 ViewController.swift 中的 Constants 枚举中： 1static let IndexRestorationKey = "currentAlbumIndex" 这个静态常量将用于保存和恢复当前专辑的索引，现在添加以下代码： 1234567891011override func encodeRestorableState(with coder: NSCoder) &#123; coder.encode(currentAlbumIndex, forKey: Constants.IndexRestorationKey) super.encodeRestorableState(with: coder)&#125;override func decodeRestorableState(with coder: NSCoder) &#123; super.decodeRestorableState(with: coder) currentAlbumIndex = coder.decodeInteger(forKey: Constants.IndexRestorationKey) showDataForAlbum(at: currentAlbumIndex) horizontalScrollerView.reload()&#125; 你将在这里保存索引（该操作在应用程序进入后台时进行）并恢复它（该操作在应用程序启动时加载完成 controller 中的 view 后进行）。还原索引后，更新 tableView 和 scrollView 以显示更新之后的选中状态。还有一件事要做，那就是你需要将 scrollView 滚动到正确的位置。如果你在此处滚动 scrollView，这样是行不通的，因为 view 尚未布局完毕。下面请在正确的地方添加代码让 scrollView 滚动到对应的 view： 1234override func viewDidAppear(_ animated: Bool) &#123; super.viewDidAppear(animated) horizontalScrollerView.scrollToView(at: currentAlbumIndex, animated: false)&#125; 编译并运行你的应用程序，点击其中一个专辑，然后按一下 Home 键使应用程序进入后台（如果你在模拟器上运行，则也可以按下 Command+Shift+H），再从 Xcode 上停止运行你的应用程序并重新启动，看一下之前选择的专辑是否到了中间的位置： 请看一下 PersistencyManager 中的 init 方法，你会注意到每次创建 PersistencyManager 时都会对专辑数据进行硬编码并重新创建。但其实更好的解决方案是一次性创建好专辑列表并将其存储在文件中。那你该如何将 Album 的数据保存到文件中呢？ 方案之一是遍历 Album 的属性并将它们保存到 plist 文件，然后在需要时重新创建 Album 实例，但这并不是最佳的，因为它要求你根据每个类中的数据或属性编写特定代码，如果你以后创建了具有不同属性的 Movie 类，则保存和加载该数据都将需要重写新的代码。 此外，你将无法为每个类实例保存私有变量，因为外部类并不难访问它们，这就是为什么 Apple 要创建 归档和序列化 机制。 归档和序列化Apple 的备忘录模式的一个专门实现方法是通过归档和序列化。在 Swift 4 之前，为了序列化和保存你的自定义类型，你必须经过许多步骤。对于 类 来说，你需要继承自 NSObject 并遵行 NSCoding 协议。 但是像 结构体 和 枚举 这样的值类型就需要一个可以扩展 NSObject 并遵行 NSCoding 的子对象了。 Swift 4 为 类，结构体 和 枚举 这三种类型解决了这个问题：[SE-0166]。 如何使用归档和序列化打开 Album.swift 并让 Album 遵行 Codable。这个协议可以让 Swift 中的类同时遵行 Encodable 和 Decodable。如果所有属性都是可 Codable 的，则协议的实现由编译器自动生成。 你的代码现在看起来会像这样： 1234567struct Album: Codable &#123; let title : String let artist : String let genre : String let coverUrl : String let year : String&#125; 要对对象进行编码，你需要使用 encoder。打开 PersistencyManager.swift 并添加以下代码： 12345678910111213141516private var documents: URL &#123; return FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]&#125;private enum Filenames &#123; static let Albums = "albums.json"&#125;func saveAlbums() &#123; let url = documents.appendingPathComponent(Filenames.Albums) let encoder = JSONEncoder() guard let encodedData = try? encoder.encode(albums) else &#123; return &#125; try? encodedData.write(to: url)&#125; 就像使用 caches 一样，你将在此定义一个 URL 用来保存文件目录，它是一个存储文件名路径的常量，然后就是将你的专辑数据写入文件的方法，事实上你并不用编写很多的代码！ 该方案的另一部分是将数据解码回具体对象。你现在需要替换掉创建专辑并从文件中加载它们的很长一段的那个方法。下载并解压 此JSON文件 并将其添加到你的项目中。 现在用以下代码替换 PersistencyManager.swift 中的 init 方法体： 1234567891011let savedURL = documents.appendingPathComponent(Filenames.Albums)var data = try? Data(contentsOf: savedURL)if data == nil, let bundleURL = Bundle.main.url(forResource: Filenames.Albums, withExtension: nil) &#123; data = try? Data(contentsOf: bundleURL)&#125;if let albumData = data, let decodedAlbums = try? JSONDecoder().decode([Album].self, from: albumData) &#123; albums = decodedAlbums saveAlbums()&#125; 现在你正在从 documents 目录下的文件中加载专辑数据（如果存在的话）。如果它不存在，则从先前添加的启动文件中加载它，然后就立即保存，那么下次启动时它将会位于文档目录中。JSONDecoder 非常智能，你只需告诉它你希望文件包含的类型，它就会为你完成剩下的所有工作！ 你可能还希望每次应用进入后台时保存专辑数据，我将把这一部分作为一个挑战让你亲自弄明白其中的原理，你在这两个教程中学到的一些模式还有技术将会派上用场！ 接下来该干嘛？你可以 在此 下载最终项目。 在本教程中你了解了如何利用 iOS 设计模式的强大功能来以很直接的方式执行复杂的任务。你已经学习了很多 iOS 设计模式和概念：单例，MVC，代理，协议，外观，观察者和备忘录。 你的最终代码将会是耦合度低、可重用并且易读的。如果其他开发者阅读你的代码，他们将能够很轻松地了解每行代码的功能以及每个类在你的应用中的作用。 其中的关键点是不要为你了使用设计模式而使用它。然而在考虑如何解决特定问题时，请留意设计模式，尤其是在设计应用程序的早期阶段。它们将使作为开发者的你生活变得更加轻松，代码同时也会更好！ 关于该文章主题的一本经典书籍是 Design Patterns: Elements of Reusable Object-Oriented Software。有关代码示例，请查看 GitHub 上一个非常棒的项目 Design Patterns: Elements of Reusable Object-Oriented Software 来取更多在 Swift 中编程中的设计模式。 最后请务必查看 Swift 设计模式进阶 和我们的视频课程 iOS Design Patterns 来了解更多设计模式！ 如果发现译文存在错误或其他需要改进的地方，欢迎到 掘金翻译计划 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 本文永久链接 即为本文在 GitHub 上的 MarkDown 链接。 译文出自：掘金翻译计划 译者： iWeslie 校对者： swants]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发中的设计模式上]]></title>
    <url>%2F2018%2F12%2F03%2FiOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8A.html</url>
    <content type="text"><![CDATA[在这个由两部分组成的教程中，你将了解构建 iOS 应用程序的常见设计模式，以及如何在自己的应用程序中应用这些模式。 更新说明：本教程已由译者针对 iOS 12，Xcode 10 和 Swift 4.2 进行了更新。原帖由教程团队成员 Eli Ganem发布。 iOS设计模式 — 你可能已经听过这个术语，但是你知道这意味着什么吗？尽管大多数开发人员可能都认为设计模式非常重要，关于这个主题的文章并不多，我们开发人员在编写代码时有时不会过多地关注设计模式。 设计模式是软件设计中常见问题的可重用解决方案。它们的模板旨在帮助你编写易于理解和重用的代码。它们还可以帮助你创建低耦合度的代码，以便你能更改或替换代码中的组件而避免很多麻烦。 如果你对设计模式不熟悉，那么我有个好消息要告诉你！首先，由于 Cocoa 的架构方式以及它鼓励你使用的最佳实践，你已经使用过了大量的 iOS 设计模式。其次，本教程将快速帮助你理解 Cocoa 中常用的所有重要（还有不那么重要）的 iOS 设计模式。 在这个由两部分组成的教程中，你将创建一个音乐应用程序，用于显示你的专辑及其相关信息。 在开发此应用程序的过程中，你将熟悉最常见的 Cocoa 设计模式： 创建型：单例。 结构型：MVC、装饰、适配器和外观。 行为型：观察者和备忘录。 不要误以为这是一篇关于理论的文章，你将在音乐应用中使用大多数这些设计模式。在本教程结束时，你的应用将如下所示： 让我们开始吧！ 入门下载 入门项目，解压缩 ZIP 文件的内容，并在 Xcode 中打开 RWBlueLibrary.xcodeproj。 请注意项目中的以下内容： 在 storyboard 里，ViewController 有三个 IBOutlet 连接了 TableView，还有撤消和删除按钮按钮。 Storyboard 有 3 个组件，为方便起见我们设置了约束。顶部组件是用来显示专辑封面的。专辑封面下方是一个 TableView，其中列出了与专辑封面相关的信息。 最后，工具栏有两个按钮，一个用于撤消操作，另一个用于删除你选择的专辑。Storyboard 如下所示： 有一个没有实现的初始 HTTP 客户端类（HTTPClient），供你稍后填写。 注意：你知道吗，只要你创建新的 Xcode 项目，就已经充满了设计模式了嘛？模型-视图-控制器，代理，协议，单例 — 这些设计模式都是现成的！ MVC – 设计模式之王 模型 - 视图 - 控制器（MVC）是 Cocoa 的构建模块之一，它无疑是所有设计模式中最常用的。它将应用内对象按照各自常用角色进行分类，并提倡将代码基于角色进行解耦。 这三个角色是： 模型（Model）：Model 是你的应用中持有并定义如何操作数据的对象。例如，在你的应用程序中，模型是 Album 结构体，你可以在 Album.swift 中找到它。大多数应用程序将具有多个类型作为其模型的一部分。 视图（View）：View 是用来展示 model 的数据并管理可与用户交互的控件的对象，基本上可以说是所有 UIView 派生的对象。 在你的应用程序中，视图是 AlbumView，你可以在 AlbumView.swift 中找到它。 控制器（Controller）：控制器是协调所有工作的中介。它访问模型中的数据并将其与视图一起显示，监听事件并根据需要操作数据。你能猜出哪个类是你的控制器吗？没错，就是 ViewController。 你的 App 要想规范地使用 MVC 设计模式，就意味着你 App 中每个对象都可以划分为这三个角色其中的某一个。 通过控制器（Controller）可以最好地描述视图（View）到模型（Model）之间的通信，如下图所示： 模型通知控制器任何数据更改，反过来，控制器更新视图中的数据。然后，视图可以向控制器通知用户执行的操作，控制器将在必要时更新模型或检索任何请求的数据。 你可能想知道为什么你不能抛弃控制器，并在同一个类中实现视图和模型，因为这看起来会容易得多。 这一切都将归结为代码分离和可重用性。理想情况下，视图应与模型完全分离。如果视图不依赖于模型的特定实现，那么可以使用不同的模型重用它来呈现其他一些数据。 例如，如果将来你还想将电影或书籍添加到库中，你仍然可以使用相同的 AlbumView 来显示电影和书籍对象。此外，如果你想创建一个与专辑有关的新项目，你可以简单地重用你的 Album 结构体，因为它不依赖于任何视图。这就是MVC的力量！ 如何使用 MVC 设计模式首先，你需要确保项目中的每个类都是Controller、Model 或 View，不要在一个类中组合两个角色的功能。 其次，为了确保你符合这种工作方法，你应该创建三个文件夹来保存你的代码，每个角色一个。 点击 File\New\Group（或者按 Command + Option + N）并把改组名为 Model。重复相同的过程以创建 View 和 Controller 组。 现在将 Album.swift 拖拽到 Model 组。将 AlbumView.swift 拖拽到 View 组，最后将 ViewController.swift 拖拽到 Controller 组。 此时项目结构应如下所示： 如果没有所有这些文件夹，你的项目看起来会好很多。显然，你可以拥有其他组和类，但应用程序的核心将包含在这三个类别中。 现在你的组件已组织完毕，你需要从某个位置获取相册数据。你将创建一个 API 类，在整个代码中使用它来管理数据，这提供了讨论下一个设计模式的机会 — 单例（Singleton）。 单例模式单例设计模式确保给定类只会存在一个实例，并且该实例有一个全局的访问点。它通常使用延迟加载来在第一次需要时创建单个实例。 注意：Apple 使用了很多这个方法。例如：UserDefaults.standard、UIApplication.shared、UIScreen.main 和 FileManager.default 都返回一个单例对象。 你可能想知道为什么你关心的是一个类有不只一个实例。代码和内存不是都很廉价吗？ 在某些情况下，只有一个实例的类才有意义。例如，你的应用程序只有一个实例，设备也只有一个主屏幕，因此你只需要一个实例。再者，采用全局配置处理程序类，他更容易实现对单个共享资源（例如配置文件）的线程安全访问，而不是让许多类可能同时修改配置文件。 你应该注意什么？ 注意事项：这种模式有被初学者和有经验的开发着滥用（或误用）的历史，因此我们将 Joshua Greene 的 Design Patterns by Tutorials 一书中的一段简述摘录至此，其中解释了使用这种模式的一些需要注意的事项。 单例模式很容易被滥用。 如果你遇到一种想要使用单例的情况，请首先考虑是否还有其他的方法来完成你的任务。 例如，如果你只是尝试将信息从一个视图控制器传递到另一个视图控制器，则不适合使用单例。但是你可以考虑通过初始化程序或属性传递该模型。 如果你确定你确实需要一个单例，那么考虑拓展单例是否会更有意义。 有多个实例会导致问题吗？自定义实例会有用吗？你的答案将决定你是否更好地使用真正的单例或其拓展。 用单例时遇到问题的最常见的原因是测试。如果你将状态存储在像单例这样的全局对象中，则测试顺序可能很重要，并且模拟它们会很烦人。这两个原因都会使测试成为一种痛苦。 最后，要注意“代码异味”，它表明你的用例根本不适合使用单例。例如，如果你经常需要许多自定义实例，那么你的用例可能会更好地作为常规对象。 如何使用单例模式为了确保你的单例只有一个实例，你必须让其他任何人都无法创建实例。Swift 允许你通过将初始化方法标记为私有来完成此操作，然后你可以为共享实例添加静态属性，该属性在类中初始化。 你将通过创建一个单例来管理所有专辑数据从而实现此模式。 你会注意到项目中有一个名为 API 的组，这是你将所有将为你的应用程序提供服务的类的地方。右键单击该组并选择 New File，在该组中创建一个新文件，选择 iOS &gt; Swift File。将文件名设置为 LibraryAPI.swift，然后单击 Create。 现在打开 LibraryAPI.swift 并插入代码： 12345678final class LibraryAPI &#123; // 1 static let shared = LibraryAPI() // 2 private init() &#123; &#125;&#125; 以下是详细分析： 其中 shared 声明的常量使得其他对象可以访问到单例对象 LibraryAPI。 私有的初始化方法防止从外部创建 LibraryAPI 的新实例。 你现在有一个单例对象作为管理专辑的入口。接下来创建一个类来持久化库里的数据。 现在在 API 组里创建一个新文件。 选择 iOS &gt; Swift File。将类名设置为 PersistencyManager.swift，然后单击 Create。 打开 PersistencyManager.swift 并添加以下代码： 123final class PersistencyManager &#123;&#125; 在括号里面添加以下代码： 1private var albums = [Album]() 在这里，你声明一个私有属性来保存专辑数据。该数组将是可变的，因此你可以轻松添加和删除专辑。 现在将以下初始化方法添加到类中： 12345678910111213141516171819202122232425262728293031323334init() &#123; //Dummy list of albums let album1 = Album(title: "Best of Bowie", artist: "David Bowie", genre: "Pop", coverUrl: "https://s3.amazonaws.com/CoverProject/album/album_david_bowie_best_of_bowie.png", year: "1992") let album2 = Album(title: "It's My Life", artist: "No Doubt", genre: "Pop", coverUrl: "https://s3.amazonaws.com/CoverProject/album/album_no_doubt_its_my_life_bathwater.png", year: "2003") let album3 = Album(title: "Nothing Like The Sun", artist: "Sting", genre: "Pop", coverUrl: "https://s3.amazonaws.com/CoverProject/album/album_sting_nothing_like_the_sun.png", year: "1999") let album4 = Album(title: "Staring at the Sun", artist: "U2", genre: "Pop", coverUrl: "https://s3.amazonaws.com/CoverProject/album/album_u2_staring_at_the_sun.png", year: "2000") let album5 = Album(title: "American Pie", artist: "Madonna", genre: "Pop", coverUrl: "https://s3.amazonaws.com/CoverProject/album/album_madonna_american_pie.png", year: "2000") albums = [album1, album2, album3, album4, album5]&#125; 在初始化程序中，你将使用五个示例专辑填充数组。如果上述专辑不符合你的喜好，可以随便使用你喜欢的音乐替换它们。 现在将以下函数添加到类中： 123456789101112131415func getAlbums() -&gt; [Album] &#123; return albums&#125;func addAlbum(_ album: Album, at index: Int) &#123; if albums.count &gt;= index &#123; albums.insert(album, at: index) &#125; else &#123; albums.append(album) &#125;&#125;func deleteAlbum(at index: Int) &#123; albums.remove(at: index)&#125; 这些方法允许你获取，添加和删除专辑。 编译你的项目，确保所有内容能正确地通过编译。 此时，你可能想知道 PersistencyManager 类的位置，因为它不是单例。你将在下一节中看到 LibraryAPI 和 PersistencyManager 之间的关系，你将在其中查看 外观（Facade） 设计模式。 外观模式外观设计模式为复杂子系统提供了单一界面。你只需公开一个简单的统一 API，而不是将用户暴露给一组类及其 API。 下图说明了这个概念： API 的用户完全不知道它其中的复杂性。这种模式在大量使用比较复杂或难理解的类时是比较理想的。 外观模式将使用系统接口的代码与你隐藏的类的实现进行解耦，它还减少了外部代码对子系统内部工作的依赖性。 如果外观下的类可能会更改，那这仍然很有用，因为外观类可以在幕后发生更改时保留相同的 API。 举个例子，如果你想要替换后端服务，那么你不必更改使用 API 的代码，只需更改外观类中的代码即可。 如何使用外观模式目前，你拥有 PersistencyManager 在本地保存专辑数据，并使用 HTTPClient 来处理远程通信。项目中的其他类不应该涉及这个逻辑，因为它们将隐藏在 LibraryAPI 的外观后面。 要实现此模式，只有 LibraryAPI 应该包含 PersistencyManager 和 HTTPClient 的实例。其次，LibraryAPI 将公开一个简单的 API 来访问这些服务。 设计如下所示： LibraryAPI 将暴露给其他代码，但会隐藏应用程序其余部分的 HTTPClient 和 PersistencyManager 复杂性。 打开 LibraryAPI.swift 并将以下常量属性添加到类中： 123private let persistencyManager = PersistencyManager()private let httpClient = HTTPClient()private let isOnline = false isOnline 决定了是否应使用对专辑列表所做的任何更改来更新服务器，例如添加或删除专辑。实际上 HTTP 客户端并不是与真实服务器工作，仅用于演示外观模式的用法，因此 isOnline 将始终为 false。 接下来，将以下三个方法添加到 LibraryAPI.swift： 1234567891011121314151617func getAlbums() -&gt; [Album] &#123; return persistencyManager.getAlbums()&#125;func addAlbum(_ album: Album, at index: Int) &#123; persistencyManager.addAlbum(album, at: index) if isOnline &#123; httpClient.postRequest("/api/addAlbum", body: album.description) &#125;&#125;func deleteAlbum(at index: Int) &#123; persistencyManager.deleteAlbum(at: index) if isOnline &#123; httpClient.postRequest("/api/deleteAlbum", body: "\(index)") &#125;&#125; 我们来看看 addAlbum(_:at:)。该类首先在本地更新数据，然后如果网络有连接，则更新远程服务器。这是外观模式的核心优势，当你要编写 Album 之外的某个类添加一个新专辑时，它不知道，也不需要知道类背后的复杂性。 注意：在为子系统中的类设计外观时，请记住，除非你正在构建单独的模块并使用访问控制，否则不会阻止客户端直接访问这些“隐藏”的类。不要吝啬访问控制的代码，也不要假设所有客户端都必须使用那些与外观使用它们方法相同的类。 编译并运行你的应用程序。你将看到两个空视图和一个工具栏。顶部的 View 将用于显示你的专辑封面，底部 View 将用于显示与该专辑相关的信息列表。 你需要一些东西能在屏幕上显示专辑的数据，这是你下一个设计模式的完美实践：装饰（Decorator）。 装饰模式装饰模式动态地向对象添加行为和职责而无需修改其中代码。它是子类化的替代方法，通过用另一个对象包装它来修改类的行为。 在 Swift 中，这种模式有两种非常常见的实现：扩展和代理。 拓展添加扩展是一种非常强大的机制，允许你向现有类，结构体或枚举类型添加新功能，而无需子类化。你可以扩展你无法访问的代码并增强他们的功能也非常棒。这意味着你可以将自己的方法添加到 Cocoa 类，如 UIView 和 UIImage。 Swift 扩展与装饰模式的经典定义略有不同，因为扩展不包含它扩展的类的实例。 如何使用拓展想象一下，你希望在 TableView 中显示 Album 实例的情况： 专辑的标题来自哪里？Album 是一个模型，因此它不关心你将如何呈现数据。你需要一些外部代码才能将此功能添加到 Album 结构体中。 你将创建 Album 结构体的扩展，它将定义一个返回可以在 UITableView 中容易使用的数据结构的新方法。 打开 Album.swift 并在文件末尾添加以下代码： 1typealias AlbumData = (title: String, value: String) 此类型定义了一个元组，其中包含表视图显示一行数据所需的所有信息。现在添加以下扩展名以访问此信息： 12345678910extension Album &#123; var tableRepresentation: [AlbumData] &#123; return [ ("Artist", artist), ("Album", title), ("Genre", genre), ("Year", year) ] &#125;&#125; AlbumData 数组将更容易在 TableView 中显示。 注意：类完全可以覆盖父类的方法，但是对于扩展则不能。扩展中的方法或属性不能与原始类中的方法或属性同名。 考虑一下这个模式有多强大： 你可以直接在 Album 中使用属性。 你已添加到 Album 结构体并且不用修改它。 此次简单的操作将允许你返回一个类似 UITableView 的 Album。 代理外观设计模式的另一个实现是代理，它是一种让一个对象代表或协同另外一个对象工作的机制。UITableView 很贪婪，它有两个代理类型属性，一个叫做数据源，另一个叫代理。它们做的事情略有不同，例如 TableView 将询问其数据源在特定部分中应该有多少行，但它会询问其代理在行被点击时要执行的操作。 你不能指望 UITableView 知道你希望在每个 section 中有多少行，因为这是特定于应用程序的。因此，计算每个 section 中的行数的任务会被传递到数据源。这允许 UITableView 的类独立于它显示的数据。 以下是你创建新 UITableView 时所发生的事情的伪解释： Table：我在这儿！我想做的就是显示 cell。嘿，我有几个 section 呢？Data source：一个！Table：好的，好的，很简单！第一个 section 中有多少个 cell 呢？Data source：四个！Table：谢谢！现在，请耐心点，这可能会有点重复。我可以在第 0 个 section 第 0 行获得 cell 吗？Data source：可以，去吧！Table：现在第 0 个 section，第 1 行呢？ 未完待续… UITableView 对象完成显示表视图的工作。但是最终它需要一些它没有的信息。然后它转向其代理和数据源，并发送一条消息，要求提供其他信息。 将一个对象子类化并重写必要的方法似乎更容易，但考虑一下你只能基于单个类进行子类化。如果你希望一个对象成为两个或更多其他对象的代理，你就无法通过子类化实现此目的。 注意：这是一个重要的模式。Apple 在大多数 UIKit 类中使用这种方法： UITableView， UITextView， UITextField， UIWebView， UICollectionView， UIPickerView， UIGestureRecognizer， UIScrollView。 这个清单还将不断更新。 如何使用代理模式打开 ViewController.swift 并把这些私有的属性添加到类： 123private var currentAlbumIndex = 0private var currentAlbumData: [AlbumData]?private var allAlbums = [Album]() 从 Swift 4 开始，标记为 private 的变量可以在类型和所述类型的任何扩展之间共享相同的访问控制范围。如果你想浏览 Swift 4 引入的新功能，请查看 What’s New in Swift 4。 你将使 ViewController 成为 TableView 的数据源。在类定义的右大括号之后，将此扩展添加到 ViewController.swift 的末尾： 123extension ViewController: UITableViewDataSource &#123;&#125; 编译器会发出警告，因为 UITableViewDataSource 有一些必需的函数。在扩展中添加以下代码让警告消失： 12345678910111213141516func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; guard let albumData = currentAlbumData else &#123; return 0 &#125; return albumData.count&#125;func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: "Cell", for: indexPath) if let albumData = currentAlbumData &#123; let row = indexPath.row cell.textLabel?.text = albumData[row].title cell.detailTextLabel?.text = albumData[row].value &#125; return cell&#125; tableView(_:numberOfRowsInSection:) 返回要在 tableView 中显示的行数，该行数与专辑“装饰”表示中的项目数相匹配。 tableView(_:cellForRowAtIndexPath:) 创建并返回一个带有 title 和 value 的 cell。 注意：你实际上可以将方法添加到主类声明或扩展中，编译器并不关心数据源方法实际上存在于 UITableViewDataSource 扩展中。对于阅读代码的人来说，这种组织确实有助于提高可读性。 接下来，使用以下代码替换 viewDidLoad()： 123456789override func viewDidLoad() &#123; super.viewDidLoad() //1 allAlbums = LibraryAPI.shared.getAlbums() //2 tableView.dataSource = self&#125; 以下是上述代码的解析： 通过 API 获取所有专辑的列表。请记住，我们的计划是直接使用 LibraryAPI 的外观而不是直接用 PersistencyManager！ 这是你设置 UITableView 的地方。你声明 ViewController 是 UITableView 数据源，因此，UITableView 所需的所有信息都将由 ViewController 提供。请注意，如果在 storyboard 中创建了 TableView，你实际上可以在那里设置代理和数据源。 现在，将以下方法添加到 ViewController 里： 1234567891011121314private func showDataForAlbum(at index: Int) &#123; // defensive code: make sure the requested index is lower than the amount of albums if index &lt; allAlbums.count &amp;&amp; index &gt; -1 &#123; // fetch the album let album = allAlbums[index] // save the albums data to present it later in the tableview currentAlbumData = album.tableRepresentation &#125; else &#123; currentAlbumData = nil &#125; // we have the data we need, let's refresh our tableview tableView.reloadData()&#125; showDataForAlbum(at:) 从专辑数组中获取所需的专辑数据。当你想要刷新数据时，你只需要在 UITableView 里调用 reloadData。这会导致 TableView 再次调用其数据源方法，例如重新加载 TableView 中应显示的 section 个数，每个 section 中的行数以及每个 cell 的外观等等。 将以下行添加到 viewDidLoad() 的末尾： 1showDataForAlbum(at: currentAlbumIndex) 这会在应用启动时加载当前专辑。由于 currentAlbumIndex 设置为 0，因此显示该集合中的第一张专辑。 编译并运行你的项目，你的应用启动后屏幕上应该会显示如下图： TableView 设置数据源完成！ 写在最后为了不使用硬编码值（例如字符串 Cell）污染代码，请查看 ViewController，并在类定义的左大括号之后添加以下内容： 123private enum Constants &#123; static let CellIdentifier = "Cell"&#125; 在这里，你将创建一个枚举充当常量的容器。 注意：使用不带 case 的枚举的优点是它不会被意外地实例化并只作为一个纯命名空间。 现在只需用 Constants.CellIdentifier 替换 &quot;Cell&quot;。 接下来该干嘛？到目前为止，事情看起来进展很顺利！你知道了 MVC 模式，还有单例，外观和装饰模式。你可以看到 Apple 在 Cocoa 中如何使用它们以及如何将模式应用于你自己的代码。 如果你想要查看或比较，那请看 最终项目。 库存里还有很多：本教程的第二部分还有适配器，观察者和备忘录模式。如果这还不够，我们会有一个后续教程，在你重构一个简单的 iOS 游戏时会涉及更多的设计模式。 译文出自：掘金翻译计划 译者： iWeslie 校对者： swants, Chunk49]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS高级编程ARC笔记]]></title>
    <url>%2F2018%2F09%2F29%2FiOS%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8BARC%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[ARC原理ARC 在编译期插入生命周期的代码，内存管理的方式和MRC一样。编译器会在合适的地方插入 retain release autorelease delloc 代码来管理对象的生命周期 使用ARC必须遵守的规则： 不能使用 retain/release/retainCount/autorelease 不能使用 NSAllocateObject/NSDeallocateObject 必须遵守内存管理的方法命名规则 不要显示调用 dealloc 使用@autorelease块代替NSAutoreleasePool 不能使用区域（NSZone） 对象型变量不能作为C语言结构体的成员 显式转换id和void* Apple文档：123456789101112131415161718192021222324252627- You cannot explicitly invoke dealloc, or implement or invoke retain, release, retainCount, or autorelease.The prohibition extends to using @selector(retain), @selector(release), and so on.You may implement a dealloc method if you need to manage resources other than releasing instance variables. You do not have to (indeed you cannot) release instance variables, but you may need to invoke [systemClassInstance setDelegate:nil] on system classes and other code that isn’t compiled using ARC.Custom dealloc methods in ARC do not require a call to [super dealloc] (it actually results in a compiler error). The chaining to super is automated and enforced by the compiler.You can still use CFRetain, CFRelease, and other related functions with Core Foundation-style objects (see Managing Toll-Free Bridging).- You cannot use NSAllocateObject or NSDeallocateObject.You create objects using alloc; the runtime takes care of deallocating objects.- You cannot use object pointers in C structures.Rather than using a struct, you can create an Objective-C class to manage the data instead.- There is no casual casting between id and void *.You must use special casts that tell the compiler about object lifetime. You need to do this to cast between Objective-C objects and Core Foundation types that you pass as function arguments. For more details, see Managing Toll-Free Bridging.- You cannot use NSAutoreleasePool objects.ARC provides @autoreleasepool blocks instead. These have an advantage of being more efficient than NSAutoreleasePool.- You cannot use memory zones.There is no need to use NSZone any more—they are ignored by the modern Objective-C runtime anyway.To allow interoperation with manual retain-release code, ARC imposes a constraint on method naming:- You cannot give an accessor a name that begins with new. This in turn means that you can’t, for example, declare a property whose name begins with new unless you specify a different getter: 12345// Won't work:@property NSString *newTitle; // Works:@property (getter=theNewTitle) NSString *newTitle; 属性关键字与所有权修饰符ARC 引入了几种生命周期修饰符和 weak 引用，unsafe_unretained strong autoreleasing weak生命周期修饰符是ARC 引入的新特性，代码中属性 局部变量 全局变量 参数否会用到，属性关键字最终也是映射到这几种所有权修饰符上 属性关键字 所有权修饰符 assign __unsafe_unretained copy __strong retain __strong strong __strong __unsafe_unretained __unsafe_unretained weak __weak 关于他们的官方介绍：1234__strong is the default. An object remains “alive” as long as there is a strong pointer to it.__weak specifies a reference that does not keep the referenced object alive. A weak reference is set to nil when there are no strong references to the object.__unsafe_unretained specifies a reference that does not keep the referenced object alive and is not set to nil when there are no strong references to the object. If the object it references is deallocated, the pointer is left dangling.__autoreleasing is used to denote arguments that are passed by reference (id *) and are autoreleased on return. 所有权修饰符的规范写法：ClassName * qualifier variableName; outlets 应该使用 weak，官方解释：123outlets should be weak, except for those from File’s Owner to top-level objects in a nib file (or a storyboard scene) which should be strong.Full details are given in Nib Files in Resource Programming Guide. ARC 下使用 strong/weak/autoreleasing 修饰变量，变量会隐式初始化为 nil 不支持weak弱引用的类：NSATSTypesetter, NSColorSpace, NSFont, NSMenuView, NSParagraphStyle, NSSimpleHorizontalTypesetter, and NSTextView.在ARC下 不能使用weak变量指向 NSHashTable, NSMapTable, or NSPointerArray 内存管理思想：自己生成的对象自己持有 alloc new copy mutableCopy非自己生成的对象，自己也能持有不再需要自己持有的对象时释放对象非自己持有的对象无法释放 实现原理alloc1234+alloc+allocWithZone:class_createInstance//生成实例calloc//分配内存块 retainCount12__CFdoExternRefOperationCFBasicHashGetCountOfKey retain12__CFdoExternRefOperationCFBasicHashAddValue release12__CFdoExternRefOperationCFBasicHashRemoveValue 1234567891011121314猜想实现- (NSUInteger)retainCount&#123; return (NSUInteger)____CFDoExternRefOperation(OPERATION_retainCount,self);&#125;- (id)retain&#123; return (id)____CFDoExternRefOperation(OPERATION_retain,self);&#125;//这里返回值应该是id，原书这里应该是错了- (id)release&#123; return (id)____CFDoExternRefOperation(OPERATION_release,self);&#125; 123456789101112131415161718int __CFDoExternRefOperation(uintptr_t op, id obj) &#123; CFBasicHashRef table = 取得对象的散列表(obj); int count; switch (op) &#123; case OPERATION_retainCount: count = CFBasicHashGetCountOfKey(table, obj); return count; break; case OPERATION_retain: count = CFBasicHashAddValue(table, obj); return obj; case OPERATION_release: count = CFBasicHashRemoveValue(table, obj); return 0 == count; &#125;&#125; autorelease 实现12345678910111213141516171819202122232425262728293031323334353637383940414243objc4/NSObject.mm AutoreleasePoolPage class AutoreleasePoolPage&#123; static inline void *push() &#123; //生成或者持有 NSAutoreleasePool 类对象 &#125; static inline void pop(void *token) &#123; //废弃 NSAutoreleasePool 类对象 releaseAll(); &#125; static inline id autorelease(id obj) &#123; //相当于 NSAutoreleasePool 类的 addObject 类方法 AutoreleasePoolPage *page = 取得正在使用的 AutoreleasePoolPage 实例; autoreleaesPoolPage-&gt;add(obj) &#125; id *add(id obj) &#123; //将对象追加到内部数组中 &#125; void releaseAll() &#123; //调用内部数组中对象的 release 方法 &#125;&#125;;//压栈void *objc_autoreleasePoolPush(void)&#123; if (UseGC) return nil; return AutoreleasePoolPage::push();&#125; //出栈void objc_autoreleasePoolPop(void *ctxt)&#123; if (UseGC) return; AutoreleasePoolPage::pop(ctxt);&#125; ###苹果是如何实现autoreleasepool的？autoreleasepool以一个队列数组的形式实现,主要通过下列三个函数完成.• objc_autoreleasepoolPush（压入）• objc_autoreleasepoolPop（弹出）• objc_autorelease（释放内部） __strong内部实现：123&#123; id __strong obj = [NSObject alloc] init];//obj持有对象&#125; 等同于： 12id __strong obj = [NSObject alloc] init];//obj持有对象[obj release]; 使用命名规则以外的构造方法123&#123; id __strong array = [NSMutableArray array];&#125; 等同于： 12345678910id obj = [NSMutableArray array];//obj 对 autoreleasePool 内的 array 对象引用加一[obj release];+ (id)array&#123; return [[[NSMutableArray alloc] init] autorelease];&#125; ARC下，runtime有一套对autorelease返回值的优化策略。=&gt; 12345678910&#123;id tmp = objc_retainAutoreleasedReturnValue([NSArray array]); // 代替我们调用retainid obj = tmp;objc_storeStrong(&amp;obj,nil); // 相当于代替我们调用了release&#125;+ (id)array&#123; id tmp = [NSArray array]; return objc_autoreleaseReturnValue(tmp); // 代替我们调用autorelease&#125; 实际代码中，苹果会进行优化 objc_retainAutoreleasedReturnValue的作用：持有对象，将对象注册到autoreleasepool并返回objc_autoreleaseReturnValue:返回注册到autoreleasepool的对象 __weak 实现weak 不影响引用计数，可以打破循环引用特点：● 若使用__weak修饰符的变量引用对象被废弃时，则将nil赋值给该变量 ● 使用附有__weak修饰符的变量，就是使用注册到autoreleasepool的对象。 weak 变量加入 autoreleasePool 的原因：__weak修饰符支持有对象的弱引用，在访问引用对象的过程中，该对象可能被释放。而如果将该对象加入到autoreleasepool中，在pool被释放之前，tmp对该对象的引用都是有效的。 1234id obj = [Obj new];&#123; id __weak weakObj = obj;&#125; 编译器模拟代码：1234567891011121314151617181920212223id obj = [Obj new];&#123; id weakObject; //初始化 weak 指针 objc_initWeak(&amp;weakObject,obj); /* objc_initWeak 方法做了什么 &#123; weakObject = 0; objc_storeWeak(&amp;weakObj,obj); &#125; */ //取出附有__weak修饰符变量所引用的对象并 retain id temp = objc_loadWeakRetained(&amp;weakObject); //将对象注册到autorelease中 object_autorelease(temp); objc_destroyWeak(&amp;weakObject); /* objc_destroyWeak 方法做了什么 &#123; objc_storeWeak(&amp;obj,0); &#125; */&#125; 实际上，objc_storeWeak函数会把第二个参数的对象的地址作为key，并将第一个参数（weak关键字修饰的指针的地址）作为值，注册到weak表中。如果第二个参数为0（说明weak 变量超出了作用域），直接让 weakObject 变量置为 nil，weak关键字的核心思想！如果 obj release 释放 则通过 dealloc 调用的 objc_clear_deallocating 函数。 释放对象时，废弃对象的同时，程序的动作是怎样的呢？对象通过objc_release释放。 objc_release 因为引用计数为0所以执行dealloc _objc_rootDealloc object_dispose objc_destructInstance objc_clear_deallocating 而，调用objc_clear_deallocating的动作如下： 从weak表中获取废弃对象的地址为键值的记录。 将包含在记录中的所有附有__weak修饰符变量的地址，赋值为nil 从weak表中删除记录 从引用计数表中删除废弃对象的地址作为键值的记录 autorelease 的实现ARC 下 @autoreleasepool{} 的实现 12345id pool = objc_autoreleasePoolPush();// &#123;&#125;中的代码objc_autoreleasePoolPop(pool);// pool 指当前 autoreleasepool 哨兵对象的地址 objc_autoreleasePoolPush 与 objc_autoreleasePoolPop 都是对 AutoreleasePoolPage 的封装。 AutoreleasepoolPage c++ 类 1234567magic_t const magic;id * next; //新对象将被加入的地址pthread_t const thread; //当前线程AutoreleasePoolPage * const parent; //指向上一个 pageAutoreleasePoolPage *child; //指向下一个 pageuint32_t const depth;uint32_t hiwat; AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组合而成（分别对应结构中的parent指针和child指针） AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程） AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址 上面的id *next指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置 一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入 当前page页加入的autorelease对象后满了（也就是next指针指向了end），这时就要执行建立下一页page对象，与这一页链表连接完成后，新page的next指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。 所以，向一个对象发送- autorelease消息，就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置 释放每当进行一次objc_autoreleasePoolPush调用时，runtime向当前的AutoreleasePoolPage中add进一个哨兵对象，值为0（也就是个nil）objc_autoreleasePoolPush 的返回值正是这个哨兵对象的地址，被objc_autoreleasePoolPop(哨兵对象)作为入参，于是： 根据传入的哨兵对象地址找到哨兵对象所处的page在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次- release消息，并向回移动next指针到正确位置补充2：从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page 嵌套知道了上面的原理，嵌套的AutoreleasePool就非常简单了，pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响。 ##参考官方资料其他参考资料：iOS 内存管理高级编程Objective-C 高级编程可能是史上最全面的内存管理文章可能碰到的iOS笔试面试题（6）–内存管理]]></content>
      <tags>
        <tag>ARC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于单例的一个小思考]]></title>
    <url>%2F2018%2F08%2F15%2F%E5%85%B3%E4%BA%8E%E5%8D%95%E4%BE%8B%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%80%9D%E8%80%83.html</url>
    <content type="text"><![CDATA[单例的生命周期iOS app 中单例一经创建，全局共享单例对象，单例的生命周期跟随app生命周期，那它的原理是什么呢？ 答：先看单例写法： 123456789101112131415161718192021222324252627282930//全局的变量,指的就是Singleton这个对象,静态全局变量，始终指向实例化出的对象static id instance; + (instancetype)shareInstance&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken,^&#123; //创建类 instance = [[self alloc]init]; &#125;); return instance;&#125;//创建alloc init 时候创建,会调用allocWithZone ,保证创建出来这个对象是唯一的+ (instancetype)allocWithZone:(struct _NSZone *)zone&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken,^&#123; //返回自己 instance = [super allocWithZone:zone]; &#125;); return instance;&#125;//防止外界拷贝造成多个实例- (id)copyWithZone:(NSZone *)zone&#123; return instance;&#125; 首先使用 static 修饰符，声明了单例对象，这就意味着这个单例对象是在程序的数据区进行存储的，而数据区会跟随 app打开申请 app关闭释放。实现了单例生命周期跟随app的生命周期，这也解释了为什么每次打开app(非后台状态)单例对象就会重新初始化，造成单例上次保存的数据丢失。 那单例对象生命周期是否应该由 MRC/ARC 控制呢？答案也是否定的，因为无论 ARC 还是 MRC 都是管理用来管理堆上对象的生命周期的，而数据区的单例释放与否是由系统控制的，因此不应受他们控制，需要注意的是，在使用 MRC 时，单例调用 retain 确实会引起计数增加，而调用 release 则会直接崩溃，为了避免单例收到引用计数的干扰造成意想不到的后果，在 MRC 下需要覆盖retain autorelease retainCount release 这几个方法。重写这几个方法是为了单例能在MRC中使用。 123456789101112131415161718#pragma mark - MRC中需要覆盖的方法, ARC与MRC的整合#if !__has_feature(objc_arc)- (id)retain &#123; return self;&#125; - (id)autorelease &#123; return self;&#125; - (oneway void)release &#123;&#125; - (NSUInteger)retainCount &#123; return UINT_MAX;&#125; #endif]]></content>
      <tags>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Masonry 的一些思考（下）]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%85%B3%E4%BA%8E%20Masonry%20%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%EF%BC%88%E4%B8%8B%EF%BC%89.html</url>
    <content type="text"><![CDATA[前言本篇文章是笔者对上篇文章《关于 Masonry 的一些思考》的一些自己的解答，哪里有理解不到位的地方，请尽情拍砖。如果想先看无答案版，请前往上篇文章 《看完 Masonry 源码后的几点思考？》。 图片来自戴铭文章 《读 SnapKit 和 Masonry 自动布局框架源码》 关于 Masonry 思考的解答1. Masonry 都做了些什么？Masonry 是一个让开发者用简洁优雅的语法来调用原生 AutoLayout 进行布局的轻量级框架。Masonry 拥有自己的 DSL 布局语言，让我们可以更具象地描述约束的增加与更新，让约束的代码也变得更加简洁易读、容易理解。 DSL 是一种基于特定领域的语言，它使工作更贴近于客户的理解，而不是实现本身，这样有利于开发过程中，所有参与人员使用同一种语言进行交流。简单来说，就是我们只需描述出我们想要什么效果，而毋需涉及底层实现，这无疑降低了工作过程中沟通协调的门槛。 语言过于苍白，让我们 show code： 原生 AutoLayout 实现一个红色 view 布局 123456789101112131415161718192021222324252627282930313233343536373839404142UIView *superview = self.view;UIView *view1 = [[UIView alloc] init];view1.translatesAutoresizingMaskIntoConstraints = NO;view1.backgroundColor = [UIColor greenColor];[superview addSubview:view1];UIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);[superview addConstraints:@[ //view1 constraints [NSLayoutConstraint constraintWithItem:view1 attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:superview attribute:NSLayoutAttributeTop multiplier:1.0 constant:padding.top], [NSLayoutConstraint constraintWithItem:view1 attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:superview attribute:NSLayoutAttributeLeft multiplier:1.0 constant:padding.left], [NSLayoutConstraint constraintWithItem:view1 attribute:NSLayoutAttributeBottom relatedBy:NSLayoutRelationEqual toItem:superview attribute:NSLayoutAttributeBottom multiplier:1.0 constant:-padding.bottom], [NSLayoutConstraint constraintWithItem:view1 attribute:NSLayoutAttributeRight relatedBy:NSLayoutRelationEqual toItem:superview attribute:NSLayoutAttributeRight multiplier:1 constant:-padding.right], ]]; 使用 Masonry 进行布局： 1234567UIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(superview.mas_top).with.offset(padding.top); //with is an optional semantic filler make.left.equalTo(superview.mas_left).with.offset(padding.left); make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom); make.right.equalTo(superview.mas_right).with.offset(-padding.right);&#125;]; 代码甚至可以再精简下： 1234UIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(superview).with.insets(padding);&#125;]; 以上代码来自 Masonry 的 github 介绍 经过上面的代码比较，Masonry 语法的简洁优雅效果是浅显易见的。代码不仅变得精简，而且阅读成本也基本降到了最低。 2. 下面代码会发生循环引用吗，为什么？1234[self.view addSubview:btn];[btn makeConstrants:^(MASLayoutConstraint *make)&#123;make.left.equalTo(self.view).offset(12);&#125;]; 答： 不会发生循环引用，方法中 block 参数虽然引用 self.view，间接持有了 btn，但是 block 参数是个匿名 block，并且在方法实现里未额外引用这个 block 参数， block 并未被 btn 所持有，也就不存在两者相互持有、循环引用。block -&gt; self.view -&gt; btn -(未引用)- block 而上述方法定义中也明确使用 NS_NOESCAPE 修饰 block 参数, 这个修饰符表明 block 在方法执行完前就会被执行释放，而不会对 block 进行额外的引用保存。 - (NSArray *)mas_updateConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *make))block 在代码中 Masonry 也确实是这么做的： 1234567- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block &#123; self.translatesAutoresizingMaskIntoConstraints = NO; MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self]; block(constraintMaker); return [constraintMaker install];&#125; 从上面代码中，可以清除地看到，block 参数在 return 之前就被执行，并未被其他对象引用。 更多关于 NS_NOESCAPE 的介绍 额外拓展，很多同学对 block 的循环引用都不太了解：同样是匿名 block 参数，系统动画 123[UIView animateWithDuration:100 animations:^&#123; NSLog(@"%@",self); &#125;]; 不会造成循环引用，而 MJRefresh 的 header 初始化方法 123self.scrollView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^&#123; NSLog(@"%@", self); &#125;]; 为什么会造成循环引用？ MJRefresh 的 headerWithRefreshingBlock： 方法内部，返回的 MJRefreshNormalHeader 对象强引用了这个 block，而这个返回对象最后又被 self.scrollView.mj_header 强引用了，也就造成了 self -&gt; scrollView -&gt; mj_header -&gt; block -&gt; self 的强引用闭环，因此会造成循环引用。 headerWithRefreshingBlock: 实现代码： 123456+ (instancetype)headerWithRefreshingBlock:(MJRefreshComponentRefreshingBlock)refreshingBlock&#123; MJRefreshHeader *cmp = [[self alloc] init]; cmp.refreshingBlock = refreshingBlock; return cmp;&#125; 系统的动画实现方法中，self 并未和这个 block 产生关联，但 block 确实持有了 self，但笔者猜测 block 对self 并不是强引用，因为如果在这个动画时间内控制器执行 POP 操作，self 会立即被释放掉，也就是说除了导航控制器栈，self 并未被额外的强引用，否则 self 不会被释放。 self 未引用 block (弱)-&gt; self 。因此也不存在循环引用 想一想，当方法中使用匿名 block、匿名对象作为参数，这些匿名对象是被谁持有？会在什么时候释放呢？欢迎在评论中探讨。 3. MAS_SHORTHAND、MAS_SHORTHAND_GLOBALS 宏是做什么用的？它的效果是如何实现的呢？MAS_SHORTHAND 宏可以在调用 Masonry api 的时候省去 mas_ 前缀 Masonry 为 View 定义了 一个 View+MASAdditions 分类。在这个分类中，所有的成员属性和方法都是带有 mas_ 前缀的。Masonry 还另外定义了 View+MASShorthandAdditions 分类，在这个分类中所有的所有属性和成员变量都不带 mas_ 前缀。但这个分类被 #ifdef MAS_SHORTHAND #endif 所包裹。 效果如下： 123456//MASShorthandAdditions 分类#ifdef MAS_SHORTHAND ......（不带有 mas_ 前缀的成员变量和方法）...#endif 这样只有定义了 MAS_SHORTHAND 之后这个分类才会被编译，而这个分类内部所有属性的 get 方法、对外的接口方法实现还是调用的带有 mas_ 前缀的方法，对于我们开发者来说，只是在 mas_ 属性与方法外面包裹上了一层语法糖。 不带有 mas_ 前缀方法的实现： 12345//属性的 get 方法宏，在属性前拼接 mas_ 前缀，调用带有前缀的属性 get 方法#define MAS_ATTR_FORWARD(attr) \- (MASViewAttribute *)attr &#123; \ return [self mas_##attr]; \&#125; 1234//不带有 mas_ 前缀的 API，内部会调用带有 mas_ 前缀的 API- (NSArray *)makeConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *))block &#123; return [self mas_makeConstraints:block];&#125; 而MAS_SHORTHAND_GLOBALS 宏会将 equalTo()、 greaterThanOrEqualTo()、 offset() 宏定义为 mas_equalTo()、 mas_greaterThanOrEqualTo()、 mas_offset() 。 而带有 mas_ 前缀的方法会将括号内的 block 参数从基本数据类型转化为 NSValue 对象类型 #define mas_equalTo(...) equalTo(MASBoxValue((__VA_ARGS__))) 12345678#ifdef MAS_SHORTHAND_GLOBALS#define equalTo(...) mas_equalTo(VA_ARGS)#define greaterThanOrEqualTo(...) mas_greaterThanOrEqualTo(VA_ARGS)#define lessThanOrEqualTo(...) mas_lessThanOrEqualTo(VA_ARGS)#define offset(...) mas_offset(VA_ARGS)#endif 4. Masonry 的 makeConstraints: 、updateConstraints:、 remakeConstraints: 有什么区别，分别适合那些场景？1234567- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block &#123; self.translatesAutoresizingMaskIntoConstraints = NO; MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self]; block(constraintMaker); return [constraintMaker install];&#125; remakeConstraints: 和上面代码的唯一区别就是增加了constraintMaker.removeExisting = YES; 当 [constraintMaker install] 时，如果 removeExisting 判断为 true，会将已安装的约束全部执行 [constraint uninstall] 卸载; 而 updateConstraints: 和上面代码的唯一区别就是在调用 block 之前增加了一句 constraintMaker.updateExisting = YES 标示。 当 [constraint install] 执行时，会判断 updateExisting 的值， 如果为 true 会接着判断约束和已安装的约束是否相似，（判断是否相似的规则是，两条约束只有 constant 常量值不一样，其它诸如 firstItem secondItem firstAttribute secondAttribute relation multiplier priority 必须和之前约束完全一致，才为相似约束。），如果存在相似约束，则进行约束更新，否则就新增这条约束。因此我们要十分注意 updateConstraints: 新更新的约束会不会和已有的约束冲突， 例如当我们之前约束为 make.right.equalTo(self.view).offset(-12); 更新后为 make.right.equalTo(self.view.mas_centerX).offset(-15); 这是两条不相似的约束（secondAttribute 不一样），如果更新约束，会造成约束冲突。 5. 描述下代码 make.left.right.top.equalTo(self.view).offset(0) 都做了些什么？ make.left 生成并返回 MASViewConstraint 对象，需要注意的是： 该对象已保存了调用 view（FirstView） 和 left（FirstAttribute） 该对象已被添加到 make 的 constraints 数组内保存 MASViewConstraint.right 生成并返回了 MASCompositeConstraint 对象，需要注意的是： MASCompositeConstraint 对象保存了包含 left 和 top 的两条 MASViewConstraint 对象 make 的 constraints 数组之前保存的 MASViewConstraint 对象被替换为该 MASCompositeConstraint 对象 MASCompositeConstraint.top 返回之前的 MASCompositeConstraint 对象，需要注意的是： MASCompositeConstraint 增加了一条 top 约束 MASCompositeConstraint .equalTo(self.view) 返回之前的 MASCompositeConstraint， 遍历 MASCompositeConstraint 保存的几条约束， 为他们设置 layoutRelation、secondView 和 secondAttribute equalTo() 参数是 view 类型，secondAttribute 依旧是 nil，会在最后约束安装时如果判断为 nil 则值初始化为 FirstAttribute MASCompositeConstraint.offset 无返回值 遍历 MASCompositeConstraint 保存的几条约束，为他们设置 layoutConstant 最后约束安装时 执行 [constraintMaker install]; 就会根据 firstView FirstAttribute layoutRelation secondView secondAttribute layoutConstant 来生成原生的约束 NSLayoutConstraint ，并将原生约束添加到 firstView secondView 最近的公共父视图上生效。 6. Masonry 是如何做到链式优雅调用的？链式编程思想：简单来说，是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好。a(1).b(2).c(3) 链式编程特点：方法的返回值是 block , block 必须有返回值（本身对象），block 参数就是需要操作的值。 那 make.left.right.top.bottom.equalTo(self.view).offset(12) 链式调用的具体过程是什么样的呢? 首先 Masonry 定义了一个 MASConstraint 抽象类 上面所有的方法返回值都是 MASConstraint 类型，而所有的调用者除了第一个为 MASConstraintMake 类型，其它都是 MASConstraint 类型调用。所以前一个方法的返回值正好作为下一个方法的调用者，而调用过的所有方法修改的约束都被 maker 的 constraints 所记录下来。随后在 [constraintMaker install]; 的时候遍历 constraints 执行 [constraint install] 7.MASViewConstraint 为什么要弱引用一个 MASLayoutConstraint 的实例对象，它又用这个对象做了什么？Masonry 库最后都会生成一个 MASVIewConstraint 对象，Masonry 会根据这个对象生成系统原生 NSLayoutConstraint 约束的创建，而后期可能要对这个原生约束进行一些移除操作。需要记录这个原生约束对象。 8.MASConstraintMaker 持有一个 constraints 数组， 而 MASViewConstrint 类也有一个用来记录约束的数组，这两个数组都是用来记录生成的约束，那这两个数组有什么区别吗？各自的作用又是什么？MASConstraintMaker 的 数组是记录 本次 Masonry API 调用生成的约束，最后 make 将这个数组内的约束遍历安装 install。数组里存储的是 MASViewConstraint 和 MASCompositeConstraint 对象 而 MASViewConstrint 类的数组，记录的是 Masonry 调用者 View 已经安装了哪些约束，这个数组在后期调用者调用 updateConstraints: 时判断，更新的约束是否已经安装了 ，remakeConstraints: 方法时，需要根据数组将已经安装过的约束移除。数组里存储的都是 MASViewConstrint 对象。 后记尽管笔者水平有限，但对这些问题的拙劣见解还是奉上，希望可以给读 Masonry 源码的小伙伴带来些不一样的视角，如果对于文中有解读不当的地方也请您不吝指出。]]></content>
  </entry>
  <entry>
    <title><![CDATA[看完 Masonry 源码后的几点思考？]]></title>
    <url>%2F2018%2F05%2F25%2F%20%E7%9C%8B%E5%AE%8C%20Masonry%20%E6%BA%90%E7%A0%81%E5%90%8E%E7%9A%84%E5%87%A0%E7%82%B9%E6%80%9D%E8%80%83%EF%BC%9F.html</url>
    <content type="text"><![CDATA[最近花了两周的时间读了 Masonry 源码，被它优雅的语法深深打动。它把 Apple 原生 AutoLayout 冗长,繁琐的约束语法真是封装得简洁优雅到了极致。每一次看，都能看到不一样的东西，在这里也强烈推荐各位小伙伴阅读它的源码。我把我在看源码期间想到的问题，收获，总结到了下面几个问题中，您看能答出来多少呢？欢迎在下方评论。 Masonry 都做了些什么？ 2.下面代码会发生循环引用吗，为什么？ 1234[self.view addSubview:btn];[btn makeConstrants:^(MASLayoutConstraint *make)&#123;make.left.equalTo(self.view).offset(12);&#125;]; MAS_SHORTHAND、MAS_SHORTHAND_GLOBALS 宏是做什么用的？它的效果是怎么实现的呢？ Masonry 的 makeConstraints: 、updateConstraints:、 remakeConstraints: 有什么区别，分别适合那些场景？ 描述下代码 make.left.right.top.equalTo(self.view).offset(0); 都做了些什么？ Masonry 是如何做到链式优雅调用的？ 下面几个问题可能比较细节，希望不要介意。 MASViewConstraint 为什么要弱引用一个 MASLayoutConstraint 的实例对象，它又用这个对象做了什么？ MASConstraintMaker 持有一个 constraints 数组， 而 MASViewConstrint 类也有一个用来记录约束的数组，这两个数组都是用来记录生成的约束，那么这两个数组有什么区别吗？各自的作用又是什么？ 1234567- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *))block &#123; self.translatesAutoresizingMaskIntoConstraints = NO; MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self]; constraintMaker.updateExisting = YES; block(constraintMaker); return [constraintMaker install];&#125; 上述源码中，MASConstraintMaker 的初始化方法 initWithView: 为MASConstraintMaker初始化了一个 view 属性 ，MASConstraintMaker 持有这个 view 做什么？ MASConstraintMaker 都在什么时候会初始化 MASViewAttribute对象？ 尽管笔者水平有限，但对这些问题的拙劣见解还是会在下篇文章中放出，在这希望可以抛砖引玉，期待各位大牛共同探讨 Masonry 优雅的精髓。]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何判断某经纬度是否在地图不规则区域内]]></title>
    <url>%2F2018%2F05%2F14%2F%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%9F%90%E7%BB%8F%E7%BA%AC%E5%BA%A6%E6%98%AF%E5%90%A6%E5%9C%A8%E5%9C%B0%E5%9B%BE%E4%B8%8D%E8%A7%84%E5%88%99%E5%8C%BA%E5%9F%9F%E5%86%85.html</url>
    <content type="text"><![CDATA[在 LBS 开发中，可能经常要碰到这样的问题，如何判断一个指定的经纬度点是否落在一个多边形区域内？比如在地图上画了一个多边形区域，然后给出一个经纬度点，怎样判断这个点是否在这个多边形范围之内？ 需求描述最近接到个考勤打卡场景需求: 用户在差旅状态下禁止打卡 用户进入考勤范围才允许打卡 第一点好解决：在用户差旅状态下禁止打卡交互就可以了，而第二点可能就有点复杂了： 如何来判断用户进入考勤范围内呢？拓展下类似的需求还有外卖点餐判断是否在商家配送范围？判断共享单车是否停靠在停车点？ 这些需求拆分到最后都是 在判断一个坐标点是否在一个无规则的多边形内的问题。 理论支持需求： 判断某点坐标是否在多边形内方法： 求解通过该点的水平射线与多边形各边的交点个数结果： 水平射线与多边形交点为奇数，则在多边形内部；交点为偶数，则在多边形外部 代码实现接下来就是上代码。我们首先要做的就是与后端商定 app 与服务器数据传输的规则：服务器传回包含五边形点坐标字符串，这五个点按顺序联结框定出一个不规则的五边形区域， 这个五边形区域就是我们的打卡考勤有效范围。 服务器传回的多边形各点坐标： 1@"POLYGON((116.2310052844 39.9980477478,116.5143798001 40.0028565483,116.2460357549 39.8348654814,116.3976525318 39.7646827931,116.5157236632 39.8221811347))"; 我们先把这个字符串处理成五个包含经度和纬度的 Coordinate 对象。Coordinate 对象的结构为： 1234567@interface Coordinate:NSObject@property (nonatomic, assign) double lon;@property (nonatomic, assign) double lat;@end@implementation Coordinate@end 坐标转换需要注意的是，我们在处理字符串的时候，将火星坐标转化为百度坐标。(服务传回的坐标为火星坐标，项目中定位模块定到位后直接将经纬度转化为了百度坐标，这里是为了保持与服务器坐标系的一致进行转化，各位小伙伴需要根据自己项目实际情况进行坐标转换) 各地图API坐标系统科普与转换 WGS84坐标系：即地球坐标系，国际上通用的坐标系。设备一般包含GPS芯片或者北斗芯片获取的经纬度为WGS84地理坐标系, 谷歌地图采用的是WGS84地理坐标系（中国范围除外）; GCJ02坐标系：即火星坐标系，是由中国国家测绘局制订的地理信息系统的坐标系统。由WGS84坐标系经加密后的坐标系。 谷歌中国地图和搜搜中国地图采用的是GCJ02地理坐标系; BD09坐标系：即百度坐标系，GCJ02坐标系经加密后的坐标系; 搜狗坐标系、图吧坐标系等，估计也是在GCJ02基础上加密而成的。 处理服务器返回的数据,并将火星坐标转化为百度坐标：12345678910111213141516171819202122232425262728293031//处理服务器返回的数据- (void)dealWithDotCoordinateWithString:(NSString *)locString&#123;//locString = @"POLYGON((116.2310052844 39.9980477478,116.5143798001 40.0028565483,116.2460357549 39.8348654814,116.3976525318 39.7646827931,116.5157236632 39.8221811347))"; locString = [locString stringByReplacingOccurrencesOfString:@"POLYGON((" withString:@""]; locString = [locString stringByReplacingOccurrencesOfString:@"))" withString:@""]; NSArray *locArray = [locString componentsSeparatedByString:@","]; NSMutableArray *locResult = [NSMutableArray new]; NSInteger index = 0; for (NSString * str in locArray) &#123; NSArray *strArray = [str componentsSeparatedByString:@" "]; if (strArray.count &gt; 1) &#123; Coordinate *lonAndLat = [Coordinate new] ; NSString *lon = [strArray objectAtIndex:0]; lonAndLat.lon = [lon doubleValue]; NSString *lat = [strArray objectAtIndex:1]; lonAndLat.lat = [lat doubleValue]; //将服务器的火星坐标转换为百度坐标 Coordinate *baiduLoc = [self lonAndLatLocationBaiduFromMars:lonAndLat]; [locResult addObject:baiduLoc]; index ++; &#125; &#125; &#125; 火星坐标转换为百度坐标的方法：1234567891011121314//将火星坐标转换为百度坐标的方法- (Coordinate *)lonAndLatLocationBaiduToMars:(Coordinate *)coordinate&#123;double x_pi = M_PI * 3000.0 / 180.0;double x = coordinate.lon, y = coordinate.lat;double z = sqrt(x * x + y * y) + 0.00002 * sin(y * x_pi);double theta = atan2(y, x) + 0.000003 * cos(x * x_pi);coordinate.lon = z * cos(theta) + 0.0065;coordinate.lat = z * sin(theta) + 0.006;return coordinate;&#125; 百度坐标转化为火星坐标方法：123456789101112131415161718//百度坐标转化为火星坐标- (Coordinate *) lonAndLatLocationMarsToMars:(Coordinate *)coordinate&#123; double x_pi = M_PI * 3000.0 / 180.0; double x = coordinate.lon - 0.0065, y = coordinate.lat - 0.006; double z = sqrt(x * x + y * y) - 0.00002 * sin(y * x_pi); double theta = atan2(y, x) - 0.000003 * cos(x * x_pi); coordinate.lon = z * cos(theta); coordinate.lat = z * sin(theta); return coordinate;&#125; 如何判断接下来就是重点，怎么判断坐标在多边形内部方法： 12345678910111213141516171819202122232425262728293031323334353637383940//判断点是否在多边形内部- (BOOL)judgeLocationX:(double)locationX locationY:(double)locationY insideSignArea:(NSArray *)areaArray&#123;if(areaArray.count==0)&#123; NSLog(@"考勤区域为空 直接返回 true"); return true;&#125; NSMutableArray *xArray = [NSMutableArray new]; NSMutableArray *yArray = [NSMutableArray new]; for (Coordinate *coordinate in areaArray) &#123; [xArray addObject: [NSNumber numberWithDouble:coordinate.lon]]; [yArray addObject:[NSNumber numberWithDouble:coordinate.lat]]; &#125; BOOL flag = NO; //取横坐标和纵坐标的最大值和最小值，根据这四个值minX,maxX，minY,maxY，算出一个四边形，判断目标点是否在这个四边形内，不满足，直接返回false,证明该目标点不在此多边形内部。 double minX = [[xArray valueForKeyPath:@"@min.doubleValue"] doubleValue]; double maxX = [[xArray valueForKeyPath:@"@max.doubleValue"] doubleValue]; double minY = [[yArray valueForKeyPath:@"@min.doubleValue"] doubleValue]; double maxY = [[yArray valueForKeyPath:@"@max.doubleValue"] doubleValue]; if (longitude &lt; minX || longitude &gt; maxX || latitude &lt; minY || latitude &gt; maxY ) &#123; return false; &#125; //坐标点画条水平线射线计算与多边形的交点个数，奇数在多边形内， 偶数在多边形外。 int count = (int) areaArray.count ; for (int i = 0, j = count-1; i &lt; count; j = i++) &#123; if ( ( ([yArray[i] doubleValue] &gt; locationY) != ([yArray[j] doubleValue] &gt; locationY)) &amp;&amp; (locationX &lt; ([xArray[j] doubleValue] - [xArray[i] doubleValue]) * (locationY-[yArray[i] doubleValue]) / ([yArray[j] doubleValue]-[yArray[i] doubleValue]) + [xArray[i] doubleValue]) ) flag = !flag; &#125; NSLog(@"坐标点是否在不规则区域内： %d",success); return flag; &#125; 方法内部对坐标点进行判断，判断该点纬度是否在多边形相邻两点纬度之间，如果在两纬度之间则接着判断该点单方向的水平射线与这两相邻点连结边是否有交点。如果有交点则开始计数。接着遍历判断与多边形其它边是否有交点，这样就可以得到该水平射线与多边形边交点的总个数，交点总数为奇数则该点在多边形内部；交点总数为偶数则该点在多边形外部。上面方法中并没有统计交点个数而是直接使用 flag 记录总数的奇偶性。 验证 最后进行一些简单的数据测试： 1234BOOL flag1 = [self judgeLocationX:116.3839694879 locationY:39.9274612554 insideSignArea:locResult]; //应返回 trueBOOL flag2 = [self judgeLocationX:116.4010873480 locationY:39.8485685476 insideSignArea:locResult]; //应返回 trueBOOL flag3 = [self judgeLocationX:116.5473037259 locationY:40.1688347176 insideSignArea:locResult]; //应返回 falseBOOL flag4 = [self judgeLocationX:116.1909733537 locationY:40.0254447029 insideSignArea:locResult]; //应返回 false 总结回想下我们刚才都做了些什么： 处理坐标字符串 火星坐标转化为百度坐标 判断点坐标是否在多边形内部 简单验证]]></content>
  </entry>
  <entry>
    <title><![CDATA[Swift 网络单元测试完全手册]]></title>
    <url>%2F2018%2F03%2F17%2FSwift-%E7%BD%91%E7%BB%9C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AE%8C%E5%85%A8%E6%89%8B%E5%86%8C.html</url>
    <content type="text"><![CDATA[不得不承认，对于 iOS 开发写测试并不是很普遍(至少和后端写测试程度相比)。我过去是个独立开发者而且最初也没经过原生“测试驱动”的开发培训，因此我花费了大量的时间来学习如何编写测试用例，如何写出可测试的代码。这也是我写这篇文章的初衷，我想把自己用 Swift 写测试时摸索到的心得分享给大家，希望我的见解能够帮助大家节省学习时间，少走些弯路。 在这篇文章，我们将会讨论着手写测试的入门知识：依赖注入。 想象一下，你此时正在写测试。如果你的测试对象(被测系统)是和真实世界相连的，比如 Networking 和 CoreData，编写测试代码将会非常复杂。原则上讲，我们不希望我们的测试代码被客观世界的事物所影响。被测系统不应依赖于其他的复杂系统，这样我们才能够保证在时间恒定和环境恒定条件下迅速完成测试。况且，保证我们的测试代码不会“污染”生产环境也是十分重要的。“污染”意味着什么？意味着我们的测试代码将一些测试对象写进了数据库，提交了些测试数据到生产服务器等等。而避免这些情况的发生就是 依赖注入 存在的意义。 让我们从一个例子开始。假设你拿到个应该联网并且在生产环境下才能被执行的类，联网部分就被称作该类的 依赖。如之前所言，当我们执行测试时这个类的联网部分必须能够被模拟的，或者假的环境所替换。换句话说，该类的依赖必须支持“可注入”，依赖注入使我们的系统更加灵活。我们能够为生产代码“注入”真实的网络环境；与此同时，也能够“注入”模拟的网络环境来让我们在不访问互联网的条件下运行测试代码。 TL;DR 译者注：TL;DR 是 Too long;Don’t read 的缩写。在这里的意思是篇幅较长，不想深入研究，请直接看文章总结。 在这篇文章，我们将会讨论： 如何使用 依赖注入 技术设计一个对象 在 Swift 中如何使用协议设计一个模拟对象 如何测试对象使用的数据及如何测试对象的行为 依赖注入开始动手吧! 现在我们打算实现一个叫做 HttpClient 的类。这个 HttpClient 应该满足以下要求： HttpClient 跟初始的网络组件对于同一 URL 应提交同样的 request。 HttpClient 应能够提交 request。 所以我们对 HttpClient 的初次实现是这样的： 1234567891011class HttpClient &#123; typealias completeClosure = ( _ data: Data?, _ error: Error?)-&gt;Void func get( url: URL, callback: @escaping completeClosure ) &#123; let request = NSMutableURLRequest(url: url) request.httpMethod = "GET" let task = URLSession.shared.dataTask(with: request) &#123; (data, response, error) in callback(data, error) &#125; task.resume() &#125;&#125; HttpClient 看起来可以提交一个 “GET” 请求，并通过 “callback” 闭包将返回值回传。 1HttpClient().get(url: url) &#123; (success, response) in // Return data &#125; HttpClient 的用法。 这就是问题所在：我们怎么对它测试？我们如何确保这些代码达到上述的两点要求？凭直觉，我们可以给 HttpClient 传入一个 URL，运行代码，然后在闭包里观察得到的结果。但是这些操作意味着我们在运行 HttpClient 时必须每次都连接互联网。更糟糕的是如果你测试的 URL 是连接生产服务器：你的测试在一定程度上会影响服务器性能，而且你提交的测试数据将会被提交到真实的世界。就像我们之前描述的，我们必须让 HttpClient “可测试”。 我们来看下 URLSession。URLSession 是 HttpClient 的一种‘环境’，是 HttpClient 连接互联网的入口。还记得我们刚讨论的“可测试”代码吗？ 我们需要将互联网部分变得可替换，于是我们修改了 HttpClient 的实现： 123456789101112131415class HttpClient &#123; typealias completeClosure = ( _ data: Data?, _ error: Error?)-&gt;Void private let session: URLSession init(session: URLSessionProtocol) &#123; self.session = session &#125; func get( url: URL, callback: @escaping completeClosure ) &#123; let request = NSMutableURLRequest(url: url) request.httpMethod = "GET" let task = session.dataTask(with: request) &#123; (data, response, error) in callback(data, error) &#125; task.resume() &#125;&#125; 我们将 1let task = URLSession.shared.dataTask() 修改成了 1let task = session.dataTask() 我们增加了新的变量：session，并添加了对应的 init 方法。之后每当我们创建 HttpClient 对象时，就必须初始化 session。也就是说，我们已经将 session “注入”到了我们创建的 HttpClient 对象中。现在我们就能够在运行生产代码时注入 ‘URLSession.shared’，而运行测试代码时注入一个模拟的 session。Bingo! 这时 HttpClient 的用法就变成了：HttpClient(session: SomeURLSession() ).get(url: url) { (success, response) in // Return data } 给此时的 HttpClient 写测试代码就会变得非常简单。因此我们开始布置我们的测试环境： 1234567891011class HttpClientTests: XCTestCase &#123; var httpClient: HttpClient! let session = MockURLSession() override func setUp() &#123; super.setUp() httpClient = HttpClient(session: session) &#125; override func tearDown() &#123; super.tearDown() &#125;&#125; 这是个规范的 XCTestCase 设置。httpClient 变量就是被测系统，session 变量是我们将为 httpClient 注入的环境。因为我们要在测试环境运行代码，所以我们将 MockURLSession 对象传给 session。这时我们将模拟的 session 注入到了 httpClient，使得 httpClient 在 URLSession.shared 被替换成 MockURLSession 的情况下运行。 测试数据现在让我们注意下第一点要求： HttpClient 和初始的网络组件对于同一 URL 应提交同样的 request 。 我们想达到的效果是确保该 request 的 url 和我们传入 “get” 方法的 url 完全一致。 以下是我们的测试用例： 123456789func test_get_request_withURL() &#123; guard let url = URL(string: "https://mockurl") else &#123; fatalError("URL can't be empty") &#125; httpClient.get(url: url) &#123; (success, response) in // Return data &#125; // Assert &#125; 这个测试用例可表示为： Precondition: Given a url “https://mockurl” When: Submit a http GET request Assert: The submitted url should be equal to “https://mockurl” 我们还需要写断言部分。 但是我们怎么知道 HttpClient 的 “get” 方法确实提交了正确的 url 呢？让我们再看眼依赖：URLSession。通常，“get” 方法会用拿到的 url 创建一个 request，并把 request 传给 URLSession 来完成提交: 1234let task = session.dataTask(with: request) &#123; (data, response, error) in callback(data, error)&#125;task.resume() 接下来，在测试环境中 request 将会传给 MockURLSession，所以我们只要 hack 进我们自己的 MockURLSession 就可以查看 request 是否被正确创建了。 下面是 MockURLSession 的粗略实现： 12345678class MockURLSession &#123; private (set) var lastURL: URL? func dataTask(with request: NSURLRequest, completionHandler: @escaping DataTaskResult) -&gt; URLSessionDataTask &#123; lastURL = request.url completionHandler(nextData, successHttpURLResponse(request: request), nextError) return // dataTask, will be impletmented later &#125;&#125; MockURLSession 的作用和 URLSession 一样，URLSession 和 MockURLSession 有同样的 dataTask() 方法和相同的回调闭包类型。虽然 URLSession 比 MockURLSession 的 dataTask() 做了更多的工作，但它们的接口是类似的。正是由于它们的接口相似，我们才能不需要修改 “get” 方法太多代码就可以用 MockURLSession 替换掉 URLSession。接着我们创建一个 lastURL 变量来跟踪 “get” 方法提交的最终 url 。简单点说，就是当测试的时候，我们创建一个注入 MockURLSession 的 HttpClient，然后观察 url 是否前后相同。 以下是测试用例的大概实现： 123456789func test_get_request_withURL() &#123; guard let url = URL(string: "https://mockurl") else &#123; fatalError("URL can't be empty") &#125; httpClient.get(url: url) &#123; (success, response) in // Return data &#125; XCTAssert(session.lastURL == url)&#125; 我们为 lastURL 和 url 添加断言，这样就会得知注入后的 “get” 方法是否正确创建了带有正确 url 的 request。 上面的代码仍有一处地方需要实现：return // dataTask。在 URLSession 中返回值必须是个 URLSessionDataTask 对象，但是 URLSessionDataTask 已经不能正常创建了，所以这个 URLSessionDataTask 对象也需要被模拟创建： 123class MockURLSessionDataTask &#123; func resume() &#123; &#125;&#125; 作为 URLSessionDataTask，模拟对象需要有相同的方法 resume()。这样才会把模拟对象当做 dataTask() 的返回值。 如果你跟着我一块敲代码，就会发现你的代码会被编译器报错： 1234567891011class HttpClientTests: XCTestCase &#123; var httpClient: HttpClient! let session = MockURLSession() override func setUp() &#123; super.setUp() httpClient = HttpClient(session: session) // Doesn't compile &#125; override func tearDown() &#123; super.tearDown() &#125;&#125; 这是因为 MockURLSession 和 URLSession 的接口不一样。所以当我们试着注入 MockURLSession 的时候会发现 MockURLSession 并不能被编译器识别。我们必须让模拟的对象和真实对象拥有相同的接口，所以我们引入了 “协议” ! HttpClient 的依赖： 1private let session: URLSession 我们希望不论 URLSession 还是 MockURLSession 都可以作为 session 对象，因此我们将 session 的 URLSession 类型改为 URLSessionProtocol 协议： 1private let session: URLSessionProtocol 这样我们就能够注入 URLSession 或 MockURLSession 或者其它遵循这个协议的对象。 以下是协议的实现： 123protocol URLSessionProtocol &#123; typealias DataTaskResult = (Data?, URLResponse?, Error?) -&gt; Void func dataTask(with request: NSURLRequest, completionHandler: @escaping DataTaskResult) -&gt; URLSessionDataTaskProtocol&#125; 测试代码中我们只需要一个方法：dataTask(NSURLRequest, DataTaskResult)，因此在协议中我们也只需定义一个必须实现的方法。当我们需要模拟不属于我们的对象时这个技术通常很适用。 还记得 MockURLDataTask 吗？另一个不属于我们的对象，是的，我们要再创建个协议。 1protocol URLSessionDataTaskProtocol &#123; func resume() &#125; 我们还需让真实的对象遵循这个协议。 12extension URLSession: URLSessionProtocol &#123;&#125;extension URLSessionDataTask: URLSessionDataTaskProtocol &#123;&#125; URLSessionDataTask 有个同样的 resume() 协议方法，所以这项修改对于 URLSessionDataTask 是没有影响的。 问题是 URLSession 没有 dataTask() 方法来返回 URLSessionDataTaskProtocol 协议，因此我们需要拓展方法来遵循协议。 12345extension URLSession: URLSessionProtocol &#123; func dataTask(with request: NSURLRequest, completionHandler: @escaping DataTaskResult) -&gt; URLSessionDataTaskProtocol &#123; return dataTask(with: request, completionHandler: completionHandler) as URLSessionDataTaskProtocol &#125;&#125; 这个简单的方法只是将返回类型从 URLSessionDataTask 改成了 URLSessionDataTaskProtocol，不会影响到 dataTask() 的其它行为。 现在我们就能够补全 MockURLSession 缺失的部分了： 12345678class MockURLSession &#123; private (set) var lastURL: URL? func dataTask(with request: NSURLRequest, completionHandler: @escaping DataTaskResult) -&gt; URLSessionDataTask &#123; lastURL = request.url completionHandler(nextData, successHttpURLResponse(request: request), nextError) return // dataTask, will be impletmented later &#125;&#125; 我们已经知道 // dataTask… 可以是一个 MockURLSessionDataTask： 123456789class MockURLSession: URLSessionProtocol &#123; var nextDataTask = MockURLSessionDataTask() private (set) var lastURL: URL? func dataTask(with request: NSURLRequest, completionHandler: @escaping DataTaskResult) -&gt; URLSessionDataTaskProtocol &#123; lastURL = request.url completionHandler(nextData, successHttpURLResponse(request: request), nextError) return nextDataTask &#125;&#125; 在测试环境中模拟对象就会充当 URLSession 的角色，并且 url 也能够被记录供断言判断。是不是有种万丈高楼平地起的感觉! 所有的代码都已经编译完成并且测试也顺利通过！ 让我们继续。 测试行为第二点要求是： The HttpClient should submit the request 我们希望 HttpClient 的 “get” 方法将 request 如预期地提交。 和之前验证数据是否正确的测试不同，我们现在要测试的是方法是否被顺利调用。换句话说，我们想知道 URLSessionDataTask.resume() 方法是否被调用了。让我们继续使用刚才的老把戏：我们创建一个新的 resumeWasCalled 变量来记录 resume() 方法是否被调用。 我们简单写一个测试： 1234567891011func test_get_resume_called() &#123; let dataTask = MockURLSessionDataTask() session.nextDataTask = dataTask guard let url = URL(string: "https://mockurl") else &#123; fatalError("URL can't be empty") &#125; httpClient.get(url: url) &#123; (success, response) in // Return data &#125; XCTAssert(dataTask.resumeWasCalled)&#125; dataTask 变量是我们自己拥有的模拟对象，所以我们可以添加一个属性来监控 resume() 方法的行为： 123456class MockURLSessionDataTask: URLSessionDataTaskProtocol &#123; private (set) var resumeWasCalled = false func resume() &#123; resumeWasCalled = true &#125;&#125; 如果 resume() 方法被调用了，resumeWasCalled 就会被设置成 true! :) 很简单，对不对？ 总结通过这篇文章，我们学到： 如何调整依赖注入来改变生产/测试环境。 如何利用协议来创建模拟对象。 如何检测传值的正确性。 如何断言某个函数的行为。 刚起步时，你必须花费大量时间来写简单的测试，而且测试代码也是代码，所以你仍需要保持测试代码的简洁和良好的架构。但编写测试用例得到的好处也是弥足珍贵的，代码只有在恰当的测试后才能被扩展，测试帮你免于琐碎 bug 的困扰。所以让我们一起加油写好测试吧! 所有的示例代码都在 GitHub 上，代码是以 Playground 的形式展示的，我还在上面添加了个额外的测试。 你可以自由下载或 fork 这些代码，并且欢迎任何反馈！ 感谢阅读我的文章 💚 。 参考文献 Mocking Classes You Don’t Own Dependency Injection Test-Driven iOS Development with Swift 感谢 Lisa Dziuba 和 Ahmed Sulaiman. 译文出自：掘金翻译计划 译者： Swants 校对者： pthtc ZhiyuanSun]]></content>
  </entry>
  <entry>
    <title><![CDATA[Xcode 环境配置最佳实践]]></title>
    <url>%2F2018%2F01%2F12%2FXcode-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html</url>
    <content type="text"><![CDATA[前言工欲善其事，必先利其器。在 iOS 中,如何处理 配置环境 和根据需求自定义的 设置 关系也尤为重要。虽然 Xcode 提供了一系列的工具帮助我们进行妥善地配置。但遗憾的是，我见过的很多团队在绝大多数时候都没有充分利用这些辅助工具。这并不是他们的错：苹果只为我们提供了一些不怎么好用的默认配置，而没有更好的帮助我们学习如何达到最佳实践。 在这篇文章里，我们将探索如何更好地利用 Xcode 配置，如何把 APP 的设置定义得更加有条理。 Xcode 配置Xcode 可以通过各种配置构建不同设置的包。通俗地讲，配置就是告诉编译器如何构建版本的一系列设置。IDE 允许你根据不同的配置来自定义一些设置。你可能经常看到这些： 等等… Debug vs. ReleaseDebug 和 Release 是 Xcode 提供的两种默认配置。你完全也可以创建你自己的配置，但我们通常不这么做，因为自定义的配置是否有效可能取决于项目，iOS 开发者们对哪些配置可以对项目普遍有效还没有达成共识。 这两种默认配置有几处差别，具体的差别在这里我不会详细讨论，只是简单概括下： 在 debug 构建的版本中，Xcode 会给我们发送完整的符号调试信息来帮助我们调试应用，并且 Xcode 不会对代码进行优化（更快的构建速度）。而在 release 构建的版本中，不会发送调试信息并且代码会被优化（较慢的构建速度）。 至于这两种配置的用途，debug 通常会在我们日常开发中使用。而 release 我们通常会在需要将 APP 分发给其他非开发人员如：测试人员、项目经理、客户或用户时使用。 需要注意的是，这两个配置通常是不能完全满足需求的。而且开发者经常把 ≪debug vs. release≫ 和 ≪staging vs. production≫ 这两个概念搞混，这完全是不应该的。 我们可以继续完善一些项目使用不同的配置环境：开发环境、临时环境、生产环境、预生产环境等等，用你最想用的那个就好。这种分类方式和上面讨论的两种默认配置没有直接联系。就算我们强制这么分类，用的时候达到的效果也没有想象中的那样好。比如，你想准备构建一个 release 版本，但这并不意味着你的 APP 一定要指向 生产 服务器：想像一下，你需要为 QA 打个 release 的版本的包，而这个包需要在临时服务器上进行测试。 这时就连 debug &amp; release 两个默认的配置也不能满足需求了。 因此，我想用可以满足我们更多需求的其他配置方案来代替基本的 debug &amp; release 配置。为了足够简单，在我的方案中只会保留临时环境和生产环境，在你需要使用其它环境配置时，你会发现在我的方案里可以轻松添加。 让我们重新定义配置环境我们可以定义四种配置环境： Debug Staging Debug Production TestFlight Staging TestFlight Production 从它们的名字上，你就能猜到它们大概的设置，下面就是它们的详细设置： 前两个（Debug Staging &amp; Debug Production）和默认的 Debug 配置一样，但 每个都指向不同的服务器环境。 后两个配置环境（两个 TestFlight 配置环境 ）也是这样，它们和默认的 Release 配置一样，不包含调试信息并进行了代码优化，但 每个都在对应的服务器环境下使用。 实现的操作也是非常简单，找到 project 的 Settings &gt; Info &gt; Configurations，然后点击 + 按钮。拷贝一份 Debug 配置，并将默认的配置命名为 “Debug Staging”，拷贝出来的配置命名为 “Debug Production”。按照这个方式对 Release 进行处理。 当你操作完后是这个效果： 一个 project 包含四种不同的配置环境。 第五种配置环境我使用 “ TestFlight” 命名 release 配置，而不是使用原来的 “Release” 命名是有原因的。因为代码中有些特定事件只在最终用户使用时触发，而在测试人员和客户使用时不触发。一个具体的场景就是使用用户统计来跟踪事件，这可能要求跟踪事件仅作用于最终用户，而不是生产环境下的测试人员。在这种情况下， 我们就要考虑 TestFlight Production 配置具有的细微差别，因此我们需要将这个配置继续细分下去。引进第五种配置： AppStore 你可以快速地拷贝一份 TestFlight Production 来添加这个配置。但需要注意的是这个配置可能一直不会用到，因为你不一定会遇到需要细分 TestFlight Production 配置的需求。 那么，现在你可能很想知道 如何根据所选配置来管理 APP 中的触发事件。这些将会在接下来部分详细介绍。 自定义设置有很多方式可以做到根据所选不同配置来执行不同的操作：预编译器指令、环境变量、各种 plist 文件等等。这些方式都有自己的优缺点，这里只讨论我将采取的比较纯净的方式。 需要根据配置执行的各种操作通常可以由变量来控制，通过这些变量来决定 APP 的行为。这些变量通常称为 settings 。比如一些像这样的 settings ：服务器 API 的 base URL、Facebook App ID、日志的详细级别、是否支持离线访问等等。 接着，展示我现在如何根据所选配置来管理这些自定义 settings 的方法。从我的以往经验来看，这是目前最方便的方案。 Settings.swiftAPP 的自定义 settings 可以通过单例很简单的获取到。 1234567891011121314151617struct Settings &#123; static var shared = Settings() let apiURL: URL let isOfflineAccessEnabled: Bool let feedItemsPerPage: Int private init() &#123; let path = Bundle.main.path(forResource: "Info", ofType: "plist")! let plist = NSDictionary(contentsOfFile: path) as! [AnyHashable: Any] let settings = plist["AppSetings"] as! [AnyHashable: Any] apiURL = URL(string: (settings["ServerBaseURL"] as! String))! isOfflineAccessEnabled = settings["EnableOfflineAccess"] as! Bool feedItemsPerPage = settings["FeedItemsPerPage"] as! Int print("Settings loaded: \(self)") &#125;&#125; 这个结构体用来读取和记录 APP 的各种 settings（这些 settings 会在 APP 的 Info.plist 文件中定义），这样我们就可以在代码中随时拿到这些 settings。在这里我喜欢使用强制解包，因为这样如果缺少某项设置，APP 也会无法运行。 Info.plist在 Info.plist 文件中定义 appSettings 。这里我建议大家使用字典把这些设置汇总到一起。 这样，我们就非常纯净地完成了对 APP settings 的读取。这些 settings 在不同的配置环境中值都是不同的，还差一点就完成了。 User-Defined Settings想一下，在所有的工程内 什么会随配置的不同而改变 ？ 对，编译器的代码优化级别、header 的搜索路径、描述文件等等。如果我们能够定义我们自己的随所选配置改变的设置，那不就简单了！事实证明，我们确实可以创建用户自定义的设置。 创建 User-Defined settings 非常简单，只需要在你的 Target &gt; Build Settings 中，点击 + 按钮，然后选择 “Create User-Defined Setting”。这些也可以在 project &gt; Build Settings 下创建，但我觉得在 Target &gt; Build Settings 创建更合适。 因为你刚创建的 User-Defined Settings 可能还需与其他的 Settings 来搭配使用，所以建议最好用合适的前缀来命名。 我这里使用了我名字缩写来作为 User-Defined Settings 的前缀， 但我建议最好用项目名的缩写。 接下来，在你的 Info.plist 文件中引用对应的属性值，你可以这样做： 1$(YOUR_USER_DEFINED_SETTING_NAME) 整合全部真正神奇的地方在于：你可以将 Info.plist 中 settings 的所有已经填好的属性值替换为 User-Defined Setting 的对应地址。而你现有的自定义 setting 各需对应一条 User-Defined Setting。 当 Info.plist 文件被编译时，它会获取所选配置对应的所有 settings 属性值，而这些属性值也会在编译时对应到每个 settings 上。 现在，你就可以在你的代码里随时随地 优雅 地获取到这些 settings 的属性值： 123if Settings.shared.isOfflineAccessEnabled &#123; // do stuff&#125; 最后，在 Xcode 中选择所需的编译配置就非常简单了： 或者在 CLI 中: 总结采用这套方案，我们会获得这些好处： 有组织地构建工作流程。 有组织地管理应用程序的自定义设置。 根据配置灵活改变设置。 轻松持续集成（在命令行工具中，选择要编译的配置很容易实现）。 然而，这个方案也有些值得警惕的地方： 在运行时不能灵活地更改设置，因为设置在编译时就被打包到版本内了。 在配置之间切换时体验并不是很好：每次更改配置后，Xcode 都会重新创建一个版本，也就是说你必须等待整个项目重新编译。 只能在 .xcodeproj 中修改这些设置的值，而不能在外部 灵活 修改这些设置的值。 User-Defined Settings 暴露给了所有能够接触到代码的人 , 所以千万不要把任何重要的 key 值放到这里 。 虽然这些隐患可以一一排除，但是，这个方案的初衷只是为了从这片几乎空白的领域摸索出这些工具更好的使用方法。解决这些问题就意味着更多更复杂的修改，而且这些已经超出了本文讨论的内容，我不希望这篇文章跑题。但相信我，我们做的已经足够完善了。在下篇文章里，我们将研究如何处理这些隐患，并让我们的项目变得更加完善… 待续。 译文出自：掘金翻译计划 译者：swants 校对者：charsdavy VernonVan]]></content>
  </entry>
  <entry>
    <title><![CDATA[git 命令汇总]]></title>
    <url>%2F2017%2F11%2F16%2Fgit-%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[git 仓库命令git clone : 下载仓库到本地。 git clone 仓库URL 目的路径 把仓库下载到目的路径。 当 clone 仓库到本地时 本地只能看到 master 分支 如果想看到其他分支 使用 git checkout -b &lt;name&gt; origin/&lt;name&gt; 如果 git pull 提示 “no tracking information” ，则说明本地分支和远程分支的链接关系没有创建，用命令 git branch --set-upstream branch-name origin/branch-name git pull : 将远程仓库最新的提交更新到本地。 git push ：将本地提交更新到远程仓库。 提交命令：git add .添加文件到暂存区 git commit -m ”提交注释” 将暂存区的文件更改提交到本地仓库. git reset --&lt;m 创建分支：git branch ` 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge --no-ff &lt;name&gt; 将本地分支推送到远端分支 git push origin &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 删除远端分支 git push origin --delete &lt;name&gt; Git 查看命令:git status：查看本地仓库文件状态。 git log： 查看提交记录。 git log --pretty=oneline 单行查看提交历史 git log --graph --pretty=oneline --abbrev-commit 查看提交网络图 git diff : 查看文件改动. 暂存 stash 命令 工作的时候未 commit 想保存工作区内容 去另一条分支上工作 Git stash 可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作 git stash list 查看储存现场储藏列表 git stash apply 恢复恢复后，stash内容并不删除，你需要用git stash drop来删除 git stash pop 恢复的同时把stash内容也删了 标签命令创建标签 git tag -a &lt;标签名&gt; -m ”标签说明” 查看所有标签 git tag 给以前某个c ommit 打标签 git tag v0.9 6224937 查看标签详情 git show v0.9 推送本地某个标签: git push origin &lt;tagname&gt; 推送全部未推送过的本地标签 git push origin —tags 删除一个本地标签 git tag -d &lt;tagname&gt; 删除一个远程标签git push origin :refs/tags/&lt;tagname&gt; tip:fork 了别人的库之后自己的名下会多出一个同样的库， clone 到本地 进行 bug 修改，修复成功后，可以在 GIthub 上发 PR 如果对方同意你的 PR 就会并入你的 commit。过了一段时间 发现 对方的库已经更新了，但你的 fork 库 没有更新 可以试用一下操作更新自己的库：在自己本地的 clone 库里 首先要先确定一下是否建立了主 repo 的远程源： git remote -v 如果里面只能看到你自己的两个源( fetch 和 push )，那就需要添加主 repo 的源： 12git remote add upstream URLgit remote -v 然后你就能看到 upstream 了。 如果想与主 repo 合并： 12git fetch upstreamgit merge upstream/master 这时你的本地库就已经更新到最新的了， 然后 push 到自己的 fork 库里，就完成了 官方文档解释的常用命令：不同情境下常用的 git 命令： 123456789101112131415161718192021222324252627282930313233343536start a working area `clone` Clone a repository into a new directory `init` Create an empty Git repository or reinitialize an existing onework on the current change `add` Add file contents to the index `mv` Move or rename a file, a directory, or a symlink `eset` Reset current HEAD to the specified state `rm` Remove files from the working tree and from the indexexamine the history and state `bisect` Use binary search to find the commit that introduced a bug `grep` Print lines matching a pattern `log` Show commit logs `show` Show various types of objects `status` Show the working tree statusgrow, mark and tweak your common history ` branch` List, create, or delete branches `checkout` Switch branches or restore working tree files `commit` Record changes to the repository `diff` Show changes between commits, commit and working tree, etc `merge` Join two or more development histories together `rebase` Reapply commits on top of another base tip `tag` Create, list, delete or verify a tag object signed with GPGcollaborate `fetch` Download objects and refs from another repository `pull` Fetch from and integrate with another repository or a local branch `push` Update remote refs along with associated objects 分支策略 主分支 master 用于发布版本 保持稳定 开发分支 develop 用于日常开发 每日提交 当发布版本时 合并到master 用于发布 并做标记 合并完成处理完冲突后 要记得更新develop 临时分支 : feature-new 功能分支 基于 develop 开发完成后合并到develop 最后删除功能分支 release-new 预发布分支 基于 develop 发版前分出 测试通过后, 先合并到master上 (测试可能时间长 develop 每天正常开发 commit ) develop 再合并到develop上(预发布分支上可能有 commit 归并到 develop 上) 最后删除预发布分支 fixbug-new 修复 bug 分支 基于master分支 合并到 master 和 develop 分支上 最后删除bug分支 ​ 情景: (单人开发 未考虑到冲突)发现之前版本有bug需要紧急修复, 修复完成后合并到现有代码内 回滚到 bug 版本 git reset —hard (bug版本号) 工程内修复bug 并执行 add commit (修复bug) 等操作 拉取远端代码 pull 然后合并代码 push 到远端服务器]]></content>
  </entry>
  <entry>
    <title><![CDATA[Swift Struct References]]></title>
    <url>%2F2017%2F08%2F27%2FSwift-Struct-References.html</url>
    <content type="text"><![CDATA[最近我打算为 Swift 的最新的 keypaths 找一个好的使用场景，这篇文章介绍了我意外获得的一个使用示例。这是我刚研究出来的，但还没实际应用在生产代码上的成果。也就是说，我只是觉得这个成果非常酷并想把它展示出来。 所有的代码都可以在 gist 上获取。 思考一个简单的通讯录应用，这个应用包含一个展示联系人的列表视图和展示联系人实例的详情视图控制器。如果把 人 定义成一个类的话，大概是这个样子： 123456789101112131415class Person &#123;var name: Stringvar addresses: [Address]init(name: String, addresses: [Address]) &#123;self.name = nameself.addresses = addresses&#125;&#125;class Address &#123;var street: Stringinit(street: String) &#123;self.street = street&#125;&#125; 我们的（假设）viewController 有一个通过初始化方法设置的 person 属性。这个类还有一个 change 方法来修改这个人的属性。 12345678910final class PersonVC &#123;var person: Personinit(person: Person) &#123;self.person = person&#125;func change() &#123;person.name = "New Name"&#125;&#125; 让我们思考下当 Person 初始化为一个对象后遇到的问题： 因为 person 是一个指针，其他部分的代码就可能修改它。这是非常实用的，因为这让消息传递成为了可能。而与此同时，我们需要保证我们可以一直监听的到这些改变（比如使用 KVO ），否则我们可能会遇到数据不同步的问题。但保证我们能够实时监听则是不容易实现的。 当地址发生变化时，收到通知就更难了。观察嵌套的对象属性则是最困难的。 如果我们需要给 Person 创建一个独立的本地 copy，我们就需要实现一些像 NSCopying 这样的东西， 这需要不少的工作量。甚至当我们决定这么做时，我们仍然不得不考虑是想要深拷贝（地址也被拷贝）还是浅拷贝（地址数组是独立的，但是里面的地址仍指向相同的对象）？ 如果我们把 Person 当成 AddressBook 数组的元素，我们可能想要知道通讯录什么时候做了修改（比如说进行排序）。而想要知道你的对象图中的东西何时做了改变要么需要大量的样板，要么需要大量的观察。 如果 Person 和 Address 做成结构体的话，我们又会碰到不同的问题： 每个结构体都是独立的拷贝。这是有用的，因为我们知道它总是一致的，不会在我们手底下改变。然而，当我们在详情控制器 中对 Person 做了修改时。我们就需要一个方法来将这些改变反馈给列表视图（或者说通讯录列表）。而对于对象，这种情况会自动发生（通过在适当的位置修改 Person ）。 我们可以观察通讯录结构体的根地址，从而知道通讯录发生的任何变化。然而，我们还是不能很容易得观察到它内部属性的变化（比如：观察第一个人的名字）。 我现在提出的解决方案结合了两个方案的最大优势： 我们有可变的共享指针 因为底层数据是结构体，所以我们可以随时得到我们自己的独立拷贝 我们可以观察任何部分：无论在根级别，还是观察独立的属性（例如第一个人的名字） 我接下来会演示这个方案怎么使用，如何工作，最后再说说方案的局限性和问题。 让我们用结构体来创建一个通讯录。 123456789struct Address &#123;var street: String&#125;struct Person &#123;var name: Stringvar addresses: [Address]&#125;typealias Addressbook = [Person] 现在我们可以使用我们的 Ref 类型（ Reference 的简称）。我们用一个初始化的空数组来创建一个新的 addressBook。然后添加一个 Person 。接下来就是最酷的地方：通过使用下标我们可以获得指向第一个人的 指针 ，接着是一个指向他们名字的 指针 。我们可以将指针指向的内容改为 “New Name&quot; 来验证我们是否更改了原始的通讯录。 123456let addressBook = Ref&lt;Addressbook&gt;(initialValue: [])addressBook.value.append(Person(name: "Test", addresses: []))let firstPerson: Ref&lt;Person&gt; = addressBook[0]let nameOfFirstPerson: Ref&lt;String&gt; = firstPerson[\.name]nameOfFirstPerson.value = "New Name"addressBook.value // shows [Person(name: "New Name", addresses: [])] firstPerson 和 nameOfFirstPerson 类型可以被忽略，它们仅仅是为了增加代码可读性。 无论何时我们都可以对 Person 内容进行独立备份。一旦你做了拷贝，我们就可以使用 myOwnCopy ，并且不必实现 NSCopying 就能保证它的内容不会在我们手底下改变： var myOwnCopy: Person = firstPerson.value 我们可以监听任何 Ref 。就像 reactive 库一样，我们得到了一个可以控制观察者生命周期的一次性调用： 123456var disposable: Any?disposable = addressBook.addObserver &#123; newValue inprint(newValue) // Prints the entire address book&#125;disposable = nil // stop observing 我们也可以监听 nameOfFirstPerson 。在目前的实现中，无论什么时候通讯录中的任何改变都会触发监听，但以后的实现会有更多的功能。 123nameOfFirstPerson.addObserver &#123; newValue inprint(newValue) // Prints a string&#125; 让我们返回我们的 PersonVC 。我们可以使用 Ref 作为他的实现。 这样 viewController 就可以收到每一次更改。在响应式编程中，信号通常是只读类型的（你只会收到发生了变化的信息），这时你就需要找到另一种回传信号的方法。 在 Ref 方案中，我们可以使用 person.value 进行回写： 1234567891011121314final class PersonVC &#123;let person: Ref&lt;Person&gt;var disposeBag: Any?init(person: Ref&lt;Person&gt;) &#123;self.person = persondisposeBag = person.addObserver &#123; newValue inprint("update view for new person value: \(newValue)")&#125;&#125;func change() &#123;person.value.name = "New Name"&#125;&#125; 这个 PersonVC 不知道 Ref &lt;Person&gt;是从哪里获得的：是从一个 person 数组，一个数据库或者其他地方。实际上，我们可以通过将我们的数组包装在 History 结构体 中来撤销对我们通讯录的支持。这样我们就不再需要修改 PersonVC： 12345678let source: Ref&lt;History&lt;Addressbook&gt;&gt; = Ref(initialValue: History(initialValue: []))let addressBook: Ref&lt;Addressbook&gt; = source[\.value]addressBook.value.append(Person(name: "Test", addresses: []))addressBook[0].value.name = "New Name"print(addressBook[0].value)source.value.undo()print(addressBook[0].value)source.value.redo() 我们还可以为它添加其他的很多东西：缓存，序列化，自动同步（比如只在子线程上修改和观察），但这都是之后的工作。 实现细节我们来看看这个事情是如何实现的。我们首先从 Ref 类的定义开始。Ref 包含一个获取值和一个设置值的方法，以及添加一个观察者的方法。它有一个需要三个参数的初始化方法： 1234567891011121314151617181920212223242526final class Ref&lt;A&gt; &#123;typealias Observer = (A) -&gt; ()private let _get: () -&gt; Aprivate let _set: (A) -&gt; ()private let _addObserver: (@escaping Observer) -&gt; Disposablevar value: A &#123;get &#123;return _get()&#125;set &#123;_set(newValue)&#125;&#125;init(get: @escaping () -&gt; A, set: @escaping (A) -&gt; (), addObserver: @escaping (@escaping Observer) -&gt; Disposable) &#123;_get = get_set = set_addObserver = addObserver&#125;func addObserver(observer: @escaping Observer) -&gt; Disposable &#123;return _addObserver(observer)&#125;&#125; 现在我们可以添加一个可以观察单个结构体值的初始化方法。它创建了一个观察者和变量对应的字典。这样无论变量什么时候被修改了，所有的观察者都会被通知到。它使用上述定义的初始化方法，并传递给 get, set, 和 addObserver: 12345678910111213141516171819extension Ref &#123;convenience init(initialValue: A) &#123;var observers: [Int: Observer] = [:]var theValue = initialValue &#123;didSet &#123; observers.values.forEach &#123; $0(theValue) &#125; &#125;&#125;var freshId = (Int.min...).makeIterator()let get = &#123; theValue &#125;let set = &#123; newValue in theValue = newValue &#125;let addObserver = &#123; (newObserver: @escaping Observer) -&gt; Disposable inlet id = freshId.next()!observers[id] = newObserverreturn Disposable &#123;observers[id] = nil&#125;&#125;self.init(get: get, set: set, addObserver: addObserver)&#125;&#125; 想一下我们现在已经有 Person 指针，为了拿到 Person name 属性的指针，我们需要一种方式来对 name 进行读写操作。而 WritableKeyPath 恰好可以做到。因此，我们可以在 Ref 中添加一个subscript 来创建可以指向 Person 某一部分的指针： 123456789101112extension Ref &#123;subscript&lt;B&gt;(keyPath: WritableKeyPath&lt;A,B&gt;) -&gt; Ref&lt;B&gt; &#123;let parent = selfreturn Ref&lt;B&gt;(get: &#123; parent._get()[keyPath: keyPath] &#125;, set: &#123;var oldValue = parent.valueoldValue[keyPath: keyPath] = $0parent._set(oldValue)&#125;, addObserver: &#123; observer inparent.addObserver &#123; observer($0[keyPath: keyPath]) &#125;&#125;)&#125;&#125; 上面的代码有一点难于理解，但如果只是为了使用这个库，我们不需要真的弄明白它是怎么实现的。 也许某一天，Swift 中的 keypath 也会支持下标，但至少现在没有，接下来我们必须为集合添加另外一个下标。除了使用索引而不是 keypath ，它的实现几乎就跟上面的一样。 1234567891011extension Ref where A: MutableCollection &#123;subscript(index: A.Index) -&gt; Ref&lt;A.Element&gt; &#123;return Ref&lt;A.Element&gt;(get: &#123; self._get()[index] &#125;, set: &#123; newValue invar old = self.valueold[index] = newValueself._set(old)&#125;, addObserver: &#123; observer inself.addObserver &#123; observer($0[index]) &#125;&#125;)&#125;&#125; 这就是全部实现了。上面代码使用了 Swift 大量新特性，但它仍保持在 100 行代码以下。如果没有 Swift 4 最新功能，这也基本不可能实现。它依赖于 keypaths ，通用下标，开放范围以及以前在 Swift 中提供的许多功能。 讨论就如之前所提到的那样，这些仍处于研究中而不是生产级的代码。一旦我开始在一个真正的应用程序中使用它，我非常感兴趣想知道将来会遇到什么样问题。 下面就是其中一个让我感到困惑的代码段：： 123456var twoPeople: Ref&lt;Addressbook&gt; = Ref(initialValue:[Person(name: "One", addresses: []),Person(name: "Two", addresses: [])])let p0 = twoPeople[0]twoPeople.value.removeFirst()print(p0.value) // what does this print? 我很有兴趣将它更进一步。我甚至可以想象的到，如果我为他添加队列支持，你就可以像下面那样使用： 12var source = Ref&lt;Addressbook&gt;(initialValue: [],queue: DispatchQueue(label: "private queue")) 我还能想象的到你可以用它和数据库搭配使用。这个 Var 将会让你同时支持读写操作，并订阅任何修改的通知： 1234final class MyDatabase &#123;func readPerson(id: Person.Id) -&gt; Var&lt;Person&gt; &#123;&#125;&#125; 我期待着听到您的评论和反馈，如果你需要更深入的理解它是如何工作的，试着自己去实现它（即便你已经看了代码）。顺便提一下，我们将会以它为主题开展两场 Swift Talk。如果你对 Florian 和我从头开始构建这个项目感兴趣，就订阅它吧。 更新： 感谢 Egor Sobko 指出了一个微妙但却至关重要的错误:我为观察者发送的是 initialValue 而不是 theValue，已修改! 译文出自：掘金翻译计划 译者： Swants 校对者： ChenDongnan FlyOceanFish]]></content>
  </entry>
  <entry>
    <title><![CDATA[Swift 中的通用数据源]]></title>
    <url>%2F2017%2F08%2F14%2FSwift-%E4%B8%AD%E7%9A%84%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E6%BA%90.html</url>
    <content type="text"><![CDATA[在我开发的绝大多数 iOS app 中， tableView 和 collectionView 绝对是最常用的 UI 组件。鉴于设置一个 tableView 或 collectionView 需要大量样板代码，我最近花了些时间找到一个比较好的方法，去避免一遍又一遍地重复同样的代码。我的主要工作是对必需的样板代码进行抽取封装。随着时间的推移，很多其他开发者也解决了这个问题。并且随着 Swift 的最新进展出现了很多有趣的解决方案。 本篇文章里，我将介绍在我 APP 里已经使用了一段时间的解决方案，这个方案让我在设置 collectionView 的时候减少了大量的样板代码。 TableView vs CollectionView有些人可能会问 为什么单讨论 collectionView 而不提 tableView 呢? 在最近的几个月里，我在之前可以使用 tableView 的地方都使用成了 collectionView 。它们到目前为止表现良好！这一做法帮助我不用去区分这两个 几乎完全 相似但并不完全相同的集合概念。接下来则是让我做出这一决定的根本原因： 任何 tableView 都可以用单列的 collectionView 进行实现/重构。 tableView 在大屏幕上（如：iPad ）表现的不是特别好。 需要说明的是，我没有建议你把代码库里所有的 tableView 都用 collectionView 重新实现。我建议的是，当你需要添加一个展示列表的新功能时，你应该考虑下使用 collectionView 来代替 tableView 。尤其是在你开发一个 Universal APP 时，因为 collectionView 将让你的 APP 在所有尺寸屏幕上动态调整布局变得更简单。 Swift 泛型与有效抽取的探索我一直是泛型编程的拥趸，所以你能想象的到当苹果宣布在 Swift 中引进泛型时，我是多么的兴奋。但是泛型和协议结合有时并不合作的那么和谐。这时 Swift 2.x 中关于 关联类型 的介绍让使用泛型协议变得更加简单，越来越多的开发者开始去尝试使用它们。 我打算展示的代码抽取是基于对泛型使用的尝试，尤其是泛型协议。这样的代码抽取能够让我对设置 collectionView 所需的样板代码进行封装，从而减少设置数据源所需的代码，甚至在一些简单的使用场景两行代码就足够了。 我想说明下我所创建的不是通解。我做的代码封装针对于解决一些特定使用场景。对于这些场景来说，使用抽取封装后的代码效果非常好。对于一些复杂的使用场景，可能就需要添加额外的代码了。我把抽取工作主要放在了 collectionView 最常用的功能。如果需要的话，你可以封装更多的功能，但是对于我的特定场景来说，这并不是必需的。 作为本篇文章的目的，我将会展示一部分抽取代码来概括使用 collectionView 时常用的功能。这将是你了解使用泛型，尤其是泛型协议能够来做什么的一个好的机会。 Collection View Cell 抽取首先，我实现 collectionView 通常都是先创建展示数据的 cell 。处理 collectionView 的 cell 时通常需要： 重用 cell 配置 cell 为了简化上面的工作，我写了两个协议： ReusableCell ConfigurableCell 让我们详细地看一下这两个抽取后代码吧。 ReusableCell这个 ReusableCell 协议需要你定义一个 重用标识符 ，这个标志符将在重用 cell 的时候被用到。在我的 APP 里，我总是图方便把 cell 的重用标识符设置为和 cell 的类名一样。因此，很容易通过创建一个协议扩展来抽取出，让 reuseIdentifier 返回一个带有类名称的字符串： 123456789public protocol ReusableCell &#123; static var reuseIdentifier: String &#123; get &#125;&#125;public extension ReusableCell &#123; static var reuseIdentifier: String &#123; return String(describing: self) &#125;&#125; ConfigurableCell这个 ConfigurableCell 协议需要你实现一个方法，这个方法将使用特定类型的实例配置 cell ,而这个实例被定义成了一个泛型类型 T: 12345public protocol ConfigurableCell: ReusableCell &#123; associatedtype T func configure(_ item: T, at indexPath: IndexPath)&#125; 这个 ConfigurableCell 协议将会在加载 cell 内容的时候被调用。接下来我会详细介绍一些细节，现在我就强调下一些地方： ConfigurableCell 继承 ReusableCell 绑定类型的使用（ 绑定类型 T ）将 ConfigurableCell 定义为泛型协议。 数据源的抽取: CollectionDataProvider现在，让我们把目光收回，再回想下设置 collection view 都需要做些什么。为了让 collection view 展示内容，我们需要遵循 UICollectionViewDataSource 协议。那么最先要做的常常是确定下来这些: 需要几组：numberOfSections(in:) 每组需要几行：collectionView(_:numberOfItemsInSection:) cell 的内容怎么加载 ：collectionView(_:cellForItemAt:) 将上述代理方法实现，会确保我们能够对指定 collectionView 的 cell 进行展示 。而对于我来说，这里是非常适合进行代码抽取的地方。 为了抽取和封装上述步骤，我创建了以下泛型协议： 123456789public protocol CollectionDataProvider &#123; associatedtype T func numberOfSections() -&gt; Int func numberOfItems(in section: Int) -&gt; Int func item(at indexPath: IndexPath) -&gt; T? func updateItem(at indexPath: IndexPath, value: T)&#125; 这个协议前三个方法是： numberOfSections() numberOfItems(in:) item(at:) 他们指明了遵循 UICollectionViewDataSource 协议需要实现的代理方法列表。基于我有过一些当用户交互后需要更新数据源的使用场景，我在最后又加了一个 (updateItem(at:, value:)) 方法。这个方法允许你在需要的时候更新底层数据。到这里，在 CollectionDataProvider 定义的方法满足了遵循 UICollectionViewDataSource 协议时需要实现的常用功能。 封装样板: CollectionDataSource通过上面的抽取，现在可以开始实现一个基类，这个基类将被封装为 collectionView 创建数据源所需的常用样板。这就是最神奇地方！这个类的主要作用就是利用特定的 CollectionDataProvider 和 UICollectionViewCell 来满足遵循 UICollectionViewDataSource 协议所需要实现的方法。 这是这个类的定义： 123456open class CollectionDataSource&lt;Provider: CollectionDataProvider, Cell: UICollectionViewCell&gt;: NSObject, UICollectionViewDataSource, UICollectionViewDelegate, where Cell: ConfigurableCell, Provider.T == Cell.T&#123; [...] &#125; 它为我们做了很多事： 这个类有一个公有属性，让我们能够将它扩展为指定 CollectionDataProvider 提供正确的实现。 这是一个泛型的类，所以它需要特定的 Provider (CollectionDataProvider) 和 Cell (UICollectionViewCell) 对象进一步的定义来使用。 这个类继承于 NSObject 基类，所以能够遵循 UICollectionViewDataSource 和 UICollectionViewDelegate 来进行抽取封装样板代码。 这个类在以下场景使用的时候有一些特定限制： UICollectionViewCell 必须遵循 ConfigurableCell 协议。（ Cell: ConfigurableCell ） 特定类型 T 必须和 cell 跟 Provider 的 T 相同 (Provider.T == Cell.T)。 代码需要像下面一样对 CollectionDataSource 进行初始化和设置： 12345678910111213141516// MARK: - Private Propertieslet provider: Providerlet collectionView: UICollectionView// MARK: - Lifecycleinit(collectionView: UICollectionView, provider: Provider) &#123; self.collectionView = collectionView self.provider = provider super.init() setUp()&#125;func setUp() &#123; collectionView.dataSource = self collectionView.delegate = self&#125; 代码是非常简单的：CollectionDataSource 需要知道它将针对哪个 collectionView 对象，将根据哪个作为数据提供者。这些问题都是通过 init 方法的参数进行传递确定的。在初始化的过程中，CollectionDataSource 将自己设置为 UICollectionViewDataSource 和 UICollectionViewDelegate 的代理对象(在 setUp 方法中)。 现在让我们看一下 UICollectionViewDataSource 代理的样板代码。 这是代码： 12345678910111213141516171819202122// MARK: - UICollectionViewDataSourcepublic func numberOfSections(in collectionView: UICollectionView) -&gt; Int &#123; return provider.numberOfSections()&#125;public func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return provider.numberOfItems(in: section)&#125;open func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell&#123; guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: Cell.reuseIdentifier, for: indexPath) as? Cell else &#123; return UICollectionViewCell() &#125; let item = provider.item(at: indexPath) if let item = item &#123; cell.configure(item, at: indexPath) &#125; return cell&#125; 上面的代码片段通过 CollectionDataProvider 的一个对象展示了 UICollectionViewDataSource 代理的主要实现，就像之前所说的那样，它封装了数据源实现的所有细节。每个代理都使用指定的 CollectionDataProvider 方法来抽取跟数据源之间进行交互。 注意 collectionView(_:cellForItemAt:) 方法有一个公开的属性，这就能够让它的任何子类在需要对 cell 内容进行更多定制化的时候进行扩展。 现在对 collectionView cell 展示的功能已经做好了，让我们再为它添加更多的功能吧。 而作为第一个要添加的功能，用户应该能够在点击 cell 的时候触发某些操作。为了实现这个功能，一个简单的方案就是定义一个简单的 closure,并对这个 closure 初始化，当用户点击 cell 的时候执行这个 closure 。 处理 cell 点击的自定义 closure 如下所示： 1public typealias CollectionItemSelectionHandlerType = (IndexPath) -&gt; Void 现在，我们能定义个属性来存储这个 closure ，当用户点击这个 cell 的时候就会在 UICollectionViewDelegate 的 collectionView(_:didSelectItemAt:) 代理方法实现中执行这个初始化好的 closure 。 1234567// MARK: - Delegatespublic var collectionItemSelectionHandler: CollectionItemSelectionHandlerType?// MARK: - UICollectionViewDelegatepublic func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) &#123; collectionItemSelectionHandler?(indexPath)&#125; 作为第二个要添加的功能，我打算在 CollectionDataSource 中对多组组头和组的一些代码样板进行封装。这就需要实现 UICollectionViewDataSource 的代理方法 viewForSupplementaryElementOfKind 。为了能够让子类自定义的实现 viewForSupplementaryElementOfKind ，这个代理方法需要定义为公开方法，以便让任何子类能够对这个方法进行重写。 123456open func collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, at indexPath: IndexPath) -&gt; UICollectionReusableView&#123; return UICollectionReusableView(frame: CGRect.zero)&#125; 通常来说，这种方式适用于所有的代理方法，当他们需要被子类重写覆盖时，这些方法需要定义为公有方法，并在 CollectionDataSource 中实现。 另一种不同的解决方案就是使用一个自定义的 closure ，就像在 (CollectionItemSelectionHandlerType) 方法中处理 cell 点击事件一样。 我实现的这个特定方面是软件工程中的一个典型的权衡，一方面 —— 为 collectionView 设置数据源的主要细节都被隐藏（被抽取封装）。另一方面 —— 封装的样板代码中没有提供的功能，就会变得不能开箱即用，添加新的功能并不复杂，但是需要像我上面两个例子那样，需要实现更多的自定义代码。 实现一个具体的 CollectionDataProvider 也就是 ArrayDataProvider现在样板代码已经设置好了，collectionView 的数据源由 CollectionDataSource 负责。让我们通过一个普通的使用案例来看看样板代码用起来有多方便。为了做这个，CollectionDataSource 对象需要提供 CollectionDataProvider 具体的实现。一个覆盖大多数常见使用案例的基本实现，可以简单地使用二维数组来包含展示 collectionView cell 内容的数据 。作为我对数据源抽象的试验的一部分，我使这个实现变得更加通用，并且能够表示: 二维数组，每一个数组元素代表 collectionView 一组 cell 的内容。 数组，表示 collectionView 只有一组 cell 的内容（没有组头）。 上面的代码实现都包含在泛型类 ArrayDataProvider 中： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ArrayDataProvider&lt;T&gt;: CollectionDataProvider &#123; // MARK: - Internal Properties var items: [[T]] = [] // MARK: - Lifecycle init(array: [[T]]) &#123; items = array &#125; // MARK: - CollectionDataProvider public func numberOfSections() -&gt; Int &#123; return items.count &#125; public func numberOfItems(in section: Int) -&gt; Int &#123; guard section &gt;= 0 &amp;&amp; section &lt; items.count else &#123; return 0 &#125; return items[section].count &#125; public func item(at indexPath: IndexPath) -&gt; T? &#123; guard indexPath.section &gt;= 0 &amp;&amp; indexPath.section &lt; items.count &amp;&amp; indexPath.row &gt;= 0 &amp;&amp; indexPath.row &lt; items[indexPath.section].count else &#123; return items[indexPath.section][indexPath.row] &#125; return nil &#125; public func updateItem(at indexPath: IndexPath, value: T) &#123; guard indexPath.section &gt;= 0 &amp;&amp; indexPath.section &lt; items.count &amp;&amp; indexPath.row &gt;= 0 &amp;&amp; indexPath.row &lt; items[indexPath.section].count else &#123; return &#125; items[indexPath.section][indexPath.row] = value &#125;&#125; 这样做可以提取访问数据源的细节，线性数据结构可以表示 cell 的内容是最常见的使用情况。 封装到一块: CollectionArrayDataSource这样 CollectionDataProvider 协议就具体实现了，创建一个 CollectionDataSource 子类来实现最常见的简单的列表数据展示是非常容易的。 让我们从这个类的定义开始： 123open class CollectionArrayDataSource&lt;T, Cell: UICollectionViewCell&gt;: CollectionDataSource&lt;ArrayDataProvider&lt;T&gt;, Cell&gt; where Cell: ConfigurableCell, Cell.T == T &#123; [...] &#125; 这个声明定义了很多事情： 这个类有一个公有的属性，因为它最终将被扩展为 UICollectionView 对象的数据源对象。 这是一个继承 UICollectionViewCell 的泛型类，需要被特定的类型 T 进一步定义才能正确展示 cell 和 cell 的内容。 这个类扩展了 CollectionDataSource 来提供进一步的特定行为。 特定类型 T 将被表示，它将通过一个 ArrayDataProvider &lt; T &gt; 对象来访问 cell 内容。 这个类在 closure 中的定义表明有些特定的约束: UICollectionViewCell 必须遵循 ConfigurableCell 协议。（ Cell: ConfigurableCell ） cell 中的特定类型 T 必须跟 Provider 的 T 相同 (Provider.T == Cell.T) 。 类的实现非常简单： 123456789101112131415161718// MARK: - Lifecyclepublic convenience init(collectionView: UICollectionView, array: [T]) &#123; self.init(collectionView: collectionView, array: [array])&#125;public init(collectionView: UICollectionView, array: [[T]]) &#123; let provider = ArrayDataProvider(array: array) super.init(collectionView: collectionView, provider: provider)&#125;// MARK: - Public Methodspublic func item(at indexPath: IndexPath) -&gt; T? &#123; return provider.item(at: indexPath)&#125;public func updateItem(at indexPath: IndexPath, value: T) &#123; provider.updateItem(at: indexPath, value: value)&#125; 它只是提供了一些初始化方法和与交互方法，这些方法使我们能够让数据提供者与数据源透明地进行读取和写入操作。 创建一个基本的 CollectionView可以将 CollectionArrayDataSource 基类扩展，为任何可以用二维数组展示的 collection view 创建一个特定的数据源。 1class PhotosDataSource: CollectionArrayDataSource&lt;PhotoViewModel, PhotoCell&gt; &#123;&#125; 声明比较简单: 继承于 CollectionArrayDataSource 。 这个类表示 PhotoViewModel 作为特定类型 T 将会展示 cell 内容，可通过 ArrayDataProvider &lt; PhotoViewModel > 对象访问，PhotoCell 将作为 UICollectionViewCell 展示。 请注意，PhotoCell 必须遵守 ConfigurableCell 协议，并且能够通过 PhotoViewModel 实例初始化它的属性。 创建一个 PhotosDataSource 对象是非常简单的。只需要传递过去将要展示的 collectionView 和由展示每个 cell 内容的 PhotoViewModel 元素组成的数组： 1let dataSource = PhotosDataSource(collectionView: collectionView, array: viewModels) collectionView 参数通常是 storyboard 上的 collectionView 通过 outlet 指向获取到的。 所有的就完成了！两行代码就可以设置一个基本的 collectionView 数据源。 设置带有组标题和组的 CollectionView对于更高级和复杂的用例，你可以简单在 GitHub repo 上查看 TaskList 。内容已经很长了，本文就不再不介绍示例的更多细节。我将在下一篇 “Collection View with Headers and Sections” 文章里进行深入地探讨。在这个说明中，如果存在一个话题对你来说很有意思，请不要犹豫让我知道，这样我就可以优先考虑下一步写什么。为了和我联系，请在这篇文章下方留言或发邮件给我: andrea.prearo@gmail.com 。 结论在这篇文章中，我介绍了一些我做的抽取封装，以简化使用泛型数据源的 collectionView 。所提出的实现都是基于我在构建 iOS app 时遇到的重复代码的场景。一些更高级的的功能可能需要进一步的自定义。我相信，继续优化所得到的代码抽取，或者构建新的代码抽取，来简化处理不同的 collectionView 模式都是可能的。但这已经超出了这篇文章的范围。 所有的通用数据源代码和示例工程都在 GitHub 并且是遵守 MIT 协议的。你可以直接使用和修改它们。欢迎所有的反馈意见和建议的贡献，并非常感谢你这么做。如果你有足够的兴趣，我将很乐意添加所需的配置，使代码与Cocoapods和Carthage一起使用，并允许使用这种依赖关系管理工具导入通用数据源。或者，这可能是一个很好的起点去为这个项目做出贡献。 额外链接 Smooth Scrolling in UITableView and UICollectionView Boost Smooth Scrolling with iOS 10 Pre-Fetching API 披露声明：这些意见是作者的意见。 除非在文章中额外声明，否则 Capital One 版权不属于任何所提及的公司，也不属于任何上述公司。 使用或显示的所有商标和其他知识产权均为其各自所有者的所有权。 本文版权为 ©2017 Capital One 更多关于 API、开源、社区活动或开发文化的信息，请访问我们的一站式开发网站 developer.capitalone.com 。 译文出自：掘金翻译计划 译者： Swants 校对者： iOSleep]]></content>
  </entry>
  <entry>
    <title><![CDATA[开发者眼中 iOS 11 都更新了什么？]]></title>
    <url>%2F2017%2F07%2F07%2F%E5%BC%80%E5%8F%91%E8%80%85%E7%9C%BC%E4%B8%AD-iOS-11-%E9%83%BD%E6%9B%B4%E6%96%B0%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F.html</url>
    <content type="text"><![CDATA[苹果在 2017 年全球开发者大会上公布了 iOS 11 , 其加入许多强大的功能，如 Core ML,ARKit,Vision,PDFKit,MusicKit 拖放等等。 我尝试着把主要变化在接下来的文章里总结了出来，并在可行的地方提供代码，这样你就可以直接上手。 注意： 有些地方没涉及到并不是因为懒，我已经尽我所能提供足够多的代码来帮你在应用上快速上手这些特性。但是你最终还是免不了去额外了解更多 iOS 11 中大量复杂的设计功能。 在接着读下去之前，你可能需要了解下这几篇文章： What’s new in Swift 4? What’s new in Swift 3.1? What’s new in iOS 10? What’s new in iOS 9? 你可能想购买我的新书：《 Practical iOS 11 》。 你可以通过教程的形式获得 7 个完整的项目代码，以及更多深入了解特定新技术的技术项目 - 这是熟悉 iOS 11最快的方式！ Buy Practical iOS 11 for $30 拖放拖放是我们在桌面操作系统中认为理所当然的操作，但是拖放在 iOS 上直到 iOS 11 才出现，这真的阻碍了多任务处理的发展。换句话说，在 iOS 11 上尤其是在 iPad 上，多任务处理迎来了高速发展的时代。得益于拖放成为其中很大的一部分：你可以在 APP 内部和或 APP 之间移动内容，当你拖放的时候你可以用另一只手对其他 app 进行操作.你甚至可以利用 全新的 dock 系统来激活其他 app 的中间拖动。 注意： 在 iPhone 上拖放被限制在单个 app 内 —— 你不能把内容拖放到其他 app 里。 令人欣喜的是，UITableView 和 UICollectionView 在一定程度上都支持拖拽内置。但是想要使用拖放功能仍旧需要写相当多的代码。你也可以向其他组件添加拖放支持，而且你会发现实际上这只需要少量的工作。 下面让我们来看看如何使用简单的拖放来实现在两个列表之间拷贝行内容。首先，我们需要使用一个简单的 app 。让我们写一些代码来创建两个有示例数据的 tableview 供我们拷贝。 在 Xcode 内创建一个新的单一视图 app 模板，然后打开 ViewController.swift 类进行编辑。 现在我们需要在这里放上两个含有示例数据的 tableView 。我不打算使用 IB 的方式布局， 因为全部使用代码来实现是更清楚的。顺便提一下，我 不打算 详细地解释代码，因为这都是现成的 iOS 代码，我不想浪费你的时间。 这些代码将： 创建两个 tableView ,并且创建两个分别包含Left 和 Right 元素的字符串数组。 制定两个 tableView 都使用 view controller 来作为它们的数据源，给他们写死位置宽高，注册一个可重用的 cell ，把它们两个都添加到这个 view 上。 实现 numberOfRowsInSection 方法，确保每个 table view 都根据其字符串数组有正确的行数。 实现 cellForRowAt 来排列，这时 cell根据 table 来从两个字符串数组中选出对应的数据源正确展示。 然后，这是 iOS 11 之前的所有代码，应该没有你不熟悉的代码。将 ViewController.swift 类的内容用下面的代码替换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import UIKitclass ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate &#123; var leftTableView = UITableView() var rightTableView = UITableView() var leftItems = [String](repeating: "Left", count: 20) var rightItems = [String](repeating: "Right", count: 20) override func viewDidLoad() &#123; super.viewDidLoad() leftTableView.dataSource = self rightTableView.dataSource = self leftTableView.frame = CGRect(x: 0, y: 40, width: 150, height: 400) rightTableView.frame = CGRect(x: 150, y: 40, width: 150, height: 400) leftTableView.register(UITableViewCell.self, forCellReuseIdentifier: "Cell") rightTableView.register(UITableViewCell.self, forCellReuseIdentifier: "Cell") view.addSubview(leftTableView) view.addSubview(rightTableView) &#125; func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; if tableView == leftTableView &#123; return leftItems.count &#125; else &#123; return rightItems.count &#125; &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: "Cell", for: indexPath) if tableView == leftTableView &#123; cell.textLabel?.text = leftItems[indexPath.row] &#125; else &#123; cell.textLabel?.text = rightItems[indexPath.row] &#125; return cell &#125;&#125; 好：下面就是 新 的内容了。如果你现在运行 app 你就会看到两个并列并且填满数据的 tableView 。我们现在想要做的就是让用户可以从一个 table 上选择一行并且复制到另一个 table 里，或者反方向操作。 第一步就是就是设置两个 tableView 的拖和放操作的代理为当前 view controller ，再把它们设置为可拖放。 最后把下面的代码加入到 viewDidLoad() 方法里： 1234567leftTableView.dragDelegate = selfleftTableView.dropDelegate = selfrightTableView.dragDelegate = selfrightTableView.dropDelegate = selfleftTableView.dragInteractionEnabled = truerightTableView.dragInteractionEnabled = true 当你做完这些后，Xcode 会抛出几个警告，因为我们当前的控制器类没有遵从 UITableViewDragDelegate 和 UITableViewDropDelegate 协议。通过给我们的类添加这两个协议很容易就修复这些警告了 —— 滚动到文件的最顶端并且改变类的定义： 1class ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate, UITableViewDragDelegate, UITableViewDropDelegate &#123; 但是这样又会产生新的问题：我说过我们应该遵从这两个新协议，但是我们没有实现协议必须实现的方法，在过去修复这个常常是很麻烦的，但是 Xcode 9 可以自动完成这几个协议必须实现的方法 —— 点击报红色高亮代码行上的数字 2，这时你将会看到出现了更多的详细解释。点击 “fix” 来让 Xcode 9 为我们插入两个缺少的方法 —— 你将会看到你的类里边出现了下面的代码： 1234567func tableView(_ tableView: UITableView, itemsForBeginning session: UIDragSession, at indexPath: IndexPath) -&gt; [UIDragItem] &#123; code&#125;func tableView(_ tableView: UITableView, performDropWith coordinator: UITableViewDropCoordinator) &#123; code&#125; Xcode 总是把新的方法插在你的类最上面，至少在这次初始的 beta 版本里是。如果你和我一样看这不顺眼 —— 在继续之前可以把它们移到更明智地方！ itemsForBeginning 方法是最简单的，让我们先从它开始。这个方法是在当用户的手指在 tableView 某行 cell 上按下执行拖的操作的时候调用。如果你返回一个空数组，你实际上就是拒绝了拖放操作。 我们打算为这个方法添加四行代码： 指出哪一个字符串被拷贝，我们可以使用一个简单的三元操作符来实现：如果当前的 tableView 是在左边就从 leftItems 中读取，否则就从 rightItems 中读取。 试着将这个字符串转换成一个 Data 对象， 以便可以通过拖放进行传递。 将这个 data 放进一个 NSItemProvider 中，并且标记为存储了一个纯文本字符串从而其他 app 可以知道如何去处理它。 最后， 把这个 NSItemProvider 放进一个 UIDragItem内，从而它可以用于 UIKit 的拖放。 为了把 data 元素标记为纯文本字符串 我们需要引入 MobileCoreServices 框架，所以请把下面的代码加入到 ViewController.swift 文件最上面： 1import MobileCoreServices 现在用下面的代码替换你的 itemsForBeginning 方法： 1234567func tableView(_ tableView: UITableView, itemsForBeginning session: UIDragSession, at indexPath: IndexPath) -&gt; [UIDragItem] &#123; let string = tableView == leftTableView ? leftItems[indexPath.row] : rightItems[indexPath.row] guard let data = string.data(using: .utf8) else &#123; return [] &#125; let itemProvider = NSItemProvider(item: data as NSData, typeIdentifier: kUTTypePlainText as String) return [UIDragItem(itemProvider: itemProvider)]&#125; 接下来我们只需要实现 performDropWith 方法。我说 “只需要”，但是剩下的两个潜在的复杂问题还是很棘手的。首先，如果有人拖放了很多东西我们就会同时获得很多字符串，我们需要把它们都正确插入。其次，我们可能被告知用户想要插入到哪几行，也可能不被告知 —— 用户可能只是把字符串拖放到 tableView 的空白处，这时需要我们决定该怎么处理。 要解决这两个问题需要写比你期望中的更多的代码，但我会带你一步一步编写代码，让它更容易些。 首先，是最简单的部分：找出行被拖放到哪里。 performDropWith 返回一个 UITableViewDropCoordinator 类对象，该对象有一个 destinationIndexPath 属性 可以告诉我们用户想把数据拖放到哪里。然而 这个方法是 可选 实现：如果用户把他们的数据拖放到我们 tableView 的空单元格上，方法返回的将会是 nil 。如果这真的发生了我们会认为用户是想把数据拖放到 table 的最尾部。 所以，把下面的代码添加到 performDropWith 方法内继续吧： 123456789let destinationIndexPath: IndexPathif let indexPath = coordinator.destinationIndexPath &#123; destinationIndexPath = indexPath&#125; else &#123; let section = tableView.numberOfSections - 1 let row = tableView.numberOfRows(inSection: section) destinationIndexPath = IndexPath(row: row, section: section)&#125; 正如你所看到的那样，如果 coordinator 的 destinationIndexPath 存在就直接用，如果不存在则创建一个最后一组最后一行的 destinationIndexPath 。 下一步就是让拖放的 coordinator 来加载拖动的所有特定类对象。在我们的例子里这个特定类是 NSString 。（然而，通常用 String 不起作用。）当所有拷贝的内容都就绪时我们需要发送一个闭包来运行，这也是最复杂的地方：我们需要把内容一个接一个地在目标行下面插入，修改 leftItems 或 rightItems 数组，最后调用我们 tableView 的 insertRows() 方法来展示拷贝后的结果。 那么，接下来：我们刚刚写了一些代码来指出拖放操作最终的目标行。但如果我们得到了 多个 拷贝对象，那么我们所有的都是初始的 destination index path —— 第一个拷贝对象的目标行就是它，第二个拷贝对象的目标行比它低一行，第三个拷贝对象的目标行比它低两行，等等。当我们移动每个拷贝对象时，我们会创建一个新的 index path 并且把它暂存到一个 indexPaths 数组中，这样我们就可以让 tableView 只调用一次 insertRows() 方法就完成了全部插入操作 。 把代码添加到你的 performDropWith 方法中，放在我们刚才写的代码下面： 123456789101112131415161718192021222324252627// attempt to load strings from the drop coordinatorcoordinator.session.loadObjects(ofClass: NSString.self) &#123; items in // convert the item provider array to a string array or bail out guard let strings = items as? [String] else &#123; return &#125; // create an empty array to track rows we've copied var indexPaths = [IndexPath]() // loop over all the strings we received for (index, string) in strings.enumerated() &#123; // create an index path for this new row, moving it down depending on how many we've already inserted let indexPath = IndexPath(row: destinationIndexPath.row + index, section: destinationIndexPath.section) // insert the copy into the correct array if tableView == self.leftTableView &#123; self.leftItems.insert(string, at: indexPath.row) &#125; else &#123; self.rightItems.insert(string, at: indexPath.row) &#125; // keep track of this new row indexPaths.append(indexPath) &#125; // insert them all into the table view at once tableView.insertRows(at: indexPaths, with: .automatic)&#125; 这就是完成的所有代码了 —— 你现在能够运行这个 app 并且在两个 tableView 之间拖动行内容来完成拷贝。完成这个花费了这么多的工作量，但令人感到惊喜的是：你所做的这些工作你能够支持整个系统的拖放：譬如如果你试着用 iPad 模拟器的话，你就会发现你可以把这些文本拖放到 Apple News 内的任何一个列表上，或者把 tableView 上的文本拖放到 Safari 的搜索条上。非常酷！ 在你试着去完成拖放操作之前，我想再展示一件事：如何实现为其他 View 添加拖放支持。其实比在 tableView 上实现要容易，那就让我们快速做一遍吧。 在开始之前，我们需要一个简单的控件来让我们有可以添加拖放的东西。这次我们打算创建一个 UIImageView 并且渲染一个简单的红色圆圈作为图片。你可以保留已存在的单视图 APP 模板 并把 ViewController.swift 的内容用新代码替换： 1234567891011121314151617181920212223import UIKitclass ViewController: UIViewController &#123; // create a property for our image view and define its size var imageView: UIImageView! let size = 512 override func viewDidLoad() &#123; super.viewDidLoad() // create and add the image view imageView = UIImageView(frame: CGRect(x: 50, y: 50, width: size, height: size)) view.addSubview(imageView) // render a red circle at the same size, and use it in the image view let renderer = UIGraphicsImageRenderer(size: CGSize(width: size, height: size)) imageView.image = renderer.image &#123; ctx in let rectangle = CGRect(x: 0, y: 0, width: size, height: size) ctx.cgContext.setFillColor(UIColor.red.cgColor) ctx.cgContext.fillEllipse(in: rectangle) &#125; &#125;&#125; 像之前一样，这都是些 iOS 的老代码所以我不打算给你详细解释它。如果你试着在 iPad 模拟器上运行，你就会在控制器里看到一个大的红色圆圈 —— 这对供我们测试来说足够了。 自定义视图的拖放是通过一个新的叫作 UIDragInteraction 类来实现的。 你告诉它在哪里发送信息（在我们这个例子里，我们用的是当前的控制器），然后将它和用来交互的 View 绑定。 重要提示： 千万不要忘了打开相关视图的交互，否则当拖放最后不起作用时，你会感到非常困惑。 首先， 在 viewDidLoad() 的最末尾添加这三行代码，就在之前的代码后面。你就会看到 Xcode 提示我们的 View Controller 没有遵循UIDragInteractionDelegate 协议，所以把类的定义改成下面这样： 1class ViewController: UIViewController, UIDragInteractionDelegate &#123; Xcode 将会继续提示我们没有实现 UIDragInteractionDelegate 协议的一个必要方法，所以重复之前我们所做的 —— 在出错行上单击错误提示，然后选择 “Fix” 来插入下面的代码： 123func dragInteraction(_ interaction: UIDragInteraction, itemsForBeginning session: UIDragSession) -&gt; [UIDragItem] &#123; code&#125; 这就像我们之前为我们的 tableView 实现的 itemsForBeginning 方法一样：当用户开始拖动我们的 imageView 的时候，我们需要返回我们想要分享的图像。 这些代码是非常好并且简单的：我们会使用 guard 来防止我们在 imageView 上拉取图片时出现问题，先用一个 NSItemProvider 包装 image，然后返回数据的时候再使用 UIDragItem 包装下。 将 itemsForBeginning 方法用下面的代码替换： 123456func dragInteraction(_ interaction: UIDragInteraction, itemsForBeginning session: UIDragSession) -&gt; [UIDragItem] &#123; guard let image = imageView.image else &#123; return [] &#125; let provider = NSItemProvider(object: image) let item = UIDragItem(itemProvider: provider) return [item]&#125; 这就完成了！ 尝试使用 ipad 多任务处理功能来将图库放在屏幕的右端 —— 你能够通过拖放图片来将图片从你的 APP 拷贝到图库里。 增强现实增强现实 (AR) 已经出现有一段时间了，但是苹果在 iOS 11 上做了一些可圈可点的事情：他们创造了一个卓越的实现就是让 AR 开发可以和现有的游戏开发技术无缝集成。这就意味着你不需要做太多的工作就能把你 SpriteKit 或 SceneKit 技能和 AR 集成起来，这是个非常诱人的前景。 Xcode 自带了一个非常棒可以立即使用的 ARKit 模板，因此我鼓励你去尝试一下 —— 你会惊奇地发现实现它是多么的容易！ 我想快速地演示下模板的使用，这样你就可以了解到这一切是如何融合在一起的。首先，使用虚拟现实模板创建一个新的 Xcode 工程，然后选择 SpriteKit 作为内容技术。是的，SpriteKit 是一个 2D 框架，但它仍能够在 ARKit 中用得很好，因为它可以像 3D 一样通过扭曲或旋转来展示你的精灵。 如果你打开了 Main.storyboard ，你会发现这个 ARKit 模板与普通的 SpriteKit 模板有所不同：它使用了一个新的 ARSKView 界面对象，将 ARKit 和 SpriteKit 两个世界融合在一起。这个对象通过一个 outlet 和 ViewController.swift 连接在一起，在这个控制器中的 viewWillAppear() 方法中构建 AR 追踪，并在 viewWillDisappear() 方法中暂停追踪。 但是，真正起作用的是在两个地方：Scene.swift 文件的 touchesBegan() 方法内，和 ViewController.swift 文件的 nodeFor 方法。 在通常的 SpriteKit 中你创建节点并把节点直接添加到你的场景中，但是使用 ARKit 后创建的是 锚点 —— 包含场景位置和标识符的占位，但它没有实际的内容。根据需要的时候使用 nodeFor 方法转换为 SpriteKit 节点。如果你曾使用过 MKMapView ，会发现这和 MKMapView 添加大头针和标注的方式是类似的 —— 标注是你的模型数据，大头针是 view。 在 Scene.swift 类的 touchesBegan() 方法你会看到从 ARKit 拉出当前帧的代码，先计算放入一个新敌人的位置。这是通过矩阵乘法实现：如果你创建一个单位矩阵（表示位置 X:0, Y:0, Z:0 的东西），再将它的 Z 坐标移回 0.2（相当于 0.2 米），你可以乘以当前场景相机位置来实现向用户指向的方向移动。 所以，当用户指向前方锚点就会被放在前方，如果他们指向上方，锚点就会放在上方。一旦锚点被放在那，它就会呆在那：ARKit 将会自动移动，旋转或扭曲来确保当用户的设备移动时与锚点始终正确对齐。 所有的操作可以用三行代码来实现： 123var translation = matrix_identity_float4x4translation.columns.3.z = -0.2let transform = simd_mul(currentFrame.camera.transform, translation) 一旦计算出来转换，位移就会包装成一个锚点并添加到回话中，就像这样： 12let anchor = ARAnchor(transform: transform)sceneView.session.add(anchor: anchor) 最后会调用 ViewController.swift 类的 nodeFor 方法。之所以会调用是因为当前 ViewController 被设置成了 ARSKView 的代理，当前 ViewController 就会在需要的时候负责把锚点转换成节点。你 不需要 担心定位这些节点：记住，锚点已经放置到真实世界的具体坐标上了，ARKit 负责映射锚点的位置并转换成 SpriteKit 节点。 总之，nodeFor 方法很简单： 1234567func view(_ view: ARSKView, nodeFor anchor: ARAnchor) -&gt; SKNode? &#123; // Create and configure a node for the anchor added to the view's session. let labelNode = SKLabelNode(text: "Enemy") labelNode.horizontalAlignmentMode = .center labelNode.verticalAlignmentMode = .center return labelNode;&#125; 如果你想知道，ARKit 锚点有一个 identifier 属性可以让你知道创建了什么样的节点。在 Xcode 模板中所有的节点都是未知的。但是在你自己的工程中你几乎肯定会想把事物唯一标识出来。 就是这些！这么少的代码带来的结果是非常有效的 —— ARKit 注定是一个大的飞跃。 插播广告如果你喜欢这篇文章，你可能对我新写的 iOS 11 实践教程新书感兴趣。你将会实际开发基于 Core ML , PDFView , ARKit , 拖拽等更多新技术的工程。 —— 这是学习 iOS 11 最快的方式！ Buy Practical iOS 11 for $30 PDF 渲染自从 OS X 10.4 开始受益于几乎不需要提供任何代码就可以提供 PDF 渲染，操作，标注甚至更多的 PDFKit 框架后，macOS 就始终对 PDF 渲染有着一流的支持。 至于，到了 iOS 11 也可以在系统中使用 PDF 框架的全部功能了：你可以使用 PDFView 类来显示 PDF，让用户浏览文档，选择并且分享内容，放大缩小等等操作。或者，你可以使用独立的类比如： PDFDocument , PDFPage 和 PDFAnnotation 来创建你自己自定义的 PDF 阅读器。 和拖放一样，我们可以创建一个简单的 app 来演示 PDFKIT 是多么的简单。如果你愿意的话，你可以继续使用你刚才创建的单视图 app 工程，但你需要向工程中导入一个 PDF 文件来供 PDFKit 去读取。 你需要学习两个新的比较小的类来编写代码，第一个是 PDFView ，它负责所有的负责工作，包括 PDF 渲染，滚动和缩放手势响应，选择文本等。它也是 iOS 系统中常见的 UIView 子类，所以你可以不使用任何参数地创建 PDFView 实例对象，然后使用自动布局来约束它的位置来满足你的需求。第二个是新的类是 PDFDocument ，它可以通过一个 URL 来加载一个在其他地方可以被渲染或者操作 PDF 文档。 把 ViewController.swift 类的全部代码用这个代替： 1234567891011121314151617181920212223242526import PDFKitimport UIKitclass ViewController: UIViewController &#123; // store our PDFView in a property so we can manipulate it later var pdfView: PDFView! override func viewDidLoad() &#123; super.viewDidLoad() // create and add the PDF view pdfView = PDFView() pdfView.translatesAutoresizingMaskIntoConstraints = false view.addSubview(pdfView) // make it take up the full screen pdfView.leadingAnchor.constraint(equalTo: view.leadingAnchor).isActive = true pdfView.trailingAnchor.constraint(equalTo: view.trailingAnchor).isActive = true pdfView.topAnchor.constraint(equalTo: view.topAnchor).isActive = true pdfView.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive = true // load our example PDF and make it display immediately let url = Bundle.main.url(forResource: "your-pdf-name-here", withExtension: "pdf")! pdfView.document = PDFDocument(url: url) &#125;&#125; 如果运行 app 你应该可以看到你可以使用连续的滚动机制垂直滚动页面。如果你在真机上测试，你也可以通过捏合操作进行缩放 —— 这时你就会发现 PDF 以更高的分辨率重新渲染。如果你想要更改 PDF 的布局样式，你可以试着去设置 displayMode, displayDirection, 和 displaysAsBook 属性。 例如，你可以将页面以双页的模式展现，而封面默认就是这样的： 12pdfView.displayMode = .twoUpContinuouspdfView.displaysAsBook = true PDFView 提供了一系列有用的方法来让用户浏览和操作 PDF。为了试验，我们会在我们的控制器上添加一些导航栏按钮，因为这是添加交互最简单的方式。 总共三步，我们先添加一个 navigation controller， 这样我们就有了一个现成的导航栏来使用。所以，打开你的 Main.storyboard ，在大纲视图里选中 View Controller Scene 。再进入编辑菜单选择 Embed In &gt; Navigation Controller 。 接下来，在 ViewController.swift 中的 viewDidLoad() 方法中添加以下代码： 12345let printSelectionBtn = UIBarButtonItem(title: "Selection", style: .plain, target: self, action: #selector(printSelection))let firstPageBtn = UIBarButtonItem(title: "First", style: .plain, target: self, action: #selector(firstPage))let lastPageBtn = UIBarButtonItem(title: "Last", style: .plain, target: self, action: #selector(lastPage))navigationItem.rightBarButtonItems = [printSelectionBtn, firstPageBtn, lastPageBtn] 这些代码添加了三个按钮来实现一些基本的功能。最后，我们只需要写这三个按钮的响应方法就好了，那么把下面这些方法添加到 ViewController 类中： 1234567891011func printSelection() &#123; print(pdfView.currentSelection ?? "No selection")&#125;func firstPage() &#123; pdfView.goToFirstPage(nil)&#125;func lastPage() &#123; pdfView.goToLastPage(nil)&#125; 现在，如果是在 Swift 3 下，我们可以这么做。但是到了 Swift 4 你将会看到报 “Argument of ‘#selector’ refers to instance method ‘firstPage()’ that is not exposed to Objective-C” 错误。换句话说就是 Swift 的方法对 Objective-C 不可见的，而 UIBarButtonItem 是 Objective-C 代码实现。 当然在每个方法之前加上 @objc 是个有效的办法，我猜大部分人可能就耸耸肩（我有什么办法，我也很绝望啊），然后在类之前加上一个 @objcMembers 的定义 —— 这会像之前 Swift 3 那样自动将类的所有东西都暴露给 Objective-C 。所以，把类的定义修改成这样： 12@objcMembersclass ViewController: UIViewController &#123; 现在这就正确地编译了，现在你将会看到跳转到首页和末页的功能可以直接使用了。至于选择按钮，你只需要在点击按钮之前在 PDF 之前选择一些文本 —— 就像在 iBooks 进行文本选择操作那样。 开始支持 NFC 读取iPhone 7 引入了针对 NFC 的硬件支持，至于 iOS 11，NFC 开始支持让我们在自己的 APP 内使用：你现在可以编写代码来检测附近的 NFC NDEF 标签，而且出乎意料地简单 —— 至少在 代码层面 。然而在我们看代码之前，你需要绕过一些坑，所有的我都希望在正式版消失。 Step 1: 在 Xcode 里创建一个新的 单视图 APP 模板。 Step 2: 去 iTunes 配置网站 https://developer.apple.com/account 为你的 APP 创建一个 包含 NFC 标签读取的 APP ID。 Step 3: 为这个 APP ID 创建一个描述文件，并将其安装到 Xcode 中。取消 “Automatically manage signing” 选项卡，并且选择你刚才安装的描述文件。你可以点击描述文件旁边的小 “i” 按钮来在权限列表里查看 “com.apple.developer.nfc.readersession.formats”。 Step 4: 使用 快捷键 Cmd+N 为工程添加一个新的文件，先选择属性列表。把它命名为 “Entitlements.entitlements” ，并且确保 “Group” 旁边有一个蓝色的图标。 Step 5: 打开 Entitlements.entitlements 进行编辑，右击空白处选择 “Add Row”。键值为 “com.apple.developer.nfc.readersession.formats” 并把它的类型改为数组。点击 “com.apple.developer.nfc.readersession.formats” 左侧的指示箭头，再点击右边的 + 标记。这时应该会插入一个带有空值的 “Item 0” 键 —— 把它的值改为 “NDEF”。 Step 6: 定位到你的 target 的 build settings 找到 Code Signing Entitlements 。在文本框里填入 “Entitlements.entitlements” 。 Step 7: 打开你的 Info.plist 文件，再右击空白处选择 “Add Row” 。添加键为 “Privacy - NFC Scan Usage Description” ，值为 “SwiftyNFC” 。 是的，就是一团糟。我不知道为什么——能够扫描 NFC 几乎没有比访问某人的健康记录更私密，而且更容易做到。在你思考恶意应用会不会暗地里扫描 NFC 之前，还是省省吧：就像刚才看到的那样，这是根本不可能做到的。 在混乱的设置之后，很高兴地告诉你使 NFC 工作的代码几乎是微不足道的：创建一个属性来存储一个代表当前 NFC 扫描会话的 NFCNDEFReaderSession 对象，再创建这个对象并要求它开始扫描。 当你创建读取会话时，你需要给它提供三条数据：它能够发送信息的代理，它应该用于发送这些消息的队列和当它扫描到一个 NFC 标签的时候是否结束扫描。我们会用 self 作为代理，DispatchQueue.main 作为队列，将值设置为 false 当扫描到一个标签后不停止扫描，所以它会继续扫描直到60秒结束。 打开 ViewController.swift，导入 CoreNFC，再把这个属性添加到 ViewController 类： 1var session: NFCNDEFReaderSession! 接下来,在 viewDidLoad() 方法中添加这两行代码： 12session = NFCNDEFReaderSession(delegate: self, queue: DispatchQueue.main, invalidateAfterFirstRead: false)session.begin() ViewController 现在还没有正确地遵循 NFCNDEFReaderSessionDelegate 协议，你需要修改你的类定义来包含它： 1class ViewController: UIViewController, NFCNDEFReaderSessionDelegate &#123; 按照惯例，Xcode 将会报你缺失一些必要方法的错，所以使用它建议的修复来插入下面这两个方法： 1234567func readerSession(_ session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage]) &#123; code&#125;func readerSession(_ session: NFCNDEFReaderSession, didInvalidateWithError error: Error) &#123; code&#125; 两个方法都是特别简单的，但是错误的处理也非常简单——我们只是把错误打印到 Xcode 的控制台。在 didInvalidateWithError 方法内像这样添加内容： 123func readerSession(_ session: NFCNDEFReaderSession, didInvalidateWithError error: Error) &#123; print(error.localizedDescription)&#125; 现在对于 didDetectNDEFs 方法。当它被调用的时候你会得到一个检测到的消息的数组，数组每一个元素都可以包含描述单个数据的一个或更多记录。例如，你可能会看到 NFC 被用作启动 Google Cardboard app: Cardboard 设备有一个简单的包含绝对 URL “cardboard://V1.0.0” 的 NFC 标签，当设备检测到标签后会唤起 APP 显示。 用 NFC 数据的处理就是你需要做的事了，我们只是把他打印出来了，把你的 didDetectNDEFs 修改成这样： 123456789func readerSession(_ session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage]) &#123; for message in messages &#123; for record in message.records &#123; if let string = String(data: record.payload, encoding: .ascii) &#123; print(string) &#125; &#125; &#125;&#125; 所有的代码就完成了，那么继续开始运行这个 app 吧！如果所有的部分都起作用了，你将立即看到系统用户界面出现提示用户将其设备靠近要扫描的位置。这就是为什么恶意应用程序滥用 NFC 扫描是不可能的 - 不仅我们无法控制用户界面，而且 60 秒后扫描也会因为超时结束以避免浪费电量。 机器学习和视觉识别机器学习是现在最时髦的流行语，就是让计算机根据过去接触到的处理规则来适应新的数据。比如，如果你只有一张吉他画和一个空的 Swift 类，那么”这幅画中有吉他吗？“是个非常难回答的问题，但是如果你使用大量包含吉他的图片样本来构建一个训练模型，这时你就可以有效地训练计算机识别出包含吉他的新图像。 听上去很无聊，但实际上是 iOS 11 上大量的先进技术的基础：Siri，照相机，Quick Type 都使用了机器学习来帮助它们更好的理解我们所在的世界。iOS 11 还引入了一个新的 Vision 框架，这是一个从 Core Image ，机器学习功能和所有新技术组成的一个有点模糊的组合。 在 iOS 11 里所有的这些都是由一个叫做 Core ML 的机器学习框架提供，该框架旨在支持各种各样的模型，而不仅仅是识别图像。信不信由你，编写 Core ML 的代码是很少的，然而这只是事情的一面。 你清楚的，Core ML 需要训练模型才能工作，而模型是用算法在大量数据训练得出的。这些模型可以从几千字节到数百兆字节甚至更多，而且明显需要一定的专业知识才能训练，特别是当你处理图像识别的时候。令人欣喜的是，苹果提供了一些可以用来快速上手和运行的模型，所以如果你只是想要尝试下使用 Core ML ，实际上是非常简单的。 难过的是，还有事情还有另外一面：第三方框架总是非常恶心的，你明白的，Core ML 模型为我们自动生成接收一些输入数据并返回一些输出数据的代码 - 这部分是非常友好的。但悲伤的是，处理图像时所需的输入数据不是 “UIImage”，也不是 “CGImage”，更不是 “CIImage” 。 相反，苹果选择让我们使用 “CVPixelBuffer” 输入。CVPixelBuffer 放进我的代码中就像血友病聚会上来了头豪猪一样不受欢迎。没有把 UIImage 转换为 CVPixelBuffer 的完美有效的方法，我是很有资格说的，因为我浪费了几个小时来寻求解决方案。幸运的是 Chris Cieslak 非常慷慨把他的代码分享给我，在他的 WTFPL 下转换是非常有效的，所以你也可以使用它进行转换。 现在让我们尝试下 Core ML 吧。先创建一个新的单视图 APP 工程（或者继续使用你现有的工程），再在工程里添加一张图片 —— 我添加的是维基百科里的 华盛顿杜勒斯国际机场 。把这张图片重命名为 “test.jpg” 以避免拼写错误。 现在我们有一些输入测试，我们需要添加一个训练好的模型。它可能没有看到过我们确切的照片，但它需要接触些类似的图片以便识别出这个机场。苹果在 https://developer.apple.com/machine-learning 上提供了一些预配置的模型 —— 现在进入网站，并下载 “Places205-GoogLeNet” 模型。 模型只有 25MB，所以它不会占用你用户设备上太多空间。 当你下载好模型后，先把它拖到你的 Xcode 工程中，再选择它，这时你就可以看到 Core ML 的模型查看器。你会看到它是由 MIT 制作的神经网络分类器，还有可以根据知识共享许可证使用。在这个下面，你将看到它有 “sceneImage” 作为输入，还有 “sceneLabelProbs ” 和 “sceneLabel” 作为输出 —— 输入一张图片，输出一些计算机识别这张图片的文本描述。 你还将看到 “Model class” 和 “Swift generated source” —— Xcode为我们生成了一个类，只包含几行代码，这一点非常显著，你将很快看到。 现在，我们有一个可以识别的图像和一个可以检查它的训练好的模型。 我们现在需要做的是将两者放在一起：加载图片，为模型准备图片，最后询问模型的预测。 为了使这个代码更容易理解，我把它分成了一些块。 首先，打开 ViewController.swift 并将其修改为： 12345678910111213import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let image = UIImage(named: "test.jpg")! // 1 // 2 // 3 &#125;&#125; 这只是加载我们准备被处理的测试图片。 接下来的步骤是从 “// 1” 开始逐个填写这三个注释。 基于图像的 Core ML 模型要求以精确的尺寸接收图片，这是他们接受过训练的尺寸。 对于 GoogLeNetPlaces 模型尺寸应该是 224 x 224 而其他模型有它们各自的尺寸，而 Core ML 会告诉你是否以错误的尺寸输入了东西。 所以，我们需要的第一件事是缩小我们的图像，让图片恰好是 224 x 224 ，而不管我们是使用视网膜屏设备还是其他的设备。 这可以使用 “UIGraphicsBeginImageContextWithOptions（）” 方法来强制 1.0 的比例。 用下面的代码替换这个 // 1 注释： 12345let modelSize = 224UIGraphicsBeginImageContextWithOptions(CGSize(width: modelSize, height: modelSize), true, 1.0)image.draw(in: CGRect(x: 0, y: 0, width: modelSize, height: modelSize))let newImage = UIGraphicsGetImageFromCurrentImageContext()!UIGraphicsEndImageContext() 这给了我们一个新的叫做 “newImage” 常量，它是一个符合模型中正确尺寸的 “UIImage”。 现在第二部分要做的是从 “UIImage” 到 “CVPixelBuffer” 之间恶心的转换。 因为这是毫无意义的复杂操作，所以我不打算试图解释所有的各个步骤。除了拷贝下面的代码，我不建议你做任何事情。 用下面的代码替换这个 // 2 注释： 123456789101112131415161718let attrs = [kCVPixelBufferCGImageCompatibilityKey: kCFBooleanTrue, kCVPixelBufferCGBitmapContextCompatibilityKey: kCFBooleanTrue] as CFDictionaryvar pixelBuffer : CVPixelBuffer?let status = CVPixelBufferCreate(kCFAllocatorDefault, Int(newImage.size.width), Int(newImage.size.height), kCVPixelFormatType_32ARGB, attrs, &amp;pixelBuffer)guard (status == kCVReturnSuccess) else &#123; return &#125;CVPixelBufferLockBaseAddress(pixelBuffer!, CVPixelBufferLockFlags(rawValue: 0))let pixelData = CVPixelBufferGetBaseAddress(pixelBuffer!)let rgbColorSpace = CGColorSpaceCreateDeviceRGB()let context = CGContext(data: pixelData, width: Int(newImage.size.width), height: Int(newImage.size.height), bitsPerComponent: 8, bytesPerRow: CVPixelBufferGetBytesPerRow(pixelBuffer!), space: rgbColorSpace, bitmapInfo: CGImageAlphaInfo.noneSkipFirst.rawValue)context?.translateBy(x: 0, y: newImage.size.height)context?.scaleBy(x: 1.0, y: -1.0)UIGraphicsPushContext(context!)newImage.draw(in: CGRect(x: 0, y: 0, width: newImage.size.width, height: newImage.size.height))UIGraphicsPopContext()CVPixelBufferUnlockBaseAddress(pixelBuffer!, CVPixelBufferLockFlags(rawValue: 0)) 如果可能使用很多次上面的代码，你可能想要把这些复杂代码封装到一个函数里边。但无论你如何操作，请不要试图去记住它。 现在开始重要的，有趣的和微不足道的部分：实际使用 Core ML 框架，这只有三行代码，相当坦率地说，非常简单。 就像我所说的，Xcode 自动根据 Core ML 模型生成一个 Swift 类，所以我们可以立即实例化一个 “GoogLeNetPlaces” 对象。 最后我们可以将我们的图片缓存传递给它的 “prediction()” 方法，这个方法将返回预测结果或抛出一个错误。 在实践中，你可能会发现使用 `try？’ 更容易获得一个值或是 nil 。 最后，我们将打印出预测结果，以便你了解到 Core ML 的表现。 用下面代码替换替换这个 // 3 注释： 123let model = GoogLeNetPlaces()guard let prediction = try? model.prediction(sceneImage: pixelBuffer!) else &#123; return &#125;print(prediction.sceneLabel) 不管你相不相信，这就是使用 Core ML 的所有代码； 这简单的三行代码做完了所有的工作。 你打印出来的结果取决于你的输入内容和你的训练模型，但 GoogLeNetPlaces 正确地将我的图片识别为机场航站楼，这一切完全在设备上完成 —— 无需将图片发送到远程服务器处理，因此在这个黑盒子里你得到了极好的隐私保护。 更多其他的更新。。。iOS 11 还有大量的其他更新 —— 这些是我最喜欢的： Metal 2 被设置成提高整个系统的图形性能。我没在这提供代码示例是因为这实在是一个高深的话题 —— 大多数人只会很高兴看到他们的 SpriteKit ，SceneKit 和 Unity 应用程序无需额外的工作就可以获得更快的速度。 TableView Cell 现在自动支持自适应。以前都是设置 UITableViewAutomaticDimension 作为行高来触发自适应行为。但现在再也不需要设置了。 TableView 增加了一个 新的基于闭包的 performBatchUpdates() 方法，它可以让你一次性对多行的插入、删除、移动操作进行动画处理，甚至可以在动画完成之后立即执行结束闭包。 在 Apple Music 第一次出现的新的加粗黑标题现在可以再整个系统使用了，同时支持通过一个细小的改动在我们自己的 APP 使用：在 IB 内为我们的导航条选择 “Prefers Large Titles” ，或者如果你更喜欢使用代码的话使用 navigationController?.navigationBar.prefersLargeTitles = true 来设置。 为了支持 safeAreaLayoutGuide topLayoutGuide属性被弃用了。它提供了所有边的边缘而不仅仅是顶部和底部，这可能预示未来的 iPhone 为非矩形布局 —— 带有沉浸式相机的全屏幕 iPhone 8，有人有异议吗？ Stack views 增加了一个 setCustomSpacing(_:after:) 方法，这可以让你在 stack view 添加你想要的而不是统一大小的空白。 接下来就是 XcodeXcode 9 是我见过的最令人兴奋的 Xcode 版本 —— 它充满了令人难以置信的新功能，甚至可以使最坚定的 Xcode 抱怨者重新考虑。 这些是最吸引我的功能更新： 可以在编辑器内进行 Swift 和 Objective-C 的重构，这意味着你只需点击几下鼠标就可以对你的代码进行彻底的更改（例如对方法重命名）。 iOS 和 tvOS 支持无线调试了。为了使用这个功能，先使用 USB 连接你的设备，再在 Window 菜单里选择 Devices and Simulators 。选择你的设备，最后选择 “Connect via network” 。如果第一次不能成功 不必感到惊奇 —— 这还是 beta 1 版本！ 源代码编辑器使用 Swift 进行了重写，带来了滚动和搜索的速度极大的提升。以及一些其他有用的功能，比如按住 Ctrl 键时的范围高亮显示。 你现在可以将命名颜色添加到 asset catalogs，这样你可以定义一次颜色， 在任何地方使用 UIColor(named:) 方法初始化。 默认情况下启用了一个新的主线程检查器，当检测到任何不在主线程上执行的 UIKit 方法调用时，它将自动发出警告 - 这是常见的错误源头。 你现在可以同时运行多个模拟器，甚至可以自由调整它们的大小。 苹果在模拟器周围添加了额外的用户界面，以便我们访问硬件控件。 如果您不想立即使用 Swift 4，则会有一个新的 “Swift Language Version” 构建设置，您可以选择 Swift 4.0 或 Swift 3.2。 两者都使用相同的编译器，但在内部启用不同的选项 认真的，我希望我今年在 WWDC 现场，这样我就给 Xcode 工程师一个熊抱 —— 这是一个炙手可热的版本，让 Xcode 在奔向伟大的路上越行越远。 还在等什么？现在你已经了解了 iOS 11 中的新功能，你也应该看一看我的新书：Practical iOS 11。这是一本用实际项目讲解 iOS 11 中所有主要变化的书籍，拥有它你可以尽可能快地熟悉 iOS 11。 Buy Practical iOS 11 for $30 译文出自：掘金翻译计划 译者： Swants 校对者： Danny1451 RichardLeeH]]></content>
      <tags>
        <tag>iOS 11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[避免使用第三方UI库]]></title>
    <url>%2F2017%2F06%2F15%2F%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9UI%E5%BA%93.html</url>
    <content type="text"><![CDATA[最近 iOS 社区一些人在讨论关于应该 赞成还是反对使用第三方依赖库 (当然, 大部分人持反对意见). 我看到的许多争论的观点都有失偏颇 -它们把所有的第三方库都归于一类混为一谈. 就像大多数事情一样,整体考虑不是那么简单的的事,所以现在让我们将目光放在一个小的观点上: 我们应该避免使用 第三方UI依赖库吗? 考虑使用第三方库的缘由开发者们考虑使用一个第三方库通常有两个主要原因: 缺乏技能或者知识。 比方说,你正在做一款照片分享功能的 app. 你没有从 推出自己的密码 开始。 缺乏从事某件事的时间或者兴趣。 除非你又无限的时间不需要去分清主次。 大部分的 UI 库(不是所有的!)都趋向于第二个原因.这个事儿不是高深的事,但是把它做好却需要花费时间. 什么应该”外包”那么,我们通常应该怎么决定什么代码应该我们自己写,什么应该交给第三方组件呢? 著名的乔尔建议提供了非常好的依据: 如果是核心商业功能的话 就自己做 不管它是什么。 一个事实(并且比较残酷的)是几乎所有的 iOS app 正在向前端而不是后端发展。,因此我们应该考虑在内部尽可能多地进行 UI 开发 看起来就尤为重要。 有人可能会说这只是个人观点,所以让我们重新思考你是对第三方 UI 库使用的更详细原因。 UI库自身的问题通用 vs 特定有两种类型的控件/视图: 通用 允许你在很多场景 甚至是我们想不到的场景下使用 比如 UIKit 中的 UICollectionView . 特定 专门为一些特定的场景设计 比如 UIPickerView 大部分第三方库倾向于第二个分类.而且它们通常是在一个已存在并且在不断优化的代码库中取出.比如,还记得上个月看到的那个看起来非常酷的下拉刷新库吗?如果不修改控制器交互或下拉偏移量的话,它可能不太适合你 app 的设计或使用场景. 使用继承进行个性化就面向对象而言,由子类化转向组件化是行业趋势.当你选择第三方库的时候请确保没有违背这个趋势.在大多数情况下 你可以选择其他人做的一个组件,你只需要继承或者直接修改代码就好了.(代理模式也是接近组件化的方法之一.) 看起来过于定制化 一个第三方库内可见的 UI 元素越少越好,这听起来可能觉得有悖常理.高度定制化的控件或界面带来的问题就是它不可能满足所有的的需求来迎合所有的使用情景. 如果有大量的自定义 UI ,你可能无法回馈上游,因为你对于外观或感觉的想法可能和库的维护者不一样.这个时候你会自己维护一个库的fork代码.或者在 app 内添加一个丑陋的遮盖 仅仅是为了移除一条阴影.而在另一方面,一些库在UI层进行操作 但是没有或者几乎没有提供任何样式.想一想 SDWebImage 或者我的 SloppySwiper . 它们都可以不需要任何修改直接放进你的工程内. 未知的早期预设很多团队都会对内部代码进行代码审查, 但可能将第三方源代码的质量视为理所当然。花费点时间去浏览第三方库的源代码是值得的.你可能会看到一堆警告 比如在不需要的地方使用方法实现交换. 尝试着去了解下库的结构,你能否根据未来的需求尝试着去调整库,或者当 MVP 的时候后重写库吗? 你也应该考虑下库的维护情况,最近有多少次提交,多少个问题 是否做过任何的单元测试或者 UI测试? 忽略 GitHub 的星数,尽管它有时是很有意义的. 想法 &gt; 代码 ?我喜欢开源因为开源允许我去了解别人是怎么思考的,是怎么设计他们的方案的. 通常学习这个想法比获得这个代码本身更有意义. 如果一个库接触到了 UI 并且很小,通常从代码中获取灵感并且开发一个组件来完美适应你的工程是更明智的做法. 不能忽略它由于 UIKit 的设计方式,你可能几乎不能够忽略掉第三方 UI 库,比如 在一个适配器后面,一个库将会和你的 UI 代码交叉在一起,事实上已经变成了你工程里一等公民. 未来时间花费UIKit 会随着每个 iOS 版本进行变化,这时候就糟了,你的第三方依赖并不会像你想象的那样免于维护. ##结论在编程中经常会出现这种情况,很难提供一般规则,我们必须在代码库添加每一行代码的时候都要考虑一条又一条的规则.根据我的个人经验,使用大多数第三方UI库都是通过牺牲灵活性来节省一些时间. 我们利用现成的代码来更快地实现需求,但是迟早,我们将会被第三方库所限制 并作出艰难的决定:考虑接下来怎么办? 原文地址: http://holko.pl/2017/05/31/avoiding-ui-libraries/翻译: Swants]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS APP 崩溃日志分析]]></title>
    <url>%2F2017%2F05%2F11%2FiOS-APP-%E5%B4%A9%E6%BA%83%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[在日常开发中,我们难免遇到崩溃.如果是在开发过程中，我们可以直接通过 Xcode 来找到问题所在。如果是在测试的时候崩溃，我们也可以轻易的通过测试机导出 crash 进行问题定位。 可是一旦当产品上线之后，这一切就变得不那么容易了。庆幸的是市场上已经出现了一些比较好的第三方 crash 统计服务比如 bugly。 可以让我轻松了解到crash时的堆栈信息。 但是bugly也有符号化不到位的情况， 比如: 那么在这种情况下我们应该怎么办呢? 崩溃日志符号化使用xcode符号化 条件: (需要崩溃手机) 如果发生崩溃的手机在手边.可以连上电脑 在 Xcode 中的 organizer&gt;device 中直接查看符号化好的日志.优点: 操作简单缺点: 如果崩溃日志较多 还需要崩溃时间才能确定是哪个crash文件. crash不好统计 使用symbolicatecrash符号化条件: crash文件 dsYM 文件 symbolicatecrashsymbolicatecrash 位置 1(/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash) 方法: 将三个文件放在同级下 然后打开终端 进入文件夹目录下 设置环境变量 1export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer 符号化 12 ### symbol.crash 就是最后符号化好的文件 ###../symbolicatecrash ../.crash ../.dsym &gt; ../symbol.crash 优点:操作简单缺点:适合针对单个crash 文件符号化 使用 atos 命令符号化条件: dSYM 和堆栈信息使用 grep 命令 获取该模块的 指令集和加载起始地址 1grep "name armv" ../*.crash 然后用获得的指令集(armv7) 和起始地址(0x4000) 来符号化 12345xcrun atos -o ../.dsYM/../name -l 0x4000(起始地址) -arch -armv7(指令集) //输入目标地址 0x00352aee //得到结果 -[UIScrollView(UITouch) touchesEnded:withEvent:] (in appName) (UIScrollView+UITouch.h:26) 注意 模块只能定位到本模块的位置 不能越层 如:AFN.framework.dSYM 只能定位到AFN内的目标地址位置appName.app.dSYM 只能定位到app内代码的地址位置 优点: 只需要堆栈信息 和符号表就可以. 可以在获取不到Crash文件 但在bugly等第三方统计中获得了堆栈信息的情况下使用.缺点: 一次只能符号化一行,比较繁琐.(可以作为bugly符号化不完全情况下的补充.) 有兴趣的可以实际动手操作下:Xcode 自带 atos 脚本: symbolicatecrash 下载crash 文件 : demoAPP.crash 下载符号表: demoAPP.app.dSYM 下载第三方模块符号表 RBPlayer.framework.dSYM 下载 crash文件组成分析让我们看一下一个实际的 crash 文件组成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126### 1.进程信息 ###Incident Identifier: CDDADF33-6F8A-44B3-90D1-52D9095ADA0CCrashReporter Key: ed6929203307e230288ce2a758bd7099d3a52e15Hardware Model: iPhone5,2Process: demoApp [9806]Path: /private/var/containers/Bundle/Application/0C5CCF0C-6A7F-4864-BD5A-0765725E0CCB/demoApp.app/demoAppIdentifier: com.yimiao100.demoAppVersion: 6 (1.6)Code Type: ARM (Native)Role: ForegroundParent Process: launchd [1]Coalition: com.yimiao100.demoApp [3588]### 2.基本信息 ###Date/Time: 2017-05-10 10:37:51.2003 +0800Launch Time: 2017-05-10 10:36:26.0000 +0800OS Version: iPhone OS 10.3.1 (14E304)Report Version: 104### 3.异常信息 ###Exception Type: EXC_CRASH (SIGABRT)Exception Codes: 0x0000000000000000, 0x0000000000000000Exception Note: EXC_CORPSE_NOTIFYTriggered by Thread: 0Application Specific Information:abort() calledFiltered syslog:None foundLast Exception Backtrace:(0x1ceefb38 0x1c177062 0x1ceefa80 0x1fd6f826 0x1fd6f9de 0x1fd70044 0x148a244 0x14813e4 0x1ce9bdb4 0x1ce9b6f4 0x1ce9b4dc 0x1cef6304 0x1cdff030 0x1d74c0a8 0x1d750b26 0x147f440 0x237bff76 0x237c0622 0x237c1644 0x1c5bd792 0x1c5bd77e 0x1c5c1d00 0x1ceabd64 0x1cea9e14 0x1cdfd0ea 0x1cdfcf0c 0x1e5a7b3c 0x22181e7e 0x10b2a8 0x1c5ea4e6)### 4.线程回溯 ###Thread 0 name: Dispatch queue: com.apple.main-thread### Crash调用堆栈 ###Thread 0 Crashed:0 libsystem_kernel.dylib 0x1c6bdacc 0x1c6a8000 + 887801 libsystem_pthread.dylib 0x1c7760f6 0x1c771000 + 207262 libsystem_c.dylib 0x1c65295a 0x1c608000 + 3054983 libc++abi.dylib 0x1c157708 0x1c156000 + 58964 libc++abi.dylib 0x1c16e552 0x1c156000 + 996665 libobjc.A.dylib 0x1c17731e 0x1c170000 + 294706 demoApp 0x005b6e78 0x44000 + 57135287 libc++abi.dylib 0x1c16b98e 0x1c156000 + 884628 libc++abi.dylib 0x1c16b1a2 0x1c156000 + 864349 libobjc.A.dylib 0x1c177138 0x1c170000 + 2898410 CoreFoundation 0x1ceefa84 0x1cdf5000 + 102669211 QuartzCore 0x1fd6f82a 0x1fc7c000 + 99741812 QuartzCore 0x1fd6f9e2 0x1fc7c000 + 99785813 QuartzCore 0x1fd70048 0x1fc7c000 + 99949614 RBPlayer 0x0148a248 0x1477000 + 7840815 RBPlayer 0x014813e8 0x1477000 + 4196016 CoreFoundation 0x1ce9bdb8 0x1cdf5000 + 68344817 CoreFoundation 0x1ce9b6f8 0x1cdf5000 + 68172018 CoreFoundation 0x1ce9b4e0 0x1cdf5000 + 68118419 CoreFoundation 0x1cef6308 0x1cdf5000 + 105344820 CoreFoundation 0x1cdff034 0x1cdf5000 + 4101221 Foundation 0x1d74c0ac 0x1d746000 + 2474822 Foundation 0x1d750b2a 0x1d746000 + 4381823 RBPlayer 0x0147f444 0x1477000 + 3386024 AVFoundation 0x237bff7a 0x23759000 + 42175425 AVFoundation 0x237c0626 0x23759000 + 42346226 AVFoundation 0x237c1648 0x23759000 + 42759227 libdispatch.dylib 0x1c5bd796 0x1c5bc000 + 603828 libdispatch.dylib 0x1c5bd782 0x1c5bc000 + 601829 libdispatch.dylib 0x1c5c1d04 0x1c5bc000 + 2381230 CoreFoundation 0x1ceabd68 0x1cdf5000 + 74890431 CoreFoundation 0x1cea9e18 0x1cdf5000 + 74088832 CoreFoundation 0x1cdfd0ee 0x1cdf5000 + 3300633 CoreFoundation 0x1cdfcf10 0x1cdf5000 + 3252834 GraphicsServices 0x1e5a7b40 0x1e59e000 + 3974435 UIKit 0x22181e82 0x22110000 + 46656236 demoApp 0x0010b2ac 0x44000 + 81578837 libdyld.dylib 0x1c5ea4ea 0x1c5e7000 + 13546### 其他线程 ###Thread 1 name: Dispatch queue: com.apple.root.default-qosThread 1:0 libsystem_kernel.dylib 0x1c6bde7c 0x1c6a8000 + 897241 libsystem_c.dylib 0x1c6120e8 0x1c608000 + 411922 Foundation 0x1d834c36 0x1d746000 + 9779743 demoApp 0x00228310 0x44000 + 19832484 libdispatch.dylib 0x1c5bd796 0x1c5bc000 + 60385 libdispatch.dylib 0x1c5cab1c 0x1c5bc000 + 601886 libdispatch.dylib 0x1c5cc1b4 0x1c5bc000 + 659727 libdispatch.dylib 0x1c5cc00e 0x1c5bc000 + 655508 libsystem_pthread.dylib 0x1c7728ec 0x1c771000 + 63809 libsystem_pthread.dylib 0x1c7724cc 0x1c771000 + 5324Thread 2 name: com.apple.uikit.eventfetch-threadThread 2:0 libsystem_kernel.dylib 0x1c6a8900 0x1c6a8000 + 23041 libsystem_kernel.dylib 0x1c6a86e0 0x1c6a8000 + 17602 CoreFoundation 0x1ceabbe2 0x1cdf5000 + 7485143 CoreFoundation 0x1ceaa064 0x1cdf5000 + 741476...Thread 3 name: com.apple.NSURLConnectionLoaderThread 3:0 libsystem_kernel.dylib 0x1c6a8900 0x1c6a8000 + 23041 libsystem_kernel.dylib 0x1c6a86e0 0x1c6a8000 + 17602 CoreFoundation 0x1ceabbe2 0x1cdf5000 + 7485143 CoreFoundation 0x1ceaa064 0x1cdf5000 + 7414764 CoreFoundation 0x1cdfd0ee 0x1cdf5000 + 33006...... ...Thread 0 crashed with ARM Thread State (32-bit): r0: 0x00000000 r1: 0x00000000 r2: 0x00000000 r3: 0x0000006e r4: 0x00000006 r5: 0x3a697e40 r6: 0x397d430c r7: 0x00c88044 r8: 0x00000002 r9: 0x00000000 r10: 0x40000000 r11: 0x158ee214 ip: 0x00000148 sp: 0x00c88038 lr: 0x1c7760f7 pc: 0x1c6bdacc cpsr: 0x00000010### 5.动态库信息 ###Binary Images:0x44000 - 0x85ffff demoApp armv7 &lt;4d8140e3978f35d29c938c2659aa766d&gt; /var/containers/Bundle/Application/0C5CCF0C-6A7F-4864-BD5A-0765725E0CCB/demoApp.app/demoApp0xa4d000 - 0xa78fff AFNetworking armv7 &lt;f0d55a034b7f3eb7b90a1214a8639f1a&gt; /var/containers/Bundle/Application/0C5CCF0C-6A7F-4864-BD5A-0765725E0CCB/demoApp.app/Frameworks/AFNetworking.framework/AFNetworking0x1477000 - 0x1496fff RBPlayer armv7 &lt;f03427c9cf4e32ddae455c67d3a157ac&gt; /var/containers/Bundle/Application/0C5CCF0C-6A7F-4864-BD5A-0765725E0CCB/demoApp.app/Frameworks/RBPlayer.framework/RBPlayerEOF 进程信息第一部分是闪退进程的相关信息。 Incident Identifier是崩溃报告的唯一标识符。 CrashReporter Key是与设备标识相对应的唯一键值。虽然它不是真正的设备标识符，但也是一个非常有用的情报:如果你看到 100 个崩溃日志的 CrashReporter Key 值都是相同的，或者只有少数几个不同的 CrashReport 值，说明这不是一个普遍的问题，只发生在一个或少数几个设备上。 Hardware Model 标识设备类型。 如果很多崩溃日志都是来自相同的设备类型，说明应用只在某特定类型的设备上有问题。上面的日志里，崩溃日志产生的设备是 iPhone 5 。 Process 是应用名称。中括号里面的数字是闪退时应用的进程ID。 基本信息 VersionAPP的版本号 OS VersioniOS操作系统版本号 iPhone OS 10.3.1 (14E304)10.3.1：系统版本14E304：build 号这里要所以下 build 号。每个系统版本号有可能会对应多个 build 号。如苹果发布的 10.3.1 会有几个版本，如：电信版本、联通版本等。build 号我们后面对日志符号化的时候会用到。 异常信息在这部分，你可以看到闪退发生时抛出的异常类型。还能看到异常编码和抛出异常的线程。根据崩溃报告类型的不同，在这部分你还能看到一些另外的信息。 Crashed Threadcrash 线程号。可以根据这个编号找到对应的 crash 调用堆栈，当前crash 线程的编号为 0，所以我们可以直接找到 crash 线程的堆栈信息：12345678910111213141516171819202122232425262728293031323334353637383940Thread 0 name: Dispatch queue: com.apple.main-threadThread 0 Crashed:0 libsystem_kernel.dylib 0x1c6bdacc 0x1c6a8000 + 887801 libsystem_pthread.dylib 0x1c7760f6 0x1c771000 + 207262 libsystem_c.dylib 0x1c65295a 0x1c608000 + 3054983 libc++abi.dylib 0x1c157708 0x1c156000 + 58964 libc++abi.dylib 0x1c16e552 0x1c156000 + 996665 libobjc.A.dylib 0x1c17731e 0x1c170000 + 294706 demoApp 0x005b6e78 0x44000 + 57135287 libc++abi.dylib 0x1c16b98e 0x1c156000 + 884628 libc++abi.dylib 0x1c16b1a2 0x1c156000 + 864349 libobjc.A.dylib 0x1c177138 0x1c170000 + 2898410 CoreFoundation 0x1ceefa84 0x1cdf5000 + 102669211 QuartzCore 0x1fd6f82a 0x1fc7c000 + 99741812 QuartzCore 0x1fd6f9e2 0x1fc7c000 + 99785813 QuartzCore 0x1fd70048 0x1fc7c000 + 99949614 RBPlayer 0x0148a248 0x1477000 + 7840815 RBPlayer 0x014813e8 0x1477000 + 4196016 CoreFoundation 0x1ce9bdb8 0x1cdf5000 + 68344817 CoreFoundation 0x1ce9b6f8 0x1cdf5000 + 68172018 CoreFoundation 0x1ce9b4e0 0x1cdf5000 + 68118419 CoreFoundation 0x1cef6308 0x1cdf5000 + 105344820 CoreFoundation 0x1cdff034 0x1cdf5000 + 4101221 Foundation 0x1d74c0ac 0x1d746000 + 2474822 Foundation 0x1d750b2a 0x1d746000 + 4381823 RBPlayer 0x0147f444 0x1477000 + 3386024 AVFoundation 0x237bff7a 0x23759000 + 42175425 AVFoundation 0x237c0626 0x23759000 + 42346226 AVFoundation 0x237c1648 0x23759000 + 42759227 libdispatch.dylib 0x1c5bd796 0x1c5bc000 + 603828 libdispatch.dylib 0x1c5bd782 0x1c5bc000 + 601829 libdispatch.dylib 0x1c5c1d04 0x1c5bc000 + 2381230 CoreFoundation 0x1ceabd68 0x1cdf5000 + 74890431 CoreFoundation 0x1cea9e18 0x1cdf5000 + 74088832 CoreFoundation 0x1cdfd0ee 0x1cdf5000 + 3300633 CoreFoundation 0x1cdfcf10 0x1cdf5000 + 3252834 GraphicsServices 0x1e5a7b40 0x1e59e000 + 3974435 UIKit 0x22181e82 0x22110000 + 46656236 demoApp 0x0010b2ac 0x44000 + 81578837 libdyld.dylib 0x1c5ea4ea 0x1c5e7000 + 13546 线程回溯线程回溯这部分提供应用中所有线程的回溯日志。 回溯是闪退发生时所有活动帧清单。它包含闪退发生时调用函数的清单。Crash 调用堆栈这一部分是我们分析 crash 最重要的信息。一般我们会把焦点放在 crash 线程的堆栈上。因为这样可以帮我最快的找到 crash 的原因。 看下面这行日志: 16 demoApp 0x005b6e78 0x44000 + 5713528 这条调用栈包括下面四部分： 模块号：这里是 6 二进制库名：这里是 demoApp 调用方法的地址：这里是 0x005b6e78 第四部分分为两列，基地址和偏移地址。此处基地址为 0x66000，偏移地址为 19244367。基地址指向 crash 的模块（也是模块的 load 地址）如 UIKit。偏移地址指向 crash 代码的行数。如何转换我们后面讨论。这些信息都保存在 dsym 文件中。 动态库信息这些信息包括动态库名称、UUID、模块起始地址、模块结束地址、指令集种类、安装路径等信息。这些信息都是在符号化堆栈用到的。后面我们讨论怎么用。 特别注意 注意: 你必需同时保留应用二进制文件和 .dSYM 文件才能将崩溃日志完整符号化。每次提交到 iTunes Connect 的构建都必需归档保存。.dSYM 文件和二进制文件是特定绑定于每一次构建和后续构建的，即使来自相同的源代码文件，每一次构建也与其他构建不同，不能相互替换。如果你使用 Build 和 Archive 命令,这些文件会自动放在适当位置。 如果不是使用 Build 和 Archive 命令，最好放到单独的文件夹保存。 附录符号化好的crash文件 12345678910111213141516171819202122232425262728293031 Last Exception Backtrace:0 CoreFoundation 0x1ceefb38 __exceptionPreprocess + 1241 libobjc.A.dylib 0x1c177062 objc_exception_throw + 342 CoreFoundation 0x1ceefa80 +[NSException raise:format:] + 1043 QuartzCore 0x1fd6f826 CA::Layer::set_position(CA::Vec2&lt;double&gt; const&amp;, bool) + 2344 QuartzCore 0x1fd6f9de -[CALayer setPosition:] + 505 QuartzCore 0x1fd70044 -[CALayer setFrame:] + 4846 RBPlayer 0x01483244 -[RBPlayerSlider setValue:] (RBPlayerSlider.m:194)7 RBPlayer 0x0147a3e4 -[RBPlayerBottomMask playerUpdateCurrentSeconds] (RBPlayerBottomMask.m:111)8 CoreFoundation 0x1ce9bdb4 __CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 69 CoreFoundation 0x1ce9b6f4 _CFXRegistrationPost + 37810 CoreFoundation 0x1ce9b4dc ___CFXNotificationPost_block_invoke + 3611 CoreFoundation 0x1cef6304 -[_CFXNotificationRegistrar find:object:observer:enumerator:] + 123812 CoreFoundation 0x1cdff030 _CFXNotificationPost + 53613 Foundation 0x1d74c0a8 -[NSNotificationCenter postNotificationName:object:userInfo:] + 6214 Foundation 0x1d750b26 -[NSNotificationCenter postNotificationName:object:] + 2615 RBPlayer 0x01478440 __32-[RBCorePlayer addTimerObserver]_block_invoke (RBCorePlayer.m:243)16 AVFoundation 0x237bff76 -[AVPeriodicTimebaseObserver _fireBlockForTime:] + 6417 AVFoundation 0x237c0622 -[AVPeriodicTimebaseObserver _handleTimeDiscontinuity] + 23418 AVFoundation 0x237c1644 __AVTimebaseObserver_timebaseNotificationCallback_block_invoke + 12219 libdispatch.dylib 0x1c5bd792 _dispatch_call_block_and_release + 620 libdispatch.dylib 0x1c5bd77e _dispatch_client_callout + 1821 libdispatch.dylib 0x1c5c1d00 _dispatch_main_queue_callback_4CF + 89822 CoreFoundation 0x1ceabd64 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 423 CoreFoundation 0x1cea9e14 __CFRunLoopRun + 84424 CoreFoundation 0x1cdfd0ea CFRunLoopRunSpecific + 46625 CoreFoundation 0x1cdfcf0c CFRunLoopRunInMode + 10026 GraphicsServices 0x1e5a7b3c GSEventRunModal + 7627 UIKit 0x22181e7e UIApplicationMain + 14628 VaccineSale 0x001042a8 main (main.m:15)29 libdyld.dylib 0x1c5ea4e6 _dyld_process_info_notify_release + 26 从符号化完的堆栈信息可以清楚的看出 崩溃是由 RBPlayer 类 RBPlayerSlider 文件 setValue: 方法中 第 194 行引起的. 该行对 layer 的 frame 和 position 进行赋值操作时引起了崩溃. –原创所有,转载请注明出处。]]></content>
      <tags>
        <tag>crash 符号化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CALayer 入门指引]]></title>
    <url>%2F2016%2F10%2F04%2FCALayer-%E5%85%A5%E9%97%A8%E6%8C%87%E5%BC%95.html</url>
    <content type="text"><![CDATA[本篇文章将会介绍 iOS 中一个老生常谈的话题: layers .你可能已经熟悉iOS中各种各样的views,但可能还不知道每一个view背后都有一个叫做 layer 的东西存在.而layers是组成 Core Animation framework 的重要一部分. 你可能还不了解 layer 的作用,甚至觉得自己从来不曾使用过 layer ,它可能是一个无足轻重的东西, 不管你是否了解 layer ,你的app中到处都是 layer 的身影.你app中每个 view 的背后都有个 layer 在支撑.是它让你的 app 轻松地将每个 view 的位图信息提供给手机 GPUs 绘制.下面的这张图片清楚的展示了 Core Animation 在 iOS 绘制层级中的位置. 为什么要使用 Layers?在智能手机上,用户希望能够飞速的进行各种操作.所以保持界面稳定的刷新帧率给用户丝滑般的感觉就显得尤为重要.在 iOS 系统中屏幕平均每秒钟刷新 60 次,为了保证系统在这个帧率下稳定运行,最基本同时也最强大的能够在 GPU 上精准运行的 OpenGL 就诞生了.OpenGL 提供了手机图形硬件最低层但也是最快的权限.但这也是需要权衡的,OpenGL过于低层,甚至完成最简单的任务都需要大量的代码. 为了缓解这个问题, Core Graphocs 就诞生了. Core Graphocs 可以用更少的代码提供更轻量的高层次的功能.为了让 Core Graphocs 使用起来更简单, Core Animation 也出现了. Core Animation 提供了 CALayer 类,并且能够使用一些基本的的图形能力. 后来苹果公司发现 Core Animation 强大的功能大部分在常规app内并没有使用到.于是苹果公司便推出了具有更高层次图形权限的 UIKit. 这么设计的好处就是你的 app 可以根据需求自由选择不同的图形层次功能.允许灵活选择需要实现的功能有效的防止了不必要的代码产生. UIKit 缺点就是高层次的图形 API 所能提供的功能比较少.我们可以这件事中知道: CALayer 可以让 iOS 系统快速便捷地获得 app 页面上 views 的位图信息, 这些信息将会交付给 Core Graphics 甚至 OpenGL处理 然后通过 GPU 绘制在你的手机屏幕上. 虽然在大部分的情况下我们不需要直接使用 CALayer, 但是低层次的 APIs 提供给开发者很多灵活可定制的功能,我们在文章后面将会提到. 获得 CALayer通过讨论 layers 为什么存在之后, 让我们来学着去使用! 就像我刚才提到的, 每一个 view 的背后都有个 layer 支撑. 我们可以通过 UIView 的属性来获得这个 layer. 假使我们有一个 myView 对象, 我们可以得到它的 layer 就像这样: 1myView.layer 好了, 当我们拿到 view 的 layer 之后都能做些什么操作呢? 你将会对之后我们能做的事之多感到惊奇. 在接下来的文章中我们将会看到 layer 的一些使用方法和所能达到的效果. Demo Project首先, 打开 示例工程 ,学习的最好方法就是实践,接下来我们将要在 app 内的 layer 上添加一些自定义的效果. 打开工程 你将会看到界面很简洁,一个空白的 view 中间有一个方块的 subview. 让我们来帮它美化下. 打开 ViewController.swift 开始操作吧. 切圆角你可以使用 CALayer 的 cornerRadius 属性来制作圆角. 让我们试一下吧. 在 viewDidLoad() 内 添加如下代码: 1box.layer.cornerRadius = 5 正如期望的那样,这行代码在 box 的 layer 上添加了一个 5个点单位的圆角. 就是下面这个样子: 还不错吧! 增加圆角弧度会让 layer 更加的圆滑,相反减少圆角弧度 会让layer 更加的棱角分明. 所有的 layer 默认的圆角弧度是 0 . 增加阴影效果阴影可以让我们的 app 更有立体感,并且阴影在设计界面的时候是非常有帮助的.在阴影效果下 我们可以让 views 看起来像漂浮在屏幕上. 让我们研究下用 CALayer 如何制作出隐形效果. 把下面代码插入到 ViewController 的 viewDidLoad 方法中: 1234box.layer.shadowOffset = CGSizeMake(5, 5)box.layer.shadowOpacity = 0.7box.layer.shadowRadius = 5box.layer.shadowColor = UIColor(red: 44.0/255.0, green: 62.0/255.0, blue: 80.0/255.0, alpha: 1.0).CGColor 第一行 设置 layer 的阴影偏移量是 (5,5). 将阴影的 layer.shadowOffset 设置(5,5), 意味着这个 layer 的阴影是到 box.layer 右边 5 个点单位距离, 下边 5 个单位的距离.第二行 设置 layer 的阴影透明度是 0.7 . 意味着这个阴影应该是70%的不透明度.第三行 设置的是 layer 的阴影半径是5个点. 阴影的范围是 box.layer 的模糊弧度决定的.更高的弧度会让阴影的范围更广,但是更加模糊不可见.更低的弧度会让阴影更加清晰可见度更高. 第四行 设置的是阴影的颜色是深蓝. 注意这里的颜色属性是 CGColor 类型. 而不是 UIColor. 这两个颜色类的转换是非常简单的,你只需要写成 myUIColor.CGColor. 让我们看一下效果: 添加边框 我们能够轻易地使用 CALayer 添加边框.让我们给 box 添加一个边框. 12box.layer.borderColor = UIColor.blueColor().CGColorbox.layer.borderWidth = 3 第一行 设置 box 的边框颜色是蓝色.这将会让 box 的所有边框都是蓝色的.第二行 设置边框线条的宽度是 3 点. 也就是 box 的边框厚度是 3 个点的单位. 让我们看一下 box添加边框之后的效果: 渲染图片你也可以吧一张图片赋值给 layer 这样 layer 就会将这张图片渲染出来. 在这里有一张树的图片, 让我们试着用 layer 来显示这张图片.把下面的代码插入到 viewDidLoad: 123box.layer.contents = UIImage(named: &quot;tree.jpg&quot;)?.CGImagebox.layer.contentsGravity = kCAGravityResizebox.layer.masksToBounds = true 第一行 将图片赋值给 layer 的 contents 属性.第二行 将 layer 的内容这是成自适应大小, 图片会自适应 layer 大小.第三行 将 layer 的任何 扩展到 layer 外的子 layer 部分都剪切掉.如果你不明白是什么意思.你可以将 masksToBounds 设置成 false 来看看他们的区别 (阴影被裁剪掉了): 背景颜色和不透明度研究了在 layer 添加一些 UIKit 无法实现的特殊效果. 我们也应该讨论下通过 CALayer 来修改 UIKit 类的属性的可能性. 比如 你可以修改 view 的背景颜色和不透明度: 12box.layer.backgroundColor = UIColor.blueColor().CGColorbox.layer.opacity = 0.5 CALayer 的性能在 layers 上添加太多的特殊效果会影响到性能, 现在我们来聊一聊可以帮助我们提高 app 性能的 2 个 CALayer 属性. 首先是 drawsAsynchronously 属性.这个属性决定 CPU 是否应该在子线程里渲染 layer. 如果设置成 true, 这个 layer 看起来像我们平时看到的样子, 但是 CPU 需要在子线程中来计算和渲染它.如果你的 app 里面有一个 view 需要频繁重绘(比如一个地图view 或者 tableView),你需要将这个属性设置为 true; 第二个属性是 shouldRasterize,这个属性决定这 layer 是否会栅格化.当这个属性设置为 true 后,这个 layer 只会被绘制一次,当它具有动画时 layer不会被渲染 并且第一次绘制的位图信息将会被回收.当你的app有一个不需要频繁绘制的 view 时 你可以把这个属性设置为 true. 注意 当你设置了shouldRasterize属性后,layer 的外观可能在 Retina 屏上有锯齿. 这是因为 layer 有一个控制 layer 的栅格化因子 rasterizationScale.为了防止这种情况. 将 layer 的 rasterizationScale 设置成 UIScreen.mainScreen().scale 这样就不会出现锯齿了. 栅格化 是PS中的一个专业术语，栅格即像素，栅格化即将矢量图形转化为位图。开启 shouldRasterize 后, CALayer 会被栅格化为 bitmap , layer 的阴影等效果也会被保存到 bitmap 中。 避免 shouldRasterize 和 drawsAsynchronously 的过度使用当我们开启光栅化后,需要注意三点问题。 如果我们更新已光栅化的layer,会造成大量的 offscreen 渲染。 offscreen rendring指的是在图像在绘制到当前屏幕前,需要先进行一次渲染,之后才绘制到当前屏幕。offscreen渲染会耗费大量资源. 因此 CALayer 的光栅化选项的开启与否需要我们仔细衡量使用场景。 只能用在图像内容不变的前提下的： 用于避免静态内容的复杂特效的重绘,例如前面讲到的UIBlurEffect用于避免多个View嵌套的复杂View的重绘。而对于经常变动的内容,这个时候不要开启,否则会造成性能的浪费。 例如我们日程经常打交道的 TableViewCell ,因为 TableViewCell 的重绘是很频繁的（因为Cell 的复用）,如果Cell的内容不断变化,则 Cell 需要不断重绘,如果此时设置了cell.layer 可光栅化。则会造成大量的 offscreen 渲染,降低图形性能。 当然,合理利用的话,是能够得到不少性能的提高的,因为使用 shouldRasterize 后 layer 会缓存为Bitmap位图,对一些添加了 shawdow 等效果的耗费资源较多的静态内容进行缓存,能够得到性能的提升。 不要过度使用,系统限制了缓存的大小为 2.5 x Screen Size.如果过度使用,超出缓存之后,同样会造成大量的 offscreen 渲染。被光栅化的图片如果超过 100ms 没有被使用,则会被移除 因此我们应该只对连续不断使用的图片进行缓存。对于不常使用的图片缓存是没有意义,且耗费资源的。 基于 99% 的情况下 你都不需要手动设置这两个属性.不当的设置它们可能会反而导致你 app 的性能变得更糟. 题外 关于 offscreen rendering 注意到上面提到的 offscreen rendering 。我们需要注意 shouldRasterize 的地方就是会造成 offscreen rendering 的地方,那么为什么需要避免呢？WWDC 2011 Understanding UIKit Rendering 指出一般导致图形性能的问题大部分都出在了 offscreen rendering ,因此如果我们发现列表滚动不流畅,动画卡顿等问题,就可以想想和找出我们哪部分代码导致了大量的 offscreen 渲染。那么为什么 offscreen 渲染会耗费大量资源呢？原因是显卡需要另外 alloc 一块内存来进行渲染,渲染完毕后在绘制到当前屏幕,而且对于显卡来说, onscreen 到 offscreen 的上下文环境切换是非常昂贵的(涉及到 OpenGL 的 pipelines 和 barrier 等),我们在开发应用,提高性能通常要注意的是避免 offscreen rendering 。不需要纠结和拘泥于它的定义.有兴趣可以继续阅读 Andy Matuschak , 前 UIKit team 成员关于offscreen rendering 的 评论 。 总之,我们通常需要避免大量的offscreen rendering.会造成 offscreen rendering的原因有：Any layer with a mask (layer.mask)Any layer with layer.masksToBounds being trueAny layer with layer.allowsGroupOpacity set to YES and layer.opacity is less than 1.0Any layer with a drop shadow (layer.shadow*).Any layer with layer.shouldRasterize being trueAny layer with layer.cornerRadius, layer.edgeAntialiasingMask,layer.allowsEdgeAntialiasing 因此,对于一些需要优化图像性能的场景,我们可以检查我们是否触发了 offscreen rendering 。并用更高效的实现手段来替换。阴影绘制:裁剪图片为圆:Blending 的过多使用检查有无过多offscreen渲染检查有无过多Blending检查有无不正确图片格式,图片是否被放缩,像素是否对齐。检查有无使用复杂的图形效果。 – 原创所有,转载请注明出处。]]></content>
      <tags>
        <tag>CALayer</tag>
      </tags>
  </entry>
</search>